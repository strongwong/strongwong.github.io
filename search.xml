<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FPGA 数字图像处理联合仿真平台的搭建及使用举例</title>
    <url>//posts/FPGA-%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%81%94%E5%90%88%E4%BB%BF%E7%9C%9F%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着物联网技术的不断发展，对边缘计算的性能要求愈发苛刻，传统的 IoT 级别的 SoC 或者 MCU 难以应对诸如图像识别的场景需求，因此 FPGA + MCU 或 FPGA + SoC 的异构架构愈来愈多地应用于上述场景中，以满足相关需求。（以上这段话毫无意义，只是为了凑字数，另外为了纪念第三次憾负的开场白）</p>
<a id="more"></a>

<p>当前 FPGA 发展火热，众多开发者使用 FPGA 来完成部分图像处理的部分功能，但众所周知纯 FPGA 开发（或者数字 IC 设计）与常见的 ARM A 系列（with OS）或者桌面端 PC 在图像处理开发过程中最大的差别在于过程的可视化。开发过程中的可视化多少会影响到开发者对于图像处理的判断与取舍，简而言之，如果开发者都不知道经过了这一步处理后图像变成了什么样，那还如何继续接下来的步骤。因此分享交流一下在本次车牌识别设计中我们所用到的数字图像处理的联合仿真平台（<em>注：本文仅仅介绍平台使用方式，不介绍过程中涉及到的数字图像处理原理</em>），如果有更好的方式，希望大家可以留言给予建议~</p>
<h2 id="首先是我们所需要的软件工具："><a href="#首先是我们所需要的软件工具：" class="headerlink" title="首先是我们所需要的软件工具："></a>首先是我们所需要的软件工具：</h2><p>本次我们的开发环境为 Win10 所用到的软件工具分别为：<code>Modelsim(10.5B)</code>, <code>MATLAB(R2019a)</code></p>
<p>然后简述一下我们的操作过程（以图片 RGB 色域转换 YCbCr 色域处理为例），整体过程可简述如下：通过 MATLAB 将图片文件转换为 <code>.txt</code> 格式文件，使用 Verilog 读取相应文件后完成相应图像处理操作后输出为 <code>.txt</code> 文件，再次使用 MATLAB 将输出的 <code>.txt</code> 格式文件转换为图片文件并查看。以上步骤的意义在于不仅可以实现数字图像处理的单步可视化，还可以同原始的 MATLAB 对应的处理效果进行对比。(后期我们也会更新，直接使用 Verilog 完成图像读取并输出结果查看的方法)</p>
<p>首先我们通过以下程序(亦可查看附带工程中的 <code>IMG2TXT.m</code> 文件)在 MATLAB 端将图片生成 R,G,B 色域对应的 <code>.txt</code> 格式文件。并同时通过 MATLAB 生成 YCbCr 色域下三个分量的图像予以显示。<br>其关键代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">clc</span><br><span class="line">img = imread(<span class="string">'test.jpg'</span>);</span><br><span class="line">[a,b,c]= <span class="built_in">size</span>(img);</span><br><span class="line">R1=img(:,:,<span class="number">1</span>);</span><br><span class="line">G1=img(:,:,<span class="number">2</span>);</span><br><span class="line">B1=img(:,:,<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">fidR1= fopen(<span class="string">'testR.txt'</span>,<span class="string">'w'</span>);</span><br><span class="line">fidG1= fopen(<span class="string">'testG.txt'</span>,<span class="string">'w'</span>);</span><br><span class="line">fidB1= fopen(<span class="string">'testB.txt'</span>,<span class="string">'w'</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:a</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>= <span class="number">1</span>:b</span><br><span class="line">      fprintf(fidR1,<span class="string">'%d\n'</span>,R1(<span class="built_in">i</span>,<span class="built_in">j</span>)); <span class="comment">%frame1</span></span><br><span class="line">      fprintf(fidG1,<span class="string">'%d\n'</span>,G1(<span class="built_in">i</span>,<span class="built_in">j</span>));</span><br><span class="line">      fprintf(fidB1,<span class="string">'%d\n'</span>,B1(<span class="built_in">i</span>,<span class="built_in">j</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">fclose(fidR1);</span><br><span class="line">fclose(fidG1);</span><br><span class="line">fclose(fidB1);</span><br></pre></td></tr></table></figure>

<h2 id="RGB-色域文件生成"><a href="#RGB-色域文件生成" class="headerlink" title="RGB 色域文件生成"></a>RGB 色域文件生成</h2><p>生成对应 RGB 色域 <code>.txt</code> 格式文件如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/09/02/nidDTs.png" alt="RGB.txt"></p>
<p>生成 YCbCr 色域对应分量图片(详见工程文件 <code>YCbCr.m</code> )，如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/09/02/niwnNn.png" alt="YCbCr"></p>
<h2 id="Verilog-处理"><a href="#Verilog-处理" class="headerlink" title="Verilog 处理"></a>Verilog 处理</h2><p>然后在我们的 Modelsim 工程中对 <code>.txt</code> 格式文件进行读取(亦可查看工程中附带的 imread.v 文件)，进一步的完成图像处理对应的操作后，输出对应 <code>.txt</code> 格式文件（亦可查看工程中附带 imwrite.v 文件）。<br>其 txt 读取关键代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  fR = <span class="built_in">$fopen</span>(<span class="string">"testR.txt"</span>,<span class="string">"r"</span>);   <span class="comment">// read in testR.txt</span></span><br><span class="line">  fG = <span class="built_in">$fopen</span>(<span class="string">"testG.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">  fB = <span class="built_in">$fopen</span>(<span class="string">"testB.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">if</span>(fR == <span class="meta">`NULL || fG == `NULL || fB == `NULL) begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"data_file handle was NULL"</span>);</span><br><span class="line">	<span class="built_in">$finish</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$fscanf</span>(fR,<span class="string">"%d;\n"</span>,R);</span><br><span class="line">	<span class="built_in">$fscanf</span>(fG,<span class="string">"%d;\n"</span>,G);</span><br><span class="line">	<span class="built_in">$fscanf</span>(fB,<span class="string">"%d;\n"</span>,B);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>	</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> pixel_clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset_n) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span>(reset_n == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">    R = <span class="number">8'd0</span>;</span><br><span class="line">	G = <span class="number">8'd0</span>;</span><br><span class="line">	B = <span class="number">8'd0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(de) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(fR != <span class="number">0</span> &amp;&amp; fG != <span class="number">0</span> &amp;&amp; fB != <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">	 <span class="built_in">$fscanf</span>(fR,<span class="string">"%d;\n"</span>,R);</span><br><span class="line">	 <span class="built_in">$fscanf</span>(fG,<span class="string">"%d;\n"</span>,G);</span><br><span class="line">	 <span class="built_in">$fscanf</span>(fB,<span class="string">"%d;\n"</span>,B);</span><br><span class="line">	 <span class="built_in">$display</span>(<span class="string">"time=[%d],%d,%d,%d"</span>,<span class="built_in">$realtime</span>,R,G,B);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>完成处理后生成 txt 关键代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  fR = <span class="built_in">$fopen</span>(<span class="string">"R.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line">  fG = <span class="built_in">$fopen</span>(<span class="string">"G.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line">  fB = <span class="built_in">$fopen</span>(<span class="string">"B.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line">  <span class="keyword">if</span>(fR == <span class="meta">`NULL || fG == `NULL || fB == `NULL) begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"can not open R.txt or G.txt or B.txt"</span>);</span><br><span class="line">	<span class="built_in">$finish</span>;</span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> pixel_clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset_n) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span>(de) <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"////////////////////////////////////"</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"time=[%d],%d,%d,%d"</span>,<span class="built_in">$realtime</span>,R,G,B);</span><br><span class="line">    <span class="built_in">$fwrite</span>(fR,<span class="string">"%d\n"</span>,R);</span><br><span class="line">	<span class="built_in">$fwrite</span>(fG,<span class="string">"%d\n"</span>,G);</span><br><span class="line">	<span class="built_in">$fwrite</span>(fB,<span class="string">"%d\n"</span>,B);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="处理结果"><a href="#处理结果" class="headerlink" title="处理结果"></a>处理结果</h2><p>最终在 MATLAB 端将仿真生成输出的 <code>.txt</code> 文件转换还原为图片（亦可查看工程中附带的 TXT2IMG.M 文件）。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line">clc</span><br><span class="line"> </span><br><span class="line">imgori = imread(<span class="string">'test.jpg'</span>);</span><br><span class="line">[a,b,c]= <span class="built_in">size</span>(imgori);</span><br><span class="line"> </span><br><span class="line">img1R = uint8(textread(<span class="string">'R.txt'</span>,<span class="string">'%u'</span>));</span><br><span class="line">img1G = uint8(textread(<span class="string">'G.txt'</span>,<span class="string">'%u'</span>));</span><br><span class="line">img1B = uint8(textread(<span class="string">'B.txt'</span>,<span class="string">'%u'</span>));</span><br><span class="line"> </span><br><span class="line">img1(:,:,<span class="number">1</span>) = <span class="built_in">reshape</span>(img1R,[b,a]);</span><br><span class="line">img1(:,:,<span class="number">2</span>) = <span class="built_in">reshape</span>(img1G,[b,a]);</span><br><span class="line">img1(:,:,<span class="number">3</span>) = <span class="built_in">reshape</span>(img1B,[b,a]);</span><br><span class="line"> </span><br><span class="line">img=<span class="built_in">flipdim</span>(img1,<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">figure</span>,</span><br><span class="line">subplot(<span class="number">221</span>),imshow(imrotate(img,<span class="number">-90</span>)),title(<span class="string">'YCbCr'</span>);</span><br><span class="line">subplot(<span class="number">222</span>),imshow(imrotate(img(:,:,<span class="number">1</span>),<span class="number">-90</span>)),title(<span class="string">'Y'</span>);</span><br><span class="line">subplot(<span class="number">223</span>),imshow(imrotate(img(:,:,<span class="number">2</span>),<span class="number">-90</span>)),title(<span class="string">'Cb'</span>);</span><br><span class="line">subplot(<span class="number">224</span>),imshow(imrotate(img(:,:,<span class="number">3</span>),<span class="number">-90</span>)),title(<span class="string">'Cr'</span>);</span><br></pre></td></tr></table></figure>

<p>由于常见的 FPGA 数字图像处理为了减少数据读取对于缓存资源的消耗，通常其处理步骤在视频流完成，因此本次工程中我们在 VGA 模拟时序中完成相应操作。完成仿真如波形下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/09/02/ni04iR.png" alt="Waveform"></p>
<p>生成结果 <code>.txt</code> 文件如下图所示:<br><img src="https://s2.ax1x.com/2019/09/02/ni0Xod.png" alt="Outfile"></p>
<p>将生成结果 <code>.txt</code> 文件放回 MATLAB 工程路径下最终实现效果如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/09/02/niB6fI.png" alt="Outfile of FPGA"></p>
<h2 id="MATLAB-vs-HDL数字图像处理-结果对比"><a href="#MATLAB-vs-HDL数字图像处理-结果对比" class="headerlink" title="MATLAB vs HDL数字图像处理 结果对比"></a>MATLAB vs HDL数字图像处理 结果对比</h2><p>将图像放大后，可以明显发现通过数字思想处理得到的图片结果相较于 MATLAB 直接转换得到的结果存在一定的差距，Cr 分量下表现的最为明显，具体原因在此不具体展开分析。其对比如下图（<em>注：左侧为 MATLAB 处理结果右侧为 verilog 处理结果</em>）</p>
<p><img src="https://s2.ax1x.com/2019/09/02/niwkjS.png" alt="Matlab vs HDL"></p>
<p>之后我们将逐步介绍本次我们 ARM 杯车牌识别系统的每个实现过程~</p>
<p> <font color=#FF0000 size=6>  并公开全套设计源码！！！ </font></p>
<p>举例部分全部代码详见 GitHub 仓库：<a href="https://github.com/strongwong/FPGA-DIP" target="_blank" rel="noopener">https://github.com/strongwong/FPGA-DIP</a></p>
<p><strong>By Ricky</strong></p>
]]></content>
      <categories>
        <category>IC Design</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
        <tag>FPGA仿真</tag>
        <tag>Verilog</tag>
        <tag>IC Design</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS 基础知识</title>
    <url>//posts/ROS-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<h3 id="ROS-基础知识"><a href="#ROS-基础知识" class="headerlink" title="ROS 基础知识"></a>ROS 基础知识</h3><p>上一篇，我们已经正确的安装好了 ROS ，但是在使用 ROS 进行机器人开发工作之前，我们先来了解一点 ROS 的基础知识，以便于后面的开发使用。当然我这里自然是没有 ROS wiki 上介绍的详细，要想学习更多的操作请先看 ROS wiki 上的<a href="http://wiki.ros.org/cn/ROS/StartGuide" target="_blank" rel="noopener">入门教程</a><br>这里我只简单介绍一下，在我的项目中会用到的一些操作。</p>
<a id="more"></a>

<h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><p>ROS 使用一个名为 catkin 的 ROS 专用构建系统。为了使用它，用户需要创建并初始化 catkin 工作空间，如下所示。除非用户创建新的工作空间，否则此设置只需设置一次。工作空间（ workspace ）简单来说就是一个存放工程开发相关文件的文件夹。主要目录结构如下：</p>
<ul>
<li>src: 代码空间 ( source space )</li>
<li>build: 编译空间 ( build space )</li>
<li>devel: 开发空间 ( development space )</li>
<li>install: 安装空间 ( install space )</li>
</ul>
<p><img src="https://ww3.sinaimg.cn/large/005YhI8igy1fuvaso3mffj30lf0jfq3c" alt="catkin 编译系统下的工作空间结构"></p>
<h4 id="创建工作空间-1"><a href="#创建工作空间-1" class="headerlink" title="创建工作空间"></a>创建工作空间</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p ~/catkin_ws/src   <span class="comment"># 创建工作空间机源码空间</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">$ catkin_init_workspace      <span class="comment"># 初始化工作空间</span></span><br></pre></td></tr></table></figure>
<h4 id="编译工作空间"><a href="#编译工作空间" class="headerlink" title="编译工作空间"></a>编译工作空间</h4><p>目前，只有 src 目录和 CMakeLists.txt 文件(运行初始化命令后就会生成)在 catkin 工作目录中，即使 src 目录中没有源代码，我们仍然可以使用 catkin_make 命令来进行构建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure>
<p>如果构建没有问题，运行 ls 命令。除了自己创建的 src 目录之外，还出现了一个新的 build 和 devel 目录。 catkin 的构建系统的相关文件保存在 build 目录中，构建后的可执行文件保存在 devel 目录中。</p>
<h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure>
<h4 id="检查环境变量"><a href="#检查环境变量" class="headerlink" title="检查环境变量"></a>检查环境变量</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br><span class="line">/home/ubuntu/catkin_ws/src:/opt/ros/kinetic/share:/opt/ros/kinetic/stacks</span><br></pre></td></tr></table></figure>

<h3 id="创建功能包"><a href="#创建功能包" class="headerlink" title="创建功能包"></a>创建功能包</h3><p>一个功能包它是是构成 ROS 的基本单元。 ROS 应用程序是以功能包为单位开发的。功能包包括至少一个以上的节点或拥有用于运行其他功能包的节点的配置文件。它还包含功能包所需的所有文件，如用于运行各种进程的 ROS 依赖库、数据集和配置文件等。</p>
<h4 id="创建功能包-1"><a href="#创建功能包-1" class="headerlink" title="创建功能包"></a>创建功能包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line"><span class="comment"># 创建功能包命令格式如下：</span></span><br><span class="line">$ catkin_create_pkg [功能包名称] [依赖功能包 1] [依赖功能包 n]</span><br></pre></td></tr></table></figure>
<p>「catkin_create_pkg」命令在创建用户功能包时会生成 catkin 构建系统所需的 CMakeLists.txt 和 package.xml 文件的包目录。<br><strong>注：同一个工作空间下，不允许存在同名功能包；在不同工作空间下，允许存在同名功能包。</strong></p>
<h4 id="编译功能包"><a href="#编译功能包" class="headerlink" title="编译功能包"></a>编译功能包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure>

<h3 id="ROS-通信"><a href="#ROS-通信" class="headerlink" title="ROS 通信"></a>ROS 通信</h3><p>为了最大化用户的可重用性，ROS 是以节点的形式开发的，而节点是根据其目的细分的可执行程序的最小单位。节点则通过消息（ message ）与其他的节点交换数据，最终成为一个大型的程序。这里的关键概念是节点之间的消息通信，它分为三种。单向消息发送/接收方式的话题（ topic ）；双向消息请求/响应方式的服务（ service ）；双向消息目标（ goal ）/结果（ result ）/反馈（ feedback ）方式的动作（ action ）。另外，节点中使用的参数可以从外部进行修改。这在大的框架中也可以被看作消息通信。如下图所示：<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1.jpg" alt=""></p>
<table>
<thead>
<tr>
<th align="center">种类</th>
<th align="center">区别</th>
<th align="center">方向</th>
<th align="center">响应</th>
</tr>
</thead>
<tbody><tr>
<td align="center">话题</td>
<td align="center">异步</td>
<td align="center">单向</td>
<td align="center">连续单向地发送/接收数据的情况</td>
</tr>
<tr>
<td align="center">服务</td>
<td align="center">同步</td>
<td align="center">双向</td>
<td align="center">需要对请求给出即时响应的情况</td>
</tr>
<tr>
<td align="center">动作</td>
<td align="center">异步</td>
<td align="center">双向</td>
<td align="center">请求与响应之间需要太长的时间，所以难以使用服务的情况，或需要中途反馈值的情况</td>
</tr>
</tbody></table>
<h4 id="话题通信"><a href="#话题通信" class="headerlink" title="话题通信"></a>话题通信</h4><p>话题消息通信是指发送信息的发布者和接收信息的订阅者以话题消息的形式发送和接收信息。希望接收话题的订阅者节点接收的是与在主节点中注册的话题名称对应的发布者节点的信息。基于这个信息，订阅者节点直接连接到发布者节点来发送和接收消息。另外，单个发布者可以与多个订阅者进行通信，相反，一个订阅者可以在单个话题上与多个发布者进行通信。当然，这两家发布者都可以和多个订阅者进行通信。</p>
<h4 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h4><p>服务消息通信是指请求服务的服务客户端与负责服务响应的服务服务器之间的同步双向服务消息通信。前述的发布和订阅概念的话题通信方法是一种异步方法，是根据需要传输和接收给定数据的一种非常好的方法。然而，在某些情况下，需要一种同时使用请求和响应的同步消息交换方案。因此，ROS 提供叫做服务的消息同步方法。<br>一个服务被分成服务服务器和服务客户端，其中服务服务器只在有请求（ request ）的时候才响应（response），而服务客户端会在发送请求后接收响应。与话题不同，服务是一次性消息通信。因此，当服务的请求和响应完成时，两个连接的节点将被断开。该服务通常被用作请求机器人执行特定操作时使用的命令，或者用于根据特定条件需要产生事件的节点。由于它是一次性的通信方式，又因为它在网络上的负载很小，所以它也被用作代替话题的手段，因此是一种非常有用的通信手段。</p>
<h4 id="动作通信"><a href="#动作通信" class="headerlink" title="动作通信"></a>动作通信</h4><p>动作消息通信是在如下情况使用的消息通信方式：服务器收到请求后直到响应所需的时间较长，且需要中途反馈值。这与服务非常相似，服务具有与请求和响应分别对应的目标（ goal ）和结果（ result ）。除此之外动作中还多了反馈（ feedback ）。收到请求后需要很长时间才能响应，又需要中间值时，使用这个反馈发送相关的数据。消息传输方案本身与异步方式的话题（ topic ）相同。反馈在动作客户端（ action client ）和动作服务器（ action server ）之间执行异步双向消息通信，其中动作客户端设置动作目标（ goal ），而动作服务器根据目标执行指定的工作，并将动作反馈和动作结果发送给动作客户端。</p>
<h3 id="消息通信过程"><a href="#消息通信过程" class="headerlink" title="消息通信过程"></a>消息通信过程</h3><p>主节点管理节点信息，每个节点根据需要与其他节点进行连接和消息通信。以话题消息为例，具体通信步骤如下。</p>
<h4 id="运行主节点"><a href="#运行主节点" class="headerlink" title="运行主节点"></a>运行主节点</h4><p>节点之间的消息通信当中，管理连接信息的主节点是为使用 ROS 必须首先运行的必需元素。ROS 主节点使用 roscore 命令来运行，并使用 XMLRPC 运行服务器。主节点为了节点与节点的连接，会注册节点的名称、话题、服务、动作名称、消息类型、URI 地址和端口，并在有请求时将此信息通知给其他节点。<br>运行 <code>roscore</code> 命令就启动了主节点。</p>
<h4 id="运行订阅者节点"><a href="#运行订阅者节点" class="headerlink" title="运行订阅者节点"></a>运行订阅者节点</h4><p>订阅者节点使用 rosrun 或 roslaunch 命令来运行。订阅者节点在运行时向主节点注册其订阅者节点名称、话题名称、消息类型、URI 地址和端口。主节点和节点使用 XMLRPC 进行通信。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rosrun PACKAGE_NAME NODE_NAME</span><br><span class="line">$ roslaunch PACKAGE_NAME LAUNCH_NAME</span><br></pre></td></tr></table></figure>
<h4 id="运行发布者节点"><a href="#运行发布者节点" class="headerlink" title="运行发布者节点"></a>运行发布者节点</h4><p>发布者节点（与订阅者节点类似）使用 rosrun 或 roslaunch 命令来运行。发布者节点向主节点注册发布者节点名称、话题名称、消息类型、 URI 地址和端口。主节点和节点使用 XMLRPC 进行通信。</p>
<h4 id="通知发布者信息"><a href="#通知发布者信息" class="headerlink" title="通知发布者信息"></a>通知发布者信息</h4><p>主节点向订阅者节点发送此订阅者希望访问的发布者的名称、话题名称、消息类型、 URI 地址和端口等信息。主节点和节点使用 XMLRPC 进行通信。</p>
<h4 id="订阅者节点的连接请求"><a href="#订阅者节点的连接请求" class="headerlink" title="订阅者节点的连接请求"></a>订阅者节点的连接请求</h4><p>订阅者节点根据从主节点接收的发布者信息，向发布者节点请求直接连接。在这种情况下，要发送的信息包括订阅者节点名称、话题名称和消息类型。发布者节点和订阅者节点使用 XMLRPC 进行通信。</p>
<h4 id="发布者节点的连接响应"><a href="#发布者节点的连接响应" class="headerlink" title="发布者节点的连接响应"></a>发布者节点的连接响应</h4><p>发布者节点将 TCP 服务器的 URI 地址和端口作为连接响应发送给订阅者节点。发布者节点和订阅者节点使用 XMLRPC 进行通信。</p>
<h4 id="TCPROS-连接"><a href="#TCPROS-连接" class="headerlink" title="TCPROS 连接"></a>TCPROS 连接</h4><p>订阅者节点使用 TCPROS 创建一个与发布者节点对应的客户端，并直接与发布者节点连接。节点间通信使用一种称为 TCPROS 的 TCP/IP 方式。</p>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>发布者节点向订阅者节点发送消息。节点间通信使用一种称为 TCPROS 的 TCP/IP 方式。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E8%AF%9D%E9%A2%98%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt=""><br>服务消息，服务服务器和客户端之间的连接与上述发布者和订阅者之间的 TCPROS 连接相同，但是与话题不同，服务只连接一次，在执行请求和响应之后彼此断开连接。如果有必要，需要重新连接。<br>动作消息，动作（ action ）在执行的方式上好像是在服务（ service ）的请求（ goal ）和响应( result ）之间仅仅多了中途反馈环节，但实际的运作方式与话题相同。事实上，如果使用 rostopic 命令来查阅话题，那么可以看到该动作的 goal、status、cancel、result 和 feedback 等五个话题。动作服务器和客户端之间的连接与上述发布者和订阅中的 TCPROS 连接相同，但某些用法略有不同。例如，动作客户端发送取消命令或服务器发送结果值会中断连接等。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 下学习阿里平头哥 RISC-V 芯片开发平台 wujian100</title>
    <url>//posts/Windows-%E4%B8%8B%E5%AD%A6%E4%B9%A0%E9%98%BF%E9%87%8C%E5%B9%B3%E5%A4%B4%E5%93%A5-RISC-V-%E8%8A%AF%E7%89%87%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0-wujian100.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上个月，在第六届互联网大会上，阿里的平头哥，对，就是那个人狠话不多的公司！他们宣布开源了 <code>wujian100</code> 这个芯片设计平台。搭载基于 RISC-V 架构的玄铁 902 处理器。<br>基础硬件代码和配套软件代码发布在了 GitHub 上了，使用的是 MIT 许可证。大家也都可以去下载学习。<br>GitHub 链接：<a href="https://github.com/T-head-Semi/wujian100_open" target="_blank" rel="noopener">https://github.com/T-head-Semi/wujian100_open</a></p>
<a id="more"></a>

<h2 id="介绍视频"><a href="#介绍视频" class="headerlink" title="介绍视频"></a>介绍视频</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=74527234&cid=127477207&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>

<h2 id="搭建仿真环境"><a href="#搭建仿真环境" class="headerlink" title="搭建仿真环境"></a>搭建仿真环境</h2><h3 id="安装-Linux-环境"><a href="#安装-Linux-环境" class="headerlink" title="安装 Linux 环境"></a>安装 Linux 环境</h3><p>我们要去学习 wujian100 这个代码，首先要去搭建一下运行仿真的环境。跑无剑这个仿真是需要 Linux 环境的，所以我就安装了 WSL（ Windows subsystem of Linux），我这里呢安装了 Ubuntu 18.04 的版本。要安装 WSL ，首先要去 <code>控制面板</code>-&gt;<code>程序</code>-&gt;<code>启用或关闭 Windows 功能</code> 勾选开启 <code>适用于 Linux 的 Windows 子系统</code> 这个选项，这样你就可以去微软应用商店正常安装 Linux 子系统了。</p>
<p>安装好子系统之后，我们直接进入到子系统下面进行操作就可以了。</p>
<h3 id="新建目录-Clone-官方代码"><a href="#新建目录-Clone-官方代码" class="headerlink" title="新建目录 Clone 官方代码"></a>新建目录 Clone 官方代码</h3><p>首先我们按照官方在 GitHub 上的教程新建一个项目目录，然后进入到目录， clone 官方发布的代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir test_prj</span><br><span class="line">$ <span class="built_in">cd</span> test_prj</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/T-head-Semi/wujian100_open.git</span><br></pre></td></tr></table></figure>

<h3 id="安装-RISC-V-工具链"><a href="#安装-RISC-V-工具链" class="headerlink" title="安装 RISC-V 工具链"></a>安装 RISC-V 工具链</h3><p>接下来，新建工具链目录，去官方给定的地址下载编译代码需要的 risc-v 工具链，解开压缩包，找到 <code>riscv64-elf-x86_64-20190731.tar.gz</code> 这个工具链，拷贝到工具链目录，解压安装工具链即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir riscv_toolchain</span><br><span class="line">$ <span class="built_in">cd</span> riscv_toolchain</span><br><span class="line"><span class="comment"># 下面这条命令不一定跟我一样，工具链下载后的具体路径根据你自己的系统确定</span></span><br><span class="line">$ cp /mnt/d/download/T-Head\ Tools\ package/T-Head\ RISC-V\ Toolchain-V1.2.2/riscv64-elf-x86_64-20190731.tar.gz ./  </span><br><span class="line"></span><br><span class="line">$ tar -zxvf riscv64-elf-x86_64-20190731.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="安装仿真工具"><a href="#安装仿真工具" class="headerlink" title="安装仿真工具"></a>安装仿真工具</h3><p>仿真工具可以选择官方推荐的 VCS 仿真，但是我这里呢使用 iverilog 进行仿真， gtkwave 来查看波形文件，verilator 是编辑软件。然后由于我这边安装的 ubuntu18.04 默认没有安装 make 工具，所以也一起安装了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install iverilog gtkwave verilator </span><br><span class="line">$ sudo apt install make</span><br></pre></td></tr></table></figure>
<p>注：有些同学可能是 Ubuntu 16.04 版本，直接通过 apt 命令安装 iverilog 会自动安装一个版本较低的，低版本运行这个仿真是有问题的，这时建议同学自己手动编译安装 10.0 以上版本的 iverilog 。</p>
<h3 id="编辑-setup-脚本，配置环境变量"><a href="#编辑-setup-脚本，配置环境变量" class="headerlink" title="编辑 setup 脚本，配置环境变量"></a>编辑 setup 脚本，配置环境变量</h3><p>工具安装完成之后，编辑 setup 脚本并通过执行它，来设置 EDA 环境变量。<br>由于原本的脚本是 csh 在 bash 环境下有一些不兼容的地方，所以我这里做了一些修改，修改内容如下：</p>
<p>setup.sh 脚本内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Copyright (c) 2019 Alibaba Group Holding Limited</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#set VCS path</span></span><br><span class="line"><span class="comment">#setenv VCS_HOME </span></span><br><span class="line"><span class="comment">#set path=($VCS_HOME/linux/bin $path)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#set VCS license</span></span><br><span class="line"><span class="comment">#setenv SNPSLMD_LICENSE_FILE </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#set iverilog path</span></span><br><span class="line"><span class="built_in">export</span> iverilog_path=(/usr/bin)</span><br><span class="line"><span class="built_in">export</span> gtkwave_path=(/usr/bin)</span><br><span class="line"><span class="built_in">export</span> path=(<span class="variable">$iverilog_path</span>:<span class="variable">$path</span>)</span><br><span class="line"><span class="built_in">export</span> path=(<span class="variable">$gtkwave_path</span>:<span class="variable">$path</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#set tools path</span></span><br><span class="line"><span class="built_in">export</span> TOOL_PATH=<span class="string">'../../riscv_toolchain'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> wujian100_open_PATH=<span class="string">'`pwd | perl -pe "s/wujian100_open.*/wujian100_open\//"`'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ../wujian100_open/tools </span><br><span class="line">$ vim setup.sh</span><br><span class="line">$ chmod +x setup.sh</span><br><span class="line">$ <span class="built_in">source</span> setup.sh</span><br></pre></td></tr></table></figure>

<h3 id="运行仿真"><a href="#运行仿真" class="headerlink" title="运行仿真"></a>运行仿真</h3><p>接下来，进入到 workdir 目录下运行仿真，然后通过 gtkwave 打开仿真波形。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ../workdir</span><br><span class="line">$ ../tools/run_case -sim_tool iverilog ../<span class="keyword">case</span>/timer/timer_test.c</span><br></pre></td></tr></table></figure>

<p>当你看到 Hello Friend！ 就表明你的仿真就跑起来了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VCD info: dumpfile test.vcd opened <span class="keyword">for</span> output.</span><br><span class="line">        ******START TO LOAD PROGRAM******</span><br><span class="line"></span><br><span class="line">Hello Friend!</span><br><span class="line"></span><br><span class="line">timer <span class="built_in">test</span> successfully</span><br><span class="line">***************************************</span><br><span class="line"></span><br><span class="line">*              Test Pass              *</span><br><span class="line"></span><br><span class="line">***************************************</span><br><span class="line"></span><br><span class="line">Step4 (Run simulation) is finished</span><br></pre></td></tr></table></figure>

<p>用 gtkwave 打开 workdir 目录下的 test.vcd 波形文件，查看仿真波形，（打开波形文件需要图形化界面，我这里还安装了 VcXsrv，具体安装方法请自行搜索一下）波形图如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gtkwave test.vcd</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2019/11/24/MOr25R.png" alt="wujian100_test_wave"></p>
<p>好了，到这里你的仿真就跑起来了，然后接下来就是进行综合生成 bit 流文件了，下一篇文章在来更新 vivado 综合的步骤。</p>
<h2 id="跑通仿真视频教程"><a href="#跑通仿真视频教程" class="headerlink" title="跑通仿真视频教程"></a>跑通仿真视频教程</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=76320581&cid=130546912&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>
]]></content>
      <categories>
        <category>IC Design</category>
        <category>RISC-V</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>IC Design</tag>
        <tag>RISC-V</tag>
        <tag>平头哥</tag>
        <tag>wujian100</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10 环境下搭建 RISC-V 调试环境</title>
    <url>//posts/Windows10-%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BA-RISC-V-%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.html</url>
    <content><![CDATA[<h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><ul>
<li>IDE: <a href="https://github.com/gnu-mcu-eclipse/org.eclipse.epp.packages/releases" target="_blank" rel="noopener">GNU MCU Eclipse IDE for C/C++ Developers</a></li>
<li>IDE 插件: <a href="https://github.com/gnu-mcu-eclipse/eclipse-plugins/releases" target="_blank" rel="noopener">GNU MCU Eclipse plug-ins</a></li>
<li>GCC/GDB 工具: <a href="https://github.com/gnu-mcu-eclipse/riscv-none-gcc/releases" target="_blank" rel="noopener">GNU MCU Eclipse RISC-V Embedded GCC</a></li>
<li>调试工具: <a href="https://github.com/gnu-mcu-eclipse/openocd/releases" target="_blank" rel="noopener">GNU MCU Eclipse OpenOCD</a></li>
<li>make 工具: <a href="https://github.com/gnu-mcu-eclipse/windows-build-tools/releases" target="_blank" rel="noopener">GNU MCU Eclipse Windows Build Tools</a></li>
<li>Zadig 工具: <a href="https://zadig.akeo.ie/" target="_blank" rel="noopener">Zadig</a></li>
</ul>
<h3 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h3><ul>
<li>目标 RISC-V 芯片</li>
<li>调试器： J-Link，FT2232 或其他含有标准 JTAG 接口的调试器</li>
</ul>
<a id="more"></a>

<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>以下内容来自 ChenRQ 同学！</p>
<p>启动 IDE: GNU MCU Eclipse IDE for C/C++ Developers，Eclipse 基于 Java 开发，运行时需要 Java 的运行环境(JRE)，如没有请自行安装。</p>
<h2 id="新建一个工程"><a href="#新建一个工程" class="headerlink" title="新建一个工程"></a>新建一个工程</h2><p><img src="https://i.loli.net/2019/02/26/5c7540a7474bf.png" alt="新建工程"></p>
<p>工程类型选择 Hello World RISC-V C Project，工具链选择 RISC-V Cross GCC 如下所示</p>
<p><img src="https://i.loli.net/2019/02/26/5c754155033e4.png" alt="项目类型设置"></p>
<p>使用默认配置 next 至 GNU 工具链选择， 文件路径应指向为您的 RISC-V Embedded GCC 目录下的 bin 文件夹，如下图所示</p>
<p><img src="https://i.loli.net/2019/02/26/5c7542f86b719.png" alt="工具链路径设置"></p>
<p>完成后点击 Finish 由此完成工程项目的创建。创建完成后，我们可以看到还有一个报错， 如下图所示</p>
<p><img src="https://i.loli.net/2019/02/26/5c7543a17226b.png" alt="工程创建完成界面"></p>
<p>因此我们还需要继续对项目进行配置。</p>
<h2 id="工程相关配置"><a href="#工程相关配置" class="headerlink" title="工程相关配置"></a>工程相关配置</h2><p>对工程右键选择 “properties”，在 MCU 选栏中配置 Build Tools Path，该路径应指向您的 Build Tools 目录下的 bin 文件夹，如下图所示</p>
<p><img src="https://i.loli.net/2019/02/26/5c7544fd07eb8.png" alt="Build Tools 路径配置"></p>
<p>继续配置 OpenOCD Path，路径为 OpenOCD 目录下的 bin 文件夹，如下图所示，并点击apply</p>
<p><img src="https://i.loli.net/2019/02/26/5c75487c1f6cf.png" alt="OpenOCD 路径配置"></p>
<p>再配置 RISC-V Toolchain Path（若新建项目时已配置过工具链路径，可以跳过此步骤），配置路径与工程建立时选择的工具链路径相同。</p>
<h2 id="配置编译和链接选项"><a href="#配置编译和链接选项" class="headerlink" title="配置编译和链接选项"></a>配置编译和链接选项</h2><p>继续在 “properties” 窗口中，选择 C/C++ Build 中的 settings，在 Tool Settings 中 Target Processor 进行配置，由于是 RISC-V，因此架构 (architecture) 选择 RV32I 并勾选乘法指令拓展(RVM)，原子指令拓展(RVA)及压缩指令拓展(RVC)，ABI 调用选择 ILP32(表明为 32 位架构无浮点型，PS: ilp32f 和 ilp32d 则分别表示单精度浮点和双精度浮点)，Code Model 选择 Medium Low，勾选整数除法指令(-mdiv)，如下图所示，并点击 apply</p>
<p><img src="https://i.loli.net/2019/02/26/5c7548ff7b8fb.png" alt="Target Processor 配置"></p>
<p>继续配置 Optimization，Level 选择 -O2，如下图所示，并点击 apply</p>
<p><img src="https://i.loli.net/2019/02/26/5c7549557f2eb.png" alt="Optimization 配置"></p>
<p>继续配置 Debugging，Level 选择 -g，如下图所示，并点击 apply</p>
<p><img src="https://i.loli.net/2019/02/26/5c7549be00c12.png" alt="Debugging 配置"></p>
<p>在 Tool Settings 中选择 GNU RISC-V Cross C Linker 的 General，点击右上角+号，弹窗中选择 Workspace 选择路径您芯片对应的 lds 文件，用于对地址区间进行约束，如下图所示</p>
<p><img src="https://i.loli.net/2019/02/26/5c754a785cc2d.png" alt="链接脚本配置"></p>
<p>勾选对应选项后，点击 apply,如下图所示</p>
<p><img src="https://i.loli.net/2019/02/26/5c754ad5a9b74.png" alt="链接选项配置"></p>
<p>在 Tool Settings 中选择 GNU RISC-V Cross C Linker 的 Miscellaneous 进行勾选，如下图所示，并点击 apply</p>
<p><img src="https://i.loli.net/2019/02/26/5c754b533251d.png" alt="链接杂项配置"></p>
<p>添加您的工程汇编类型的头文件路径，方法如下图所示</p>
<p><img src="https://i.loli.net/2019/02/26/5c754c158df6a.png" alt="添加工程汇编头文件目录"></p>
<p>添加您的工程 C/C++ 类型的头文件路径，方法如下图所示</p>
<p><img src="https://i.loli.net/2019/02/26/5c754c158df6a.png" alt=" 添加工程 C/C++ 头文件目录"></p>
<p>待续… </p>
<p>后续测试进行中…</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>RISC-V</tag>
      </tags>
  </entry>
  <entry>
    <title>strongwongのdiary</title>
    <url>//posts/strongwong%E3%81%AEdiary.html</url>
    <content><![CDATA[<p>简单记录一下我每天搞了什么。成长之路，点滴记录！</p>
<h3 id="2018-8-1-8-5"><a href="#2018-8-1-8-5" class="headerlink" title="2018-8-1~8-5"></a>2018-8-1~8-5</h3><p>1.搭建了博客，学习了 MarkDown 语法规则，学习用 MarkDown 来写作。<br>2.测试 UlpBench<br>3.移植 UlpBench 部分代码到 M3 上运行，测试功耗<br>4.测试单指令差异<br>5.整理分析测试数据</p>
<a id="more"></a>

<h3 id="2018-8-6"><a href="#2018-8-6" class="headerlink" title="2018-8-6"></a>2018-8-6</h3><p>1.阅读整理 Event Arbiter 代码，分析链路层和事件仲裁器之间的关系<br>2.看了很多大佬的博客，调整了博客的一些设置</p>
<h3 id="2018-8-8"><a href="#2018-8-8" class="headerlink" title="2018-8-8"></a>2018-8-8</h3><p>1.今天还是在看 Event Arbiter 的代码和文档资料。<br>2.尝试性的把 Event Arbiter 的部分代码进行了移植，但是没跑通，还要很多问题，明天继续解决。进展有点慢，测试方案还不知道怎么弄 <em>_</em><br>3.十年前的今天奥运会开幕了，我在家看奥运会；今天的我大学毕业了，在这里敲代码；十年后的我怎么样了，我会在干什么？<br>4.博客还是要坚持写，加油！</p>
<h3 id="2018-8-9"><a href="#2018-8-9" class="headerlink" title="2018-8-9"></a>2018-8-9</h3><p>1.今天还是搞 EA 这个东西，没什么进展，难受！<br>2.领导让写一个 CM3 进 sleep 的代码，写了，内存中对应的位也写入值了，但是 J-link 还是可以正常连接，有很多东西好像并没有关掉，怀疑是设计的 SOC 有问题。</p>
<h3 id="2018-8-10"><a href="#2018-8-10" class="headerlink" title="2018-8-10"></a>2018-8-10</h3><p>1.我昨天给领导写的代码应该是没问题的，只是 FPGA 上不能进行这样的调试。但是还是有一些问题，比如说中断使能没做，也没有 rtc 或者 wakeup 的功能，还需要增加。<br>2.EA 的大部分功能都已经移植好了，但是和底层相关的定时器我没有，还是有问题，不能进行正常调试。然后就是 EA 的整个测试流程怎么搞，我还不太明白，对单个函数的测好做，但是如果要测试多个事件的仲裁，测试 EA 的完整功能还不知道怎么弄。可能我需要有一个简单的任务切换，每个任务里请求一个事件，然后有 EA 来进行判断和仲裁。</p>
<h3 id="2018-8-13"><a href="#2018-8-13" class="headerlink" title="2018-8-13"></a>2018-8-13</h3><p>1.继续搞 EA ，底层的一些时间相关的寄存器我打算使用 Systick 和 Timer 结合起来模拟。但是还有一些问题，还需要解决。<br>2.今天戚博有给了一个另外的任务，需要我在服务器上使用 arm-none-eabi-gcc 来做开发。让我写一套 Makefile ，虽然我之前有简单使用过 Makefile 、make ，但是我还没弄过这种相对大一些的项目的编译、开发。我找了些 makefile 的文档来学习，看看 Makefile 该怎么写。</p>
<h3 id="2018-8-14"><a href="#2018-8-14" class="headerlink" title="2018-8-14"></a>2018-8-14</h3><p>1.学习 Linux 下面的开发，学习 Makefile 的编写。了解补充一些编译、链接相关的知识，熟悉一下 GUN 相关的工具链。<br>2.整理我之前写的代码，今天发现之前写的还是有一些问题，做了很多调整，今天主要调整了 UART 相关的代码。明天可能还需要把 timer 、 gpio 的代码做一些调整。然后往服务器上迁移。</p>
<h3 id="2018-8-26"><a href="#2018-8-26" class="headerlink" title="2018-8-26"></a>2018-8-26</h3><p>1.前段时间回家了一个多星期，断更了。现在回来了，接着写。<br>2.今天整理了一下关于 Jetson TX2 内核重新编译的东西，写了一篇博文。<br>3.请假之前领导让写 Makefile ，做一个使用 arm-none-eabi-gcc 在 Linux 下编译的版本。回来这几天搞完了。 在 Cygwin 下的编译 stm32 还是有点问题，还需要修改。</p>
<h3 id="2018-8-31"><a href="#2018-8-31" class="headerlink" title="2018-8-31"></a>2018-8-31</h3><p>1.仔细看了一些 Makefile 文件的编写规则，解决了编译问题。<br>2.当当网有购书优惠，屯了 10 本技术相关的书籍。</p>
<h3 id="2018-9-5"><a href="#2018-9-5" class="headerlink" title="2018-9-5"></a>2018-9-5</h3><p>今天突然发现不能上 Google 学习了，很尴尬，迅速寻找解决方案！成功切换到 v2ray 了上。哈哈，又可以愉快的学习了。</p>
<h3 id="2018-9-15"><a href="#2018-9-15" class="headerlink" title="2018-9-15"></a>2018-9-15</h3><p>1.又有好几天没有更新了，最近对无线电有了很大兴趣。于是前些天买了一个 RTL_SDR 鼓捣了一下软件无线电。挺好玩的~<br>2.和做基带的同学，做了一些沟通，配合他们做一下 BB 的测试。</p>
<h3 id="2018-9-20"><a href="#2018-9-20" class="headerlink" title="2018-9-20"></a>2018-9-20</h3><ol>
<li>ea 的基本测试做了一些，还没做完。</li>
<li>在和戚博的讨论过程中发现了我之前写的代码有一些不太合理的地方。缺乏面向对象的思想，代码没有很好的做到低耦合。需要做一些改动。</li>
</ol>
<h3 id="2018-10-6"><a href="#2018-10-6" class="headerlink" title="2018-10-6"></a>2018-10-6</h3><p>给博客增加了 Google Adsense ，文章下面会有 Google 广告，点击广告就会有一定的收益！来访问的小伙伴，看到广告记得帮我点一点啊~~</p>
<h3 id="2019-12-02"><a href="#2019-12-02" class="headerlink" title="2019-12-02"></a>2019-12-02</h3><p>Google Adsense 广告移除了，影响阅读体验~~</p>
]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title>wujian100 的 PWM 周期问题</title>
    <url>//posts/wujian100-%E7%9A%84-PWM-%E5%91%A8%E6%9C%9F%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="PWM-波形发生器实验结果"><a href="#PWM-波形发生器实验结果" class="headerlink" title="PWM 波形发生器实验结果"></a>PWM 波形发生器实验结果</h2><p>在 wujian100 的样例程序代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span>  <span class="title">pwm_signal_test</span><span class="params">(<span class="keyword">uint32_t</span> pwm_idx, <span class="keyword">uint8_t</span> pwm_ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> ret;</span><br><span class="line">    <span class="keyword">pwm_handle_t</span> pwm_handle;</span><br><span class="line"></span><br><span class="line">    example_pin_pwm_init();</span><br><span class="line"></span><br><span class="line">    pwm_handle = csi_pwm_initialize(pwm_idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwm_handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"csi_pwm_initialize error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = csi_pwm_config(pwm_handle, pwm_ch, <span class="number">3000</span>, <span class="number">1500</span>); <span class="comment">//设置pwm周期3ms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"csi_pwm_config error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    csi_pwm_start(pwm_handle, pwm_ch);</span><br><span class="line">    mdelay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    ret = csi_pwm_config(pwm_handle, pwm_ch, <span class="number">200</span>, <span class="number">150</span>); <span class="comment">//设置pwm周期200us</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"csi_pwm_config error\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mdelay(<span class="number">20</span>);</span><br><span class="line">    csi_pwm_stop(pwm_handle, pwm_ch);</span><br><span class="line"></span><br><span class="line">    csi_pwm_uninitialize(pwm_handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有两句配置函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = csi_pwm_config(pwm_handle, pwm_ch, <span class="number">3000</span>, <span class="number">1500</span>); <span class="comment">//设置pwm周期3ms，占空比1500/3000</span></span><br><span class="line">ret = csi_pwm_config(pwm_handle, pwm_ch, <span class="number">200</span>, <span class="number">150</span>); <span class="comment">//设置pwm周期200us占空比50/200</span></span><br></pre></td></tr></table></figure>

<p>这两句都是用来配置 pwm 周期的，是实际测试中 pwm 周期和占空比都没有问题。但是如果设置 pwm 周期为 5ms 时，需要修改这句话为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = csi_pwm_config(pwm_handle, pwm_ch, <span class="number">5000</span>, <span class="number">2500</span>);</span><br></pre></td></tr></table></figure>

<p>在实际测试过程中会发现，他的周期实际是 2.5ms 并不是预期的 5ms，如果设置为 100ms 会发现 pwm 的实际输出周期是 2.5ms。实际输出是有问题的。</p>
<a id="more"></a>

<h2 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h2><h3 id="检查软件问题"><a href="#检查软件问题" class="headerlink" title="检查软件问题"></a>检查软件问题</h3><p>跟踪 <code>csi_pwm_config</code>  函数，发现在函数中会根据设置的周期进行时钟配置：<br><code>drv_pwm_config_clockdiv(handle, channel, cnt_div[count_div]);</code> 由于 pwm 计数器是 16 位，所以软件会根据设置的周期值计算出要配置的数值，如果该数值超过 0xffff，就会设置分频系数，直到需要计数的值小于 0xffff 为止。</p>
<p>继续跟踪<br><code>drv_pwm_config_clockdiv(handle, channel, cnt_div[count_div]);</code><br>我们可以看到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drv_pwm_config_clockdiv</span><span class="params">(<span class="keyword">pwm_handle_t</span> handle, <span class="keyword">uint8_t</span> channel, <span class="keyword">uint32_t</span> div)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PWM_NULL_PARAM_CHK_NORETVAL(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wj_pwm_priv_t</span> *pwm_priv = handle;</span><br><span class="line">    <span class="keyword">wj_pwm_reg_t</span> *addr = (<span class="keyword">wj_pwm_reg_t</span> *)(pwm_priv-&gt;base);</span><br><span class="line">    addr-&gt;PWMCFG &amp;= ~(<span class="number">7</span> &lt;&lt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (div) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            addr-&gt;PWMCFG &amp;= ~(PWM_CFG_CNTDIV_EN);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            addr-&gt;PWMCFG |= PWM_CFG_CNTDIV_EN | PWM_CFG_CNTDIV_2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            addr-&gt;PWMCFG |= PWM_CFG_CNTDIV_EN | PWM_CFG_CNTDIV_5;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ........</span><br></pre></td></tr></table></figure>

<p>这个函数会对寄存器 PWMCFG 的第 25 位到第 27 位进行了赋值操作，查找数据手册发现</p>
<p><img src="https://verimake.com/uploads/images/202007/27/48/drATAcOLiI.png" alt="PWMCFG"></p>
<p>第 28 位是分频使能，第 26 到 24 位是分频系数设置。</p>
<p>在 csi 库里提供了一个函数可以读取这几位的值来查看分频的设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  \brief       get pwm clock division.</span></span><br><span class="line"><span class="comment">  \param[in]   handle   pwm handle to operate.</span></span><br><span class="line"><span class="comment">  \param[in]   channel  channel num.</span></span><br><span class="line"><span class="comment">  \return      div      clock div.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">uint33_t</span> <span class="title">drv_pwm_get_clockdiv</span><span class="params">(<span class="keyword">pwm_handle_t</span> handle, <span class="keyword">uint8_t</span> channel)</span></span></span><br></pre></td></tr></table></figure>

<p>通过这个函数可以得到 PWMCFG 寄存器里的分频系数 cntdiv 的值。通过实验我们发现分频系数的值配置到寄存器里了，并且读回来的值也是配置的值。</p>
<p><strong>总结：所以软件上对于 pwm 的配置是没有问题的，配置 pwm 周期不是预期值不是软件问题。</strong></p>
<h3 id="检查硬件问题"><a href="#检查硬件问题" class="headerlink" title="检查硬件问题"></a>检查硬件问题</h3><p>排除软件问题，那么出现 pwm 周期非预期值他的问题就只可能是 pwm 外设在设计时的硬件问题了。我们查找 wujian100 内部设计的问题，为了方便查看我们使用 verdi 来查看跟踪模块设计，这样效率高。</p>
<p>首先第一步配置 wujian100 工作路径：在 linux 系统中利用 source 将 wujian100 工作目录添加到系统环境变量。</p>
<p>第二步 tb 目录下的 tb_file.list 文件，这个文件里加载的顶层文件是 wujian100_open_top.v，并不是我们生成bit文件时的 wujian100_open_fpga_top.v 文件（该文件在 fpga 目录下），我们首先赋值 fpga 目录下的 wujian100_open_fpga_top.v 到 soc 目录下。修改文件 tb_file.list 里的第 3 行，将 wujian100_open_top.v 替换为 wujian100_open_fpga_top.v</p>
<p>第三步进入 tb 目录。使用 verdi -f tb_file.list 打开软件 verdi 并加载 tb_file.list 里列出的文件。（前提是你的 linux 系统安装了 verdi 软件）。</p>
<p>以上三步正确就会打开 wujian100 设计的模块图。</p>
<p><img src="https://verimake.com/uploads/images/202007/27/48/paS1BXFlZo.png" alt="wujian100 top"></p>
<p>查看选中打开该文件，查看文件名是不是wujian100_open_fpga_top.v</p>
<p><img src="https://verimake.com/uploads/images/202007/27/48/1upWxy2aYy.png" alt="wujian100_open_fpga_top.v"></p>
<p>然后打开原理图。点击如图按钮：</p>
<p><img src="https://verimake.com/uploads/images/202007/27/48/I1AGOAB2Pp.png" alt="原理图">))</p>
<p>打开 wujian100 的设计如图：</p>
<p><img src="https://verimake.com/uploads/images/202007/27/48/uAD9prEoAg.png" alt="wujian100"></p>
<p>接下来可以按文件查找相应模块，也可以双击原理图上的模块一层一层进入。</p>
<p>pwm 模块位于 PDU 下的 ahb1 上。一层一层进入查看下，定位到 pwm：</p>
<p><img src="https://verimake.com/uploads/images/202007/27/48/b4JYC9MGas.png" alt="pwm_sec_top"></p>
<p>继续进入 pwm_sec_top ,再进入 pwm 就是 pwm 外设的内部了。</p>
<p><img src="https://verimake.com/uploads/images/202007/27/48/tlqqmNBeeZ.png" alt="pwm_ctrl &amp; pwm_aphif"></p>
<p>在这里有两部分，一个是 aphif 负责总线，ctrl 就是 pwm 的实际实现了。<br>进入 pwm_ctrl:</p>
<p><img src="https://verimake.com/uploads/images/202007/27/48/TUl7lfX16U.png" alt="pwm_ctrl"></p>
<p>我们发现有六个 pwm_gen。和数据手册上介绍的一样。</p>
<p><img src="https://verimake.com/uploads/images/202007/27/48/2WyAXpAnmE.png" alt="6 pwm_gen"></p>
<p>我们现在定位到左下角，放大看，这部分就是pwm的时钟部分：</p>
<p><img src="https://verimake.com/uploads/images/202007/28/48/5Z0ZnHCJkP.png" alt="pwm_gen"><br>我们在 view 菜单下打开端口名称显示和模块内部端口名称显示。在图上我们可以看到 cntdiv[3:0] 控制了分频系数，分频系数会通过分频器（图上的 f）对 pclk 系统时钟进行分频，然后通过 gated_clk_cell 控制时钟的通过然后通过 clk_mux2 选择器送到后续的 pwm 发生器上作为发生器的时钟。我们双击模块就能够查看各自对应的 verilog 代码。我们在逐个查找时发现 gated_clk_cell（如下图）它的结构有问题：</p>
<p><img src="https://verimake.com/uploads/images/202007/28/48/TKowhWEMnu.png" alt="gated_clk_cell"></p>
<p>双击它，查看它内部结构：</p>
<p><img src="https://verimake.com/uploads/images/202007/28/48/8FjG7fLa9J.png" alt="gated_clk_cell"></p>
<p>如图这样一个很奇怪的结构，<strong>直接就是 clk_in 输入，直接送到 clk_out 输出上去了</strong>。结合上一张图我们可以看出 clk_in 就是 pclk 系统时钟，这样导致前面的分频没有任何作用，pclk 将会直接送到 pwm 发生器上作为 pwm 的时钟。这样不论你有没有设置分频，pwm 就只有系统时钟 pclk（21M)。这样 pwm 的信号周期无法修改。</p>
<p>反过来推到下，我们之前的实验设置周期 6ms 是得到的结果是 2.5ms，其实我们的分频系数是 2，由于时钟没有分频，导致我们的输出周期是 2.5ms，如果分频成功我们的周期就会是 2.5*2=5ms，同理，10ms 时的分频系数是 4。有兴趣的可以根据 sdk 提供的代码推到下，也可以用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint33_t</span> <span class="title">drv_pwm_get_clockdiv</span><span class="params">(<span class="keyword">pwm_handle_t</span> handle, <span class="keyword">uint8_t</span> channel)</span></span></span><br></pre></td></tr></table></figure>

<p>这个函数查看分频系数，然后分析下。</p>
<p>我们直到了问题出在模块 gated_clk_cell 上了，我们定位到模块对应的 verilog 文件，查找到代码位于 pwm.v 文件的 4186 行例化了一个叫做 gated_clk_cell 的模块，我们双击 gated_clk_cell 进入内部，双击模块定位到了 common.v 文件的 66 行，代码如下：</p>
<figure class="highlight v"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifdef</span> FPGA</span></span><br><span class="line"><span class="keyword">assign</span> clk_out = clk_in;</span><br><span class="line"><span class="meta">`<span class="meta-keyword">else</span></span></span><br><span class="line">Standard_Cell_CLK_GATE x_gated_clk_cell(</span><br><span class="line">             <span class="variable">.CK</span>  (clk_in),</span><br><span class="line">             <span class="variable">.SE</span>  (SE),</span><br><span class="line">             <span class="variable">.EN</span>   (clk_en_bf_latch),</span><br><span class="line">             <span class="variable">.Q</span>   (clk_out)</span><br><span class="line">             );</span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这下一目了然了，由于定义了 FPGA 这个量，导致 assign clk_out=clk_in; 而下面的模块没有实现，所以最主要原因就是定义了 FPGA 这个量，这个量在哪里定义的呢，就是在 wujian100_open_fpga_top.v 这个文件的最开头定义的（第 37 行）：</p>
<p><img src="https://verimake.com/uploads/images/202007/28/48/LRN8UJPFgJ.png" alt="wujian100_open_fpga_top.v"></p>
<p>将这行用 // 注释，然后在 verdi 中点击 file 下选择 reload 设计，重新加载文件，我们再查看 geted_clk_cell 模块，得到如下图：</p>
<p><img src="https://verimake.com/uploads/images/202007/28/48/1czH3wBd8y.png" alt="geted_clk_cell 改"></p>
<p>这样 clk_in 不会直接送到 clk_out 输出了。</p>
<p>修改后用 vivado 重新分析综合生成 bit，下载到开发板上，我们发现输出的 pwm 的周期输出正确了。6ms，10ms 的周期也能生成了。</p>
<p>这里有一点注意，修改后源码用 vivado 建立工程，用 vivado 去 Synthesis，不要用官方方法，用 Synplify_pro 去 Synthesis。不然生成的 bit 下载开发板，输出的 pwm 周期会小一半。例如 11ms 周期只能输出 5ms。有兴趣的可以试下。</p>
<h2 id="后续问题"><a href="#后续问题" class="headerlink" title="后续问题"></a>后续问题</h2><p>查看这张结构图</p>
<p><img src="https://verimake.com/uploads/images/202007/27/48/TUl7lfX16U.png" alt="PWM"></p>
<p>仔细查看，不难发现，它的六个 pwm_gen 都是用的一个时钟源，都是 pclk 通过分频之后的时钟直接连接在了每一个 pwn_gen 的时钟上，六个时钟都是一个源，那么就会造成一个问题，他的六组 pwm 发生器只能同时产生一个频率（周期）的信号，例如 ch1 产生了 5ms，那个这时 ch2 也只能产生 5ms，没法产生 10ms 周期的 pwm，所有通道的周期都会被最后那个设置改成同一个频率，就是因为他们的时钟是同一个。这将怎么解决，有一个思路，就是每一个 pwm_gen 有各自的分频模块。怎么解决下一篇介绍。</p>
<p>本文转自 Verimake 论坛：<br><a href="https://verimake.com/topics/122" target="_blank" rel="noopener">https://verimake.com/topics/122</a></p>
]]></content>
      <categories>
        <category>IC Design</category>
        <category>RISC-V</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>IC Design</tag>
        <tag>RISC-V</tag>
        <tag>wujian100</tag>
      </tags>
  </entry>
  <entry>
    <title>从计数器开始，看数字 IC 设计</title>
    <url>//posts/%E4%BB%8E%E8%AE%A1%E6%95%B0%E5%99%A8%E5%BC%80%E5%A7%8B%EF%BC%8C%E7%9C%8B%E6%95%B0%E5%AD%97-IC-%E8%AE%BE%E8%AE%A1.html</url>
    <content><![CDATA[<h2 id="计数器设计"><a href="#计数器设计" class="headerlink" title="计数器设计"></a>计数器设计</h2><p>之前有实验室的学长去参加海思、中芯国际、瑞芯微、…… 数字 IC 前端方向的面试，几乎都问到了同一系列问题——设计一个计数器及相关问题。这里很多朋友就会觉得很有意思了，为什么一个简单的计数器能有这么多东西，那我们就『简单』的东西简单看。</p>
<a id="more"></a>

<h2 id="0x00-请你设计一个-10-进制的异步复位无限循环计数器（0-9）"><a href="#0x00-请你设计一个-10-进制的异步复位无限循环计数器（0-9）" class="headerlink" title="0x00 请你设计一个 10 进制的异步复位无限循环计数器（0-9）"></a>0x00 请你设计一个 10 进制的异步复位无限循环计数器（0-9）</h2><p>首先，第一个问题，<strong>请你设计一个 10 进制的异步复位无限循环计数器（0-9）</strong>，你会怎么做？</p>
<p>相信到这很多朋友就开始洋洋洒洒地写道：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> counter10(</span><br><span class="line">                <span class="keyword">input</span> clk,</span><br><span class="line">                <span class="keyword">input</span> rst_n,</span><br><span class="line">                <span class="keyword">output</span> <span class="keyword">wire</span> cnt_flag</span><br><span class="line">                );</span><br><span class="line"><span class="keyword">reg</span>[<span class="number">3</span>:<span class="number">0</span>] cnt_reg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>( ~rst_n) <span class="keyword">begin</span></span><br><span class="line">        cnt_reg &lt;= <span class="number">4'b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(cnt_reg == <span class="number">4'd9</span>)</span><br><span class="line">            cnt_reg &lt;= <span class="number">4'b0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt_reg &lt;= cnt_reg + <span class="number">4'b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> cnt_flag = (cnt_reg == <span class="number">4'd9</span>) ? <span class="number">1'b1</span> : <span class="number">1'b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h2 id="0x01-请画出对应的电路图"><a href="#0x01-请画出对应的电路图" class="headerlink" title="0x01 请画出对应的电路图"></a>0x01 请画出对应的电路图</h2><p>Bravo! 没有任何问题！接下来开始有分水岭了，<strong>请画出对应的电路图</strong> ，有的朋友可能会抓脑袋了：</p>
<p>这里给一点提示，看你能想起什么，确定状态 —— 确定激励方程 —— 逻辑图 —— 自启动检查 —— 状态表。这是什么？数字电路基础，为什么？我们这是数字集成电路设计啊！最终还是要回归到数字电路上来啊！</p>
<p>好，那我们先用 D 触发器来做（不经过编码优化，只是还原最简单的设计步骤），回忆一下最初我们大一大二时怎么弄的。</p>
<h3 id="状态表："><a href="#状态表：" class="headerlink" title="状态表："></a>状态表：</h3><table>
<thead>
<tr>
<th align="center">计数顺序</th>
<th align="center">现状态</th>
<th align="center">次状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center">Q3 Q2 Q1 Q0</td>
<td align="center">D3 D2 D1 D0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0 0 0 0</td>
<td align="center">0 0 0 1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0 0 0 1</td>
<td align="center">0 0 1 0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0 0 1 0</td>
<td align="center">0 0 1 1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0 0 1 1</td>
<td align="center">0 1 0 0</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0 1 0 0</td>
<td align="center">0 1 0 1</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">0 1 0 1</td>
<td align="center">0 1 1 0</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">0 1 1 0</td>
<td align="center">0 1 1 1</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">0 1 1 1</td>
<td align="center">1 0 0 0</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">1 0 0 0</td>
<td align="center">1 0 0 1</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">1 0 0 1</td>
<td align="center">0 0 0 0</td>
</tr>
</tbody></table>
<h3 id="激励方程："><a href="#激励方程：" class="headerlink" title="激励方程："></a>激励方程：</h3><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E5%8D%A1%E8%AF%BA%E5%9B%BE.png" alt=""></p>
<h3 id="逻辑图："><a href="#逻辑图：" class="headerlink" title="逻辑图："></a>逻辑图：</h3><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E5%8D%81%E8%BF%9B%E5%88%B6D%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt=""></p>
<p>…… 剩下的估计大家都能回忆起来了</p>
<p>以上就是我们之前数字电路设计流程，我们回过头来看我们的硬件描述过程，有 if 判断值，那少不了比较器，有 <code>+</code> 运算，自然也有一个加法器 …… 当然我们真正的设计应该是先想好了有比较器和其他逻辑电路才有对应的硬件描述，但我们不妨来看一下我们设计的电路，不正是如下图所示：<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E5%8D%81%E8%BF%9B%E5%88%B6.png" alt=""></p>
<h2 id="0x02-上图中的关键路径是哪一条？"><a href="#0x02-上图中的关键路径是哪一条？" class="headerlink" title="0x02 上图中的关键路径是哪一条？"></a>0x02 上图中的关键路径是哪一条？</h2><p>Ok~ 解决了电路图，下一个问题又来了，<strong>上图中的关键路径是哪一条？</strong></p>
<p>要知道关键路径就需要时序分析啦，这里为接下来的另一个数字 IC 的小专栏———时序分析与约束挖下第一坑。</p>
<p>关键路径应该是：Q &gt; + &gt; MUX &gt; D (具体分析将在后面填坑，大家也可以先想想为什么不是 Q &gt; CMP &gt; MUX &gt; D)</p>
<h2 id="0x03-上面图中-CMP-9-即原描述中-cnt-reg-4’d9-的电路是什么？"><a href="#0x03-上面图中-CMP-9-即原描述中-cnt-reg-4’d9-的电路是什么？" class="headerlink" title="0x03 上面图中 CMP = 9 即原描述中 cnt_reg == 4’d9 的电路是什么？"></a>0x03 上面图中 CMP = 9 即原描述中 cnt_reg == 4’d9 的电路是什么？</h2><p>接下来的问题，<strong>上面图中 CMP = 9 即原描述中 cnt_reg == 4’d9 的电路是什么？</strong><br>其实答案就在我们的触发器版原理图对应的组合电路中，精简后如下图所示：<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/CMP.png" alt=""></p>
<h2 id="0x04-cnt-reg-4’d9-和-cnt-reg-gt-8-有什么区别？"><a href="#0x04-cnt-reg-4’d9-和-cnt-reg-gt-8-有什么区别？" class="headerlink" title="0x04 cnt_reg == 4’d9 和 cnt_reg &gt; 8 有什么区别？"></a>0x04 cnt_reg == 4’d9 和 cnt_reg &gt; 8 有什么区别？</h2><p>功能上确实是一样的，但是如果是一个把 Verilog 当编程玩的朋友对于接下来的东就蛮有意义的了，cnt_reg == 4’d9 实现的电路如上图所示，是一个相对简单的组合逻辑电路。如果是 cnt_reg &gt; 8，对于我们 4 位数据来说可能的范围为 9~15，则综合工具会把所有的情况都列出，cnt_reg == 9,10,11 …… 这样在无形中就浪费了资源。若位宽更大则会被综合为cnt_reg - 8 &gt; 0，由此便会引入一个加法器 ……</p>
<h2 id="0x05-加法器对应的电路是什么？如何验证这个计数器？……"><a href="#0x05-加法器对应的电路是什么？如何验证这个计数器？……" class="headerlink" title="0x05 加法器对应的电路是什么？如何验证这个计数器？……"></a>0x05 加法器对应的电路是什么？如何验证这个计数器？……</h2><p>一系列的问题，我们可以发现并非那么简单的。要知道直到现在优化加法器的文章依然不时可以出现在 sci 检索期刊中，这另外说明为什么上一问引入加法器后带来的浪费用省略号来表示，为什么关键路径是到 + 而不是比较器 ……</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>引用《手把手教你设计 CPU——RISC-V 处理器篇》作者胡振波老师的一段话，当年第一次 Verilog 课时我的授课老师董乾博士也强调过类似的话。</p>
<blockquote>
<p>先定义电路微架构而后编写代码。<br>谨记 Verilog 只是一种硬件描述语言，IC 设计的本质是对于电路的设计，虽然现在Verilog Coding 采用 RTL 级别的抽象描述，但是必须清楚所描述的代码能够映射出的电路结构，其面积和时序的影响都了然于胸，只有如此才能够成为一名优秀的 IC 设计工程师。<br>不要纠结 Verilog 的语法，而应立足实战。<br>Verilog 的设计语法子集非常精简简单，很快就可以上手入门。入门之后最好的学习方法是进行设计实战（实战是最好的老师），而不是进一步纠结 Verilog 的语法（不要浪费脑力试图记住大多数高级的 Verilog 语法，而是在需要使用的时候查阅即可）。</p>
</blockquote>
<p><strong>By Ricky</strong></p>
]]></content>
      <categories>
        <category>IC Design</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>IC Design</tag>
        <tag>计数器</tag>
        <tag>数字前端</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Docker + GitLab 构建自用的代码管理服务</title>
    <url>//posts/%E4%BD%BF%E7%94%A8-Docker-GitLab-%E6%9E%84%E5%BB%BA%E8%87%AA%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1.html</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><ul>
<li>一台 Ubuntu 系统的电脑作为服务器（我这里是一台 Ubuntu Xenial 16.04 的电脑），其他版本和系统也可以，只要 Docker CE 支持即可，详情请访问 <a href="https://www.docker.com" target="_blank" rel="noopener">Docker 官网</a>。</li>
<li>GitLab CE 要求内存 2G 以上</li>
</ul>
<h2 id="Docker-安装及配置"><a href="#Docker-安装及配置" class="headerlink" title="Docker 安装及配置"></a>Docker 安装及配置</h2><h3 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h3><p>Docker 使用 Google 公司推出的 Go 语言进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p>
<a id="more"></a>

<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p>它是目前最流行的 Linux 容器解决方案！</p>
<h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker \</span><br><span class="line">               docker-engine \</span><br><span class="line">               docker.io</span><br></pre></td></tr></table></figure>

<h3 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h3><p>由于 <code>apt</code> 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>

<p>鉴于国内网络的问题，建议使用国内源，官方源在注释中查看。<br>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code> 密钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span></span><br></pre></td></tr></table></figure>

<p>然后，向 <code>source.list</code> 中添加 Docker 软件源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">    <span class="string">"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">    <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">    stable"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ sudo add-apt-repository \</span></span><br><span class="line"><span class="comment">#    "deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="comment">#    $(lsb_release -cs) \</span></span><br><span class="line"><span class="comment">#    stable"</span></span><br></pre></td></tr></table></figure>

<h3 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h3><p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>

<h3 id="启动-Docker-CE"><a href="#启动-Docker-CE" class="headerlink" title="启动 Docker CE"></a>启动 Docker CE</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<h3 id="建立-Docker-用户组"><a href="#建立-Docker-用户组" class="headerlink" title="建立 Docker 用户组"></a>建立 Docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p>
<p>建立 <code>docker</code> 用户组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker      <span class="comment">#新建 docker 用户组</span></span><br><span class="line"></span><br><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span>     <span class="comment">#将当前用户加入 docker 组</span></span><br></pre></td></tr></table></figure>

<p>退出当前终端并重新登录，进行如下测试。</p>
<h3 id="测试-Docker-是否正确安装"><a href="#测试-Docker-是否正确安装" class="headerlink" title="测试 Docker 是否正确安装"></a>测试 Docker 是否正确安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image <span class="string">'hello-world:latest'</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">d1725b59e92d: Pull complete</span><br><span class="line">Digest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>
<p>若能正常输出以上信息，则说明安装成功。</p>
<h3 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h3><p>因为国内网络的原因，后续拉取 Docker 镜像会十分缓慢，建议安装好 Docker 后配置一下国内镜像加速。<br>Ubuntu 16.04 的配置方法如下（参考：<a href="https://www.docker-cn.com" target="_blank" rel="noopener">Docker 中国</a>）：<br>修改 <code>/etc/docker/daemon.json</code> 文件并写入如下内容（如果文件不存在请新建该文件）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">      <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p>
</blockquote>
<p>之后重新启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>到此为止，Docker 就配置好了，接下来安装 GitLab CE 就十分简单了。</p>
<h2 id="GitLab-安装及配置"><a href="#GitLab-安装及配置" class="headerlink" title="GitLab 安装及配置"></a>GitLab 安装及配置</h2><h3 id="GitLab-是什么"><a href="#GitLab-是什么" class="headerlink" title="GitLab 是什么"></a>GitLab 是什么</h3><p>GitLab 是一个类似与 GitHub 的开源源码托管服务，它提供了一个基于 Git 的全功能软件开发平台，可以通过 Web 界面访问公有或私有的项目，还具备很多与软件开发协作相关的其他功能。利用 GitLab 提供的这些功能，可以实践一些项目管理和协作流程。这套流程借鉴于很多成功的开源项目，非常适合在小型团队里使用。</p>
<h3 id="拉取-GitLab-镜像"><a href="#拉取-GitLab-镜像" class="headerlink" title="拉取 GitLab 镜像"></a>拉取 GitLab 镜像</h3><p>安装最新版 GitLab 镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>

<h3 id="启动-GitLab"><a href="#启动-GitLab" class="headerlink" title="启动 GitLab"></a>启动 GitLab</h3><p>使用 Docker 命令运行容器，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -d \</span><br><span class="line">    --hostname gitlab.asicfans.com \</span><br><span class="line">    -p 8443:443 -p 8080:80 -p 2222:22 \</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --restart always \</span><br><span class="line">    -v /srv/gitlab/config:/etc/gitlab \</span><br><span class="line">    -v /srv/gitlab/logs:/var/<span class="built_in">log</span>/gitlab \</span><br><span class="line">    -v /srv/gitlab/data:/var/opt/gitlab \</span><br><span class="line">    gitlab/gitlab-ce:latest</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意修改 hostname 为自己的域名或者 ip 地址。<br><code>-v</code> 命令表示将原有的挂载目录重新映射到自己的目录，这三个参数将 GitLab 的配置、数据和日志持久化到文件系统上，这样就可以保证后面升级 GitLab 时数据不会丢失。<br><code>-p</code> 命令表示将原有的端口映射一下，避免常用端口被占用。我这里使用的都是安全端口。如果大家的环境没有限制或不冲突可以使用与容器同端口，如：-p 443:443 -p 80:80 -p 22:22<br>上面的命令太长，也可以写成 shell 脚本</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt; start.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">HOST_NAME=gitlab.asicfans.com</span><br><span class="line">docker stop gitlab</span><br><span class="line">docker rm gitlab</span><br><span class="line">sudo docker run -d \\</span><br><span class="line">    --hostname \<span class="variable">$&#123;HOST_NAME&#125;</span> \\</span><br><span class="line">    -p 8443:443 -p 8080:80 -p 2222:22 \\</span><br><span class="line">    --name gitlab \\</span><br><span class="line">    --restart always \\</span><br><span class="line">    -v /srv/gitlab/config:/etc/gitlab \\</span><br><span class="line">    -v /srv/gitlab/logs:/var/<span class="built_in">log</span>/gitlab \\</span><br><span class="line">    -v /srv/gitlab/data:/var/opt/gitlab \\</span><br><span class="line">    gitlab/gitlab-ce:latest</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<blockquote>
<p>脚本编辑好之后运行脚本就可以了，就再也不用输入这么长的命令了！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sh start.sh</span><br></pre></td></tr></table></figure>

<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>修改 /etc/hosts 文件，使在本地端可以使用域名访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1 gitlab.asicfans.com</span><br></pre></td></tr></table></figure>
<p>这样就可以使用 <code>http://gitlab.asicfans.com:8080</code> 域名在本地从浏览器访问 GitLab 了（GitLab 初次启动会比较慢，等待大约一分钟）。</p>
<h3 id="试用-GitLab"><a href="#试用-GitLab" class="headerlink" title="试用 GitLab"></a>试用 GitLab</h3><p>首先根据提示输入管理员密码，这个密码是管理员用户的密码。对应的用户名是 root，用于以管理员身份登录 GitLab。</p>
<p><img src="https://img.mukewang.com/5a73280a0001efc904500304.png" alt=""></p>
<p>设置好密码后去注册一个普通账号</p>
<p><img src="https://img.mukewang.com/5a7327360001cdff03400477.png" alt=""></p>
<p>注册成功后会跳到首页，这样就可以创建一个项目了</p>
<p><img src="https://img.mukewang.com/5a7327620001bc7f05460400.png" alt=""></p>
<p>项目建好了，我们加一个 ssh key，以后本地 pull/push 就简单啦!</p>
<p><img src="https://img.mukewang.com/5a73277b0001982f07080200.png" alt=""></p>
<p>首先去到添加 ssh key 的页面</p>
<p><img src="https://img.mukewang.com/5a73278e0001303620200994.png" alt=""></p>
<p>然后拿到我们的 ssh key 贴到框框里就行了<br>获取 ssh key：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先看看是不是已经有了，如果有内容就直接 copy 贴过去就行啦</span></span><br><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果上一步没有这个文件 我们就创建一个，运行下面命令（邮箱改成自己的），一路回车就好了</span></span><br><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>点开我们刚创建的项目，复制项目 ssh 的地址。<br>添加个文件，测试一下（我的项目叫 test）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> ssh://git@gitlab.asicfans.com:2222/wangqq/test.git</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span> &amp;&amp; <span class="built_in">echo</span> <span class="built_in">test</span> &gt; README.md  <span class="comment"># 添加文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#push 上去</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"test"</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>这样我们就可以在 GitLab 上看到我们刚才提交的结果了。到这 GitLab 的本地端使用就已经没问题了，但是要想不在家，或者在其他地方也可以访问，那我们就需要进行一下，内网穿透！</p>
<h2 id="frp-配置"><a href="#frp-配置" class="headerlink" title="frp 配置"></a>frp 配置</h2><p>配置 frp 你需要有一个有公网 ip 的云服务器和自己的域名，然后在云服务器和本地端分别下载安装 frp 并进行配置。</p>
<p>下载与系统对应的 frp 文件，frp 支持多种系统架构，详情请访问 <a href="https://github.com/fatedier/frp/" target="_blank" rel="noopener"><strong>frp</strong></a> 查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ uname -a      <span class="comment"># 首先使用 uname 命令查看一下你的系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我这里是 Ubuntu x86_x64 所以下载 Linux_amd64 的软件包</span></span><br><span class="line">$ wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压安装包</span></span><br><span class="line">$ tar -zxvf frp_0.21.0_linux_amd64.tar.gz</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> frp_0.21.0_linux_amd64</span><br></pre></td></tr></table></figure>

<p>然后分别配置服务器端的 <code>frps.ini</code> 文件和本地端的 <code>frpc.ini</code> 文件。</p>
<ul>
<li><p>1.修改 frps.ini 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frps.ini</span></span><br><span class="line">[common]    </span><br><span class="line">bind_port = 7000        <span class="comment"># 穿透使用的端口</span></span><br><span class="line">vhost_http_post = 80    <span class="comment"># 从外网访问的端口</span></span><br><span class="line">subdomain_host = asicfans.com   <span class="comment"># 主域名</span></span><br><span class="line">token = xxxx            <span class="comment"># 服务器与本地的校验信息，校验信息错误无法穿透，自行设置</span></span><br></pre></td></tr></table></figure></li>
<li><p>2.启动 frps</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./frps -c ./frps.ini</span><br></pre></td></tr></table></figure></li>
<li><p>3.修改 frpc.ini 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x   <span class="comment"># 你的服务器 ip 地址</span></span><br><span class="line">server_port = 7000      <span class="comment"># 开放的穿透端口</span></span><br><span class="line">token = xxxx            <span class="comment"># 需要与服务器端一致</span></span><br><span class="line"></span><br><span class="line">[gitlab]</span><br><span class="line"><span class="built_in">type</span> = http</span><br><span class="line">local_port = 8080</span><br><span class="line">subdomain = gitlab</span><br></pre></td></tr></table></figure></li>
<li><p>4.启动 frpc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.将 gitlab.asicfans.com 的域名 A 记录解析到 ip <code>x.x.x.x</code>， 如果服务器已经有了对应的域名，也可以将 CNAME 记录解析到服务器原先的域名。</p>
</li>
<li><p>6.通过浏览器访问 <a href="http://gitlab.asicfans.com" target="_blank" rel="noopener">http://gitlab.asicfans.com</a> 即可访问到处于内网的 gitlab 服务了。<br>这样就不用使用 ssh key 的方式 clone/pull/push 代码仓库了，就可以直接使用 http 的方式进行操作了！ 十分方便！</p>
</li>
</ul>
<p>自此，我们就可以让自己和小伙伴们一起愉快的在 GitLab 上玩耍啦！！</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>GitLab</tag>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>make 命令及 makefile 文件编写</title>
    <url>//posts/make-%E5%91%BD%E4%BB%A4%E5%8F%8A-makefile-%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间因为工作需要简单学习了一下 make 命令以及 makefile 文件的编写，这里整理一篇在网上看到的比较简洁明了的教程。</p>
<blockquote>
<p>代码变成可执行文件，叫做 <a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener">编译</a>（ compile ）；先编译这个，还是先编译那个（即编译的安排），叫做 <a href="https://en.wikipedia.org/wiki/Software_build" target="_blank" rel="noopener">构建</a>（ build ）。</p>
<p><a href="https://en.wikipedia.org/wiki/Make_%28software%29" target="_blank" rel="noopener">Make</a> 是最常用的构建工具，诞生于 1977 年，主要用于 C 语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用 Make 构建。</p>
<p>本文介绍 Make 命令的用法，从简单的讲起，不需要任何基础，只要会使用命令行，就能看懂。我的参考资料主要是 Isaac Schlueter 的<a href="https://gist.github.com/isaacs/62a2d1825d04437c6f08" target="_blank" rel="noopener">《 Makefile 文件教程》</a>和<a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener">《 GNU Make 手册》</a>。</p>
<blockquote>
<p>来源： <a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/make.html</a><br>作者： 阮一峰</p>
</blockquote>
</blockquote>
<a id="more"></a>

<h2 id="Make-的概念"><a href="#Make-的概念" class="headerlink" title="Make 的概念"></a>Make 的概念</h2><p>Make 这个词，英语的意思是”制作”。Make 命令直接用了这个意思，就是要做出某个文件。比如，要做出文件 test.txt ，就可以执行下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make test.txt</span><br></pre></td></tr></table></figure>
<p>但是，如果你真的输入这条命令，它并不会起作用。因为 Make 命令本身并不知道，如何做出 test.txt ，需要有人告诉它，如何调用其他命令完成这个目标。</p>
<p>比如，假设文件 test.txt 依赖于 a.txt 和 b.txt ，是后面两个文件连接（ cat 命令）的产物。那么， make 需要知道下面的规则。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.txt: a.txt b.txt</span><br><span class="line">    cat a.txt b.txt &gt; test.txt</span><br></pre></td></tr></table></figure>
<p>也就是说， make test.txt 这条命令的背后，实际上分成两步：第一步，确认 a.txt 和 b.txt 必须已经存在，第二步使用 cat 命令 将这个两个文件合并，输出为新文件。</p>
<p>像这样的规则，都写在一个叫做 Makefile 的文件中， Make 命令依赖这个文件进行构建。 Makefile 文件也可以写为 makefile ， 或者用命令行参数指定为其他文件名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make -f rules.txt</span><br><span class="line"># 或者</span><br><span class="line">$ make --file&#x3D;rules.txt</span><br></pre></td></tr></table></figure>
<p>上面代码指定 make 命令依据 rules.txt 文件中的规则，进行构建。</p>
<p>总之， make 只是一个根据指定的 Shell 命令进行构建的工具。它的规则很简单，你规定要构建哪个文件、它依赖哪些源文件，当那些文件有变动时，如何重新构建它。</p>
<h2 id="Makefile-文件格式"><a href="#Makefile-文件格式" class="headerlink" title="Makefile 文件格式"></a>Makefile 文件格式</h2><p>构建规则都写在 Makefile 文件里面，要学会如何 Make 命令，就必须学会如何编写 Makefile 文件。</p>
<h3 id="Makefile-概述"><a href="#Makefile-概述" class="headerlink" title="Makefile 概述"></a>Makefile 概述</h3><p>Makefile 文件由一系列规则（ rules ）构成。每条规则的形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;target&gt;: &lt;prerequisites&gt;</span><br><span class="line">[tab]	&lt;commands&gt;</span><br></pre></td></tr></table></figure>
<p>上面第一行冒号前面的部分，叫做“目标”（ target ），冒号后面的部分叫做“前置条件”（ prerequisites ）；第二行必须由一个 tab 键起首，后面跟着“命令”（ commands ）。</p>
<p>“目标”是必需的，不可省略；“前置条件”和“命令”都是可选的，但是两者之中必须至少存在一个。</p>
<p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p>
<h3 id="目标（target）"><a href="#目标（target）" class="headerlink" title="目标（target）"></a>目标（target）</h3><p>一个目标（ target ）就构成一条规则。目标通常是文件名，指明 Make 命令所要构建的对象，比如上文的  test.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p>
<p>除了文件名，目标还可以是某个操作的名字，这称为“伪目标”（ phony target ）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm *.o</span><br></pre></td></tr></table></figure>
<p>上面代码的目标是 clean ，它不是文件名，而是一个操作的名字，属于“伪目标”，作用是删除对象文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make clean</span><br></pre></td></tr></table></figure>
<p>但是，如果当前目录中，正好有一个文件叫做 clean ，那么这个命令不会执行。因为 Make 发现 clean 文件已经存在，就认为没有必要重新构建了，就不会执行指定的 rm 命令。</p>
<p>为了避免这种情况，可以明确声明 clean 是“伪目标”，写法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure>
<p>声明 clean 是“伪目标”之后， make 就不会去检查是否存在一个叫做 clean 的文件，而是每次运行都执行对应的命令。像 .PHONY 这样的内置目标名还有不少，可以查看<a href="https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets" target="_blank" rel="noopener">手册</a>。</p>
<p>如果 Make 命令运行时没有指定目标，默认会执行 Makefile 文件的第一个目标。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>上面代码执行 Makefile 文件的第一个目标。</p>
<h3 id="前置条件（-prerequisites"><a href="#前置条件（-prerequisites" class="headerlink" title="前置条件（ prerequisites )"></a>前置条件（ prerequisites )</h3><p>前置条件通常是一组文件名，之间用空格分隔。它指定了“目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的 last-modification 时间戳比目标的时间戳新），“目标”就需要重新构建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result.txt: source.txt</span><br><span class="line">    cp source.txt result.txt</span><br></pre></td></tr></table></figure>
<p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中， source.txt 已经存在，那么 make result.txt 可以正常运行，否则必须再写一条规则，来生成 source.txt 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source.txt</span><br><span class="line">    echo &quot;this is the source&quot; &gt; source.txt</span><br></pre></td></tr></table></figure>
<p>上面代码中， source.txt 后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用 make source.txt ，它都会生成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make result.txt</span><br><span class="line">$ make result.txt</span><br></pre></td></tr></table></figure>
<p>上面命令连续执行两次 make result.txt 。第一次执行会先新建 source.txt ，然后再新建 result.txt 。第二次执行， Make 发现 source.txt 没有变动（时间戳晚于 result.txt ），就不会执行任何操作， result.txt 也不会重新生成。</p>
<p>如果需要生成多个文件，往往采用下面的写法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source: file1 file2 file3</span><br></pre></td></tr></table></figure>
<p>上面代码中， source 是一个伪目标，只有三个前置文件，没有任何对应的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make <span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>make source</code> 命令后，就会一次性生成 file1 ， file2 ， file3 三个文件。这比下面的写法要方便很多:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make file1</span><br><span class="line">$ make file2</span><br><span class="line">$ make file3</span><br></pre></td></tr></table></figure>
<h3 id="命令（-commands-）"><a href="#命令（-commands-）" class="headerlink" title="命令（ commands ）"></a>命令（ commands ）</h3><p>命令（ commands ）表示如何更新目标文件，由一行或多行的 Shell 命令组成。它是构建“目标”的具体指令，它的运行结果通常就是生成目标文件。</p>
<p>每行命令之前必须有一个 tab 键。如果想用其他键，可以用内置变量 .RECIPEPREFIX 声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.RECTPEPREFIX &#x3D; &gt;</span><br><span class="line">all:</span><br><span class="line">&gt; echo Hello, world</span><br></pre></td></tr></table></figure>
<p>上面代码用 .RECIPEPREFIX 指定，大于号（ &gt; ）替代 tab 键。所以，每一行命令的起首变成了大于号，而不是 tab 键。</p>
<p>需要注意的是，每行命令在一个单独的 shell 中执行。这些 Shell 之间没有继承关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var-lost:</span><br><span class="line">    export foo&#x3D;bar</span><br><span class="line">	echo &quot;foo&#x3D;[$$foo]&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码执行后（<code>make var-lost</code>），取不到 foo 的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var-kept:</span><br><span class="line">    export foo&#x3D;bar; echo &quot;foo&#x3D;[$$foo]&quot;</span><br></pre></td></tr></table></figure>
<p>另一个解决办法是在换行符前加反斜杠转义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var-kept:</span><br><span class="line">    export foo&#x3D;bar; \</span><br><span class="line">    echo &quot;foo&#x3D;[$$foo]&quot;</span><br></pre></td></tr></table></figure>
<p>最后一个方法是加上 <code>.ONESHELL:</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.ONESHELL:</span><br><span class="line">var-kept:</span><br><span class="line">    export foo&#x3D;bar;</span><br><span class="line">    echo &quot;foo&#x3D;[$$foo]&quot;</span><br></pre></td></tr></table></figure>

<h2 id="Makefile-文件语法"><a href="#Makefile-文件语法" class="headerlink" title="Makefile 文件语法"></a>Makefile 文件语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>井号（#）在 Makefile 中表示注释。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这是注释</span><br><span class="line">result.txt: source.txt</span><br><span class="line">    # 这是注释</span><br><span class="line">    cp source.txt result.txt # 这是注释</span><br></pre></td></tr></table></figure>
<h3 id="回声（-echoing-）"><a href="#回声（-echoing-）" class="headerlink" title="回声（ echoing ）"></a>回声（ echoing ）</h3><p>正常情况下，make 会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test:</span><br><span class="line">    # 这是测试</span><br></pre></td></tr></table></figure>
<p>执行上面的规则，会得到下面的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure>
<p>在命令的前面加上 @ ，就可以关闭回声。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test:</span><br><span class="line">    @# 这是测试</span><br></pre></td></tr></table></figure>
<p>现在再执行 <code>make test</code>，就不会有任何输出。</p>
<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的 echo 命令前面加上 @ 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test:</span><br><span class="line">    @# 这是测试</span><br><span class="line">    @echo TODO</span><br></pre></td></tr></table></figure>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符（ wildcard ）用来指定一组符合条件的文件名。 Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 [...] 。比如， *.o 表示所有后缀名为 .o 的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm -f *.o</span><br></pre></td></tr></table></figure>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>Make 命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是 %。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%.o: %.c</span><br></pre></td></tr></table></figure>
<p>等同于下面的写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1.o: f1.c</span><br><span class="line">f2.o: f2.c</span><br></pre></td></tr></table></figure>
<p>使用通配符 %，可以将大量同类型的文件，只用一条规则就完成构建。</p>
<h3 id="变量和赋值符"><a href="#变量和赋值符" class="headerlink" title="变量和赋值符"></a>变量和赋值符</h3><p>Makefile 允许使用等号自定义变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt &#x3D; Hello World</span><br><span class="line">test:</span><br><span class="line">    @echo $(txt)</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 txt 等于 Hello World 。调用时，变量需要放在 $( ) 之中。</p>
<p>调用 Shell 变量，需要在美元符号前，再加一个美元符号，这是因为 Make 命令会对美元符号转义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test:</span><br><span class="line">    @echo $$HOME</span><br></pre></td></tr></table></figure>
<p>有时，变量的值可能指向另一个变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v1 &#x3D; $(v2)</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 v1 的值是另一个变量 v2 。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。</p>
<p>为了解决类似问题， Makefile 一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看 <a href="https://stackoverflow.com/questions/448910/what-is-the-difference-between-the-gnu-makefile-variable-assignments-a" target="_blank" rel="noopener">StackOverflow</a> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在执行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure>
<h3 id="内置变量（Implicit-Variables）"><a href="#内置变量（Implicit-Variables）" class="headerlink" title="内置变量（Implicit Variables）"></a>内置变量（Implicit Variables）</h3><p>Make 命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的 Make 工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html" target="_blank" rel="noopener">手册</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">    $(CC) -o output input.c</span><br></pre></td></tr></table></figure>
<h3 id="自动变量（Automatic-Variables）"><a href="#自动变量（Automatic-Variables）" class="headerlink" title="自动变量（Automatic Variables）"></a>自动变量（Automatic Variables）</h3><p>Make 命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。<br><strong>(1) $@</strong><br>$@ 指代当前目标，就是 Make 命令当前构建的那个目标。 比如，<code>make foo</code>的 $@ 就指代 foo。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.txt b.txt:</span><br><span class="line">    touch $@</span><br></pre></td></tr></table></figure>
<p>等同于下面的写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    touch a.txt</span><br><span class="line">b.txt:</span><br><span class="line">    touch b.txt</span><br></pre></td></tr></table></figure>
<p><strong>(2) $&lt;</strong><br>$&lt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么 $&lt; 就指代 p1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.txt: b.txt c.txt</span><br><span class="line">    cp $&lt; $@</span><br></pre></td></tr></table></figure>
<p>等同于下面的写法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.txt: b.txt c.txt</span><br><span class="line">    cp b.txt a.txt</span><br></pre></td></tr></table></figure>
<p><strong>(3) $?</strong><br>$? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$? 就指代 p2 。<br><strong>(4) $^</strong><br>$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。<br><strong>(5) $* <em>*<br>$</em> 指代匹配符 % 匹配的部分， 比如 % 匹配 f1.txt 中的 f1 ，$* 就表示 f1。<br>**(6) $(@D) 和 $(@F)</strong><br>$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@ 是 src/input.c，那么 $(@D) 的值为 src ，$(@F) 的值为 input.c。<br><strong>(7) $(&lt;D) 和 $(&lt;F)</strong><br>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p>
<p>所有的自动变量清单，请看<a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html" target="_blank" rel="noopener">手册</a>。下面是自动变量的一个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dest&#x2F;%.txt: src&#x2F;%.txt</span><br><span class="line">	@[ -d dest ] || mkdir dest</span><br><span class="line">	cp $&lt; $@</span><br></pre></td></tr></table></figure>
<p>上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&lt; 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。</p>
<h3 id="判断和循环"><a href="#判断和循环" class="headerlink" title="判断和循环"></a>判断和循环</h3><p>Makefile 使用 Bash 语法，完成判断和循环。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifeq ($(CC),gcc)</span><br><span class="line">  libs=$(libs_for_gcc)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=$(normal_libs)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LIST = one two three</span><br><span class="line">all:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> $(LIST); <span class="keyword">do</span> \</span><br><span class="line">        <span class="built_in">echo</span> $<span class="variable">$i</span>; \</span><br><span class="line">     <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> one two three; <span class="keyword">do</span> \</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$i</span>; \</span><br><span class="line">    <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>上面代码的运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Makefile 还可以使用函数，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">function</span> arguments)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="variable">$&#123;function arguments&#125;</span></span><br></pre></td></tr></table></figure>
<p>Makefile 提供了许多<a href="https://www.gnu.org/software/make/manual/html_node/Functions.html" target="_blank" rel="noopener">内置函数</a>，可供调用。下面是几个常用的内置函数。<br><strong>(1) shell 函数</strong><br>shell 函数用来执行 shell 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">srcfiles := $(shell <span class="built_in">echo</span> src/&#123;00..99&#125;.txt)</span><br></pre></td></tr></table></figure>
<p><strong>(2) wildcard 函数</strong><br>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">srcfiles := $(wildcard src/*.txt)</span><br></pre></td></tr></table></figure>
<p><strong>(3) subst 函数</strong><br>subst 函数用来文本替换，格式如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(subst from,to,text)</span><br></pre></td></tr></table></figure>
<p>下面的例子将字符串”feet on the street”替换成”fEEt on the strEEt”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(subst ee,EE,feet on the street)</span><br></pre></td></tr></table></figure>
<p>下面是一个稍微复杂的例子。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line"><span class="comment"># space 变量用两个空变量作为标识符，当中是一个空格</span></span><br><span class="line">space:= $(empty) $(empty)</span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= $(subst $(space),$(comma),$(foo))</span><br><span class="line"><span class="comment"># bar is now 'a,b,c'.</span></span><br></pre></td></tr></table></figure>
<p><strong>(4) patsubst 函数</strong><br>patsubst 函数用于模式匹配的替换，格式如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(patsubst pattern,replacement,text)</span><br></pre></td></tr></table></figure>
<p>下面的例子将文件名 “x.c.c bar.c”，替换成 “x.c.o bar.o”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(patsubst %.c,%.o,x.c.c bar.c)</span><br></pre></td></tr></table></figure>
<p><strong>(5) 替换后缀名</strong><br>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上 patsubst 函数的一种简写形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min: $(OUTPUT:.js&#x3D;.min.js)</span><br></pre></td></tr></table></figure>
<p>上面代码的意思是，将变量 OUTPUT 中的后缀名 .js 全部替换成 .min.js 。</p>
<h2 id="Makefile-实例"><a href="#Makefile-实例" class="headerlink" title="Makefile 实例"></a>Makefile 实例</h2><p>(1) 执行多目标编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">        rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">        rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">        rm *.diff</span><br></pre></td></tr></table></figure>
<p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（ cleanall ），删除所有指定类型的文件。<br>(2) 编译 C 语言项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o </span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h</span><br><span class="line">    cc -c display.c</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">     rm edit main.o kbd.o command.o display.o</span><br><span class="line"></span><br><span class="line">.PHONY: edit clean</span><br></pre></td></tr></table></figure>
<p>Make 命令和Makefile文件的介绍就到这里。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>make</tag>
        <tag>makefile</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Hexo+Github Pages 搭建个人博客</title>
    <url>//posts/%E4%BD%BF%E7%94%A8Hexo-GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h2 id="使用-Hexo-Github-Pages-搭建个人博客记录"><a href="#使用-Hexo-Github-Pages-搭建个人博客记录" class="headerlink" title="使用 Hexo+Github Pages 搭建个人博客记录"></a>使用 Hexo+Github Pages 搭建个人博客记录</h2><p>最近在学习的时候发现很多人都推荐说，要学会写作。很多大牛都会有自己的博客，或者微信公众号。不仅要学会学习，更要学会表达，而写作就是一个很好的方式。通过把自己学到的东西再次输出出来，才有价值，写作是一个人吸收知识，并增强记忆转化成自己东西的过程。很多人认为学校里出来了之后应该会很少写文字了，其实不然，在工作中经常会有各种各样的汇报和报告需要你去写。<br>如果你不经常去写一些文字，慢慢的也就生疏了，也就忘了该怎么通过书面方式更好的表达信息。比如我们领导让大家每周写一份周报，每到周五的时候大家总是在纠结，这周报该怎么写。还有做测试的时候要有测试方案，测试结果，测试报告（分析）都是要写文档的。跟文字打交道的时候还是很多的啊！所以啊，平时还得多写写！</p>
<a id="more"></a>

<p>我在看一些大牛的博客的时候，发现他们的博客，好像都很好看。我很羡慕，于是我也想搭建一个自己的个人博客，所以就有了本站！<br>我了解到建站的方法有很多，比如:</p>
<ul>
<li>Hexo + GitHub Pages</li>
<li>Jekyll + GitHub Pages </li>
<li>WordPress + 服务器 + 域名</li>
<li>DeDeCMS + 服务器 + 域名</li>
<li>……</li>
</ul>
<p>我选择了使用 Hexo + GitHub Pages + 域名 的方法来建站。<br>首先 Hexo 简约风格我很喜欢，其次利用 GitHub Pages 的免费存储空间不需要自己购买服务器，<br>有一个 GitHub 账号就 ok 了，然后域名其实是一个可选项，GitHub 会提供一个 <a href="http://xxxx.github.io/" target="_blank" rel="noopener">http://xxxx.github.io/</a> 这种形式的域名进行访问。</p>
<h2 id="下面来简单记录一下，本站的搭建过程"><a href="#下面来简单记录一下，本站的搭建过程" class="headerlink" title="下面来简单记录一下，本站的搭建过程"></a>下面来简单记录一下，本站的搭建过程</h2><p>安装 Hexo 很简单，但是在安装前需要配置一些环境，需要安装 Node.js 和 Git 。因为 Hexo 博客系统是基于 Node.js 写的，需要 Node.js 的环境才能运行。 Hexo 运行之后会在本地生成网页，所以我们需要使用 Git 把本地网页文件上传到 GitHub 上的远程仓库里。（当然使用 GitHub 桌面版也可以上传。）</p>
<h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>在 Node.js 官网：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载最新的稳定版，安装时保持默认设置，一路 next 就好，等待安装完成。<br>安装好之后，按<code>Win+R</code>,输入 <code>cmd</code>，运行命令提示符，输入<code>node -v</code>和 <code>nmp -v</code>，如果出现版本号，那么就安装成功了。<br><img src="https://photo.ishield.cn/pic/5b8ca1e59dc6d611b60ee2bd" alt="node -v npm -v"></p>
<h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><p>去 Git 官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a> 下载最新的稳定版的 git 安装包，直接默认配置安装就好了，一路 next 就好。<br><img src="https://photo.ishield.cn/pic/5b8ca4519dc6d611b60ee2d1" alt="git"><br>安装完成后，在桌面右键，点击<code>Git Bush Here</code>，输入 <code>git --version</code>，如果成功出现 Git 的版本号，到这里 Git 的环境配置就完成了！（如果你对 Git 不太熟悉，不太会用 Git 来上传你的博客，你也可以考虑使用 GitHub 的桌面版。）<br><img src="https://ww3.sinaimg.cn/large/005YhI8igy1fuw5x63irrj30630a0gln" alt=""></p>
<h2 id="注册-GitHub-和配置"><a href="#注册-GitHub-和配置" class="headerlink" title="注册 GitHub 和配置"></a>注册 GitHub 和配置</h2><p>身为一个程序员，怎么能不知道 GitHub！每个程序员都应该有一个 GitHub 账号！GitHub是一个大型的代码托管平台，上面有很多技术大牛，也有很多有趣的开源项目，像Google、FaceBook、Macrosoft 等大公司也都在使用 GitHub。我们的博客就是托管在 GitHub 上的。</p>
<p>GitHub Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默认提供的域名 github.io 或者使用自定义域名来发布站点。</p>
<p>如果你还没有 Github 账号的话，需要先到 GitHub 官网进行注册： <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> </p>
<p>注册完成之后，我们需要创建一个仓库来存放我们的博客。新建一个项目，如下图所示：<br><img src="https://photo.ishield.cn/pic/5b8ca25b9dc6d611b60ee2c3" alt=""><br>仓库名称一般使用用户名加 <code>.github.io</code>后缀，如下图所示：<br><img src="https://photo.ishield.cn/pic/5b8ca2889dc6d611b60ee2c5" alt=""><br>最后，创建完成后，就可以直接访问 <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io/</a> ,如果可以正常访问，那么 GitHub 的配置就搞完了。<br>到这里环境就基本上搭好了，下面就开始安装 Hexo 正式搭建个人博客。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>Hexo 是什么？<br>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown (或者其他渲染引擎)解析文章，在几秒内，即可利用靓丽的主题生成静态网页。并且一条指令即可部署到 GitHub Pages 或者其他网站。想更多了解 Hexo 请阅读 Hexo 官方文档: <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p>
<p>首先，在你的电脑里，新建一个文件夹专门用来存放你的博客文件。比如我的都放在 D:\study\hexo 目录下。</p>
<p>然后在该目录下，右键点击 <code>Git Bush Here</code>，打开 Git 控制台窗口，接下来的操作都在 Git 控制台进行，反正我是挺喜欢敲命令行的感觉。</p>
<p>接下来，在该目录下，输入 <code>npm install -g hexo-cli</code>，安装 Hexo ，这里会有一个 <code>WARN</code>，不用担心这不会影响正常使用。然后在安装 Hexo 部署到 Github Pages 的 deployer。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli </span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p><img src="https://photo.ishield.cn/pic/5b8ca2ae9dc6d611b60ee2c6" alt=""></p>
<p>查看 Hexo 的版本，输入 <code>hexo -v</code>，正确输入如下信息就表示 Hexo 安装成功了。<br><img src="https://ww3.sinaimg.cn/large/005YhI8igy1fuw600gjbcj30gz0de74s" alt=""></p>
<h2 id="Hexo基础配置"><a href="#Hexo基础配置" class="headerlink" title="Hexo基础配置"></a>Hexo基础配置</h2><p>Hexo 安装完成后，执行下面的命令来初始化 Hexo ，对应的用户名(文件夹名称)改成自己的。Hexo 会在指定的文件夹中新建博客系统，和安装必备组件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init strongwong.github.io</span><br><span class="line">$ <span class="built_in">cd</span> strongwong.github.io</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p><img src="https://photo.ishield.cn/pic/5b8ca2f39dc6d611b60ee2c8" alt=""></p>
<p>新建完成后，在本地运行 Hexo 查看效果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate	<span class="comment">#或者运行 hexo g 根据配置生成博客</span></span><br><span class="line">$ hexo server	<span class="comment">#或者运行 hexo s 在本地运行 Hexo 登录 localhost:4000 查看</span></span><br><span class="line">			<span class="comment">#按 ctrl + c 即可关闭本地服务器</span></span><br></pre></td></tr></table></figure>

<p>这时我们到浏览器中输入 <code>localhost:4000</code> 就可以在本地端正常访问了(如下图)，这样的话就说明博客已经打起来了，但是现在只是在本地，别人还不能访问，接下来我们就要把本地博客部署到 GitHub 上，让别人也可以看到你的博客。<br><img src="https://photo.ishield.cn/pic/5b8ca3139dc6d611b60ee2cc" alt=""></p>
<h2 id="本地-Hexo-仓库与-GitHub-关联"><a href="#本地-Hexo-仓库与-GitHub-关联" class="headerlink" title="本地 Hexo 仓库与 GitHub 关联"></a>本地 Hexo 仓库与 GitHub 关联</h2><p>配置 GitHub 的 SSH 密钥，让本地项目通过 git 命令与远程 GitHub 仓库建立联系，我们在本地做了修改之后直接通过 git 命令就可以把博客同步到 GitHub 上。</p>
<p>1.首先，在 git 控制台中，输入如下命令，配置个人参数(你的名字，你的邮箱)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">$ git config --global user.email <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure>

<p>2.接下来生成 SSH key 根据提示进行操作(其实一路回车就好了。)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure>

<p>3.执行完之后就会在默认路径下生成 <code>id_rsa.pub</code>文件。默认路径是：<code>C:\Users\Administrator\.ssh\id_rsa.pub</code> 需要注意的是 .ssh 是隐藏文件夹。<br>使用记事本打开这个文件，复制文件内容，然后粘贴到 <a href="https://github.com/settings/ssh/" target="_blank" rel="noopener">https://github.com/settings/ssh/</a> 的 “new SSH key” 中。</p>
<p>4.输入下面的命令，查看 SSH 是否配置成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>如果是下面的反馈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure>
<p>直接输入 yes 就好了，然后就会看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi strongwong! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>这样的话，我们 SSH key 就配置成功了。</p>
<p>5.配置 deploy 参数<br>在博客根目录下，找到 <code>__config.yml</code> 文件，找到 deploy 关键字，进行如下配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:strongwong&#x2F;strongwong.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>6.将本地博客提交到 GitHub Pages</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g			<span class="comment">#根据你的改动生成新的静态文件(即 public 文件夹)</span></span><br><span class="line">$ hexo s			<span class="comment">#启动本地预览 ctrl + c 关闭</span></span><br><span class="line">$ hexo d			<span class="comment">#部署到远程站点</span></span><br><span class="line">$ hexo clean		<span class="comment">#清除旧的静态文件(即 public 文件夹)</span></span><br></pre></td></tr></table></figure>

<p>7.这时在浏览器输入 <a href="https://strongwong.github.io/" target="_blank" rel="noopener">https://strongwong.github.io/</a> ，可以正常访问就说明 hexo 搭建的博客已经成功部署到 GitHub 了，小伙伴们都可以通过这个地址访问自己的博客了。</p>
<h2 id="将个人域名解析到-GitHub"><a href="#将个人域名解析到-GitHub" class="headerlink" title="将个人域名解析到 GitHub"></a>将个人域名解析到 GitHub</h2><p>看着这个 GitHub 下面的二级域名，总觉得让人不太爽，所以有很多小伙伴都买了自己的域名，然后将自己域名绑定到 GitHub Pages 的博客上。<br>于是我也就到阿里云上购买了一个万网域名，也不是很贵。<br>进入阿里云网站，打开阿里云域名控制台，点击管理，然后点击域名解析。<br><img src="https://photo.ishield.cn/pic/5b8ca34f9dc6d611b60ee2cf" alt=""><br><img src="https://photo.ishield.cn/pic/5b8ca3669dc6d611b60ee2d0" alt=""></p>
<p>在下图中点击添加记录，添加解析：</p>
<blockquote>
<p>记录类型选择<code>CNAME</code><br>主机记录填 <code>www</code><br>解析线路选择 <code>默认</code><br>记录值填 <code>yourname.github.io</code><br>TTL 值为 <code>10</code> 分钟<br>再添加一个解析，记录类型 <code>A</code><br>主机记录填 <code>@</code><br>解析线路选择 <code>默认</code><br>记录值填你 GitHub 的 IP 地址 (在 cmd 中 ping：<code>ping yourname.github.io</code>)<br><img src="https://ww3.sinaimg.cn/large/005YhI8igy1fuw67ojfrmj31ba05pgm6" alt=""></p>
</blockquote>
<p>在本地博客的 source 目录下新建一个 CNAME 文件(没有扩展名)，用记事本打开填入购买的域名地址:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.strongwong.top</span><br></pre></td></tr></table></figure>
<p>将博客重新发布一次：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g -d	<span class="comment">#generate 和 deploy 的组合命令</span></span><br></pre></td></tr></table></figure>
<p>此时，在浏览器中输入你的个人域名(<a href="https://www.strongwong.top/" target="_blank" rel="noopener">www.strongwong.top</a>)，如果正常访问你的博客就说明，域名绑定成功，域名解析成功啦！！在这伟大的互联网时代，终于拥有了自己的网站啦！</p>
<h3 id="发表一篇文章"><a href="#发表一篇文章" class="headerlink" title="发表一篇文章"></a>发表一篇文章</h3><p>运行下面的命令，就会创建一个文章文件，在本地博客的 source_posts 文件夹下就会有一个新建的 markdown 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"文章标题"</span>   <span class="comment"># hexo n "文章标题" 这种简写也可以</span></span><br></pre></td></tr></table></figure>
<p>文章编辑好之后，推送到 GitHub 上我们在站点上就可以看到新的文章了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g  <span class="comment">#生成 </span></span><br><span class="line">$ hexo d  <span class="comment">#部署</span></span><br></pre></td></tr></table></figure>

<h2 id="安装-Next-主题及个性化"><a href="#安装-Next-主题及个性化" class="headerlink" title="安装 Next 主题及个性化"></a>安装 Next 主题及个性化</h2><p>Hexo 有非常多的主题可以选择，可以到官方主题库进行选择： <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>我这里选择了资料相对详细、丰富的 Next 主题，前往 Next 主题发布页面下载：<a href="https://github.com/iisnan/hexo-theme-next/releases/" target="_blank" rel="noopener">https://github.com/iisnan/hexo-theme-next/releases/</a><br>下载最新版本的 Next 主题包，解压缩，将文件名称改为 next，放置到博客根目录的 themes 目录下。<br>打开站点配置文件 <code>_config.yml</code>，找到 themes 字段，修改为 next。<br>到此，next 主题安装完成。</p>
<p>关于 next 主题的一些配置请查阅 next 主题官方文档：<a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">https://theme-next.iissnan.com/</a></p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>花了两天时间把博客搭起来，还是挺开心的。博客使用 Hexo 搭建，主题使用 Next，评论系统使用 Valine ，文章浏览统计使用 LeanCloud ，网站访客数量使用不蒜子，另外还使用了 Google 统计，方便自己查看数据。<br>我会坚持在工作之余，写点技术分享，记录一下我的学习历程。我也不知道我会分享哪些东西，但是我想可能还是嵌入式软件方面可能会比较多一些吧，其他方面也可能会分享一些学习、工作、生活中的经历和经验吧！祝我未来，越来越好！</p>
<p>strongwong</p>
<p>2018.8.2</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 vivado 综合 wujian100 生成 bitstream 文件</title>
    <url>//posts/%E4%BD%BF%E7%94%A8-vivado-%E7%BB%BC%E5%90%88-wujian100-%E7%94%9F%E6%88%90-bitstream-%E6%96%87%E4%BB%B6.html</url>
    <content><![CDATA[<h2 id="综合环境"><a href="#综合环境" class="headerlink" title="综合环境"></a>综合环境</h2><p>上一篇 blog 呢，我记录一下运行 wujian100 的一些仿真过程，这篇 blog 我将简单介绍一下使用 vivado 来综合 wujian100 需要注意的一些地方。</p>
<p>首先，说明一下我的综合环境，我是在 WSL 下安装的 vivado 2018.3 版本，然后是完全 vivado 环境下综合生成 bitstream 文件，因为没有安装 synplify，所以就没有使用官方推荐的 synplify 进行综合。</p>
<blockquote>
<p>系统：Windows 10 ， WSL Ubuntu 18.04<br>软件: vivado 2018.3</p>
</blockquote>
<a id="more"></a>

<h2 id="安装-vivado"><a href="#安装-vivado" class="headerlink" title="安装 vivado"></a>安装 vivado</h2><p>首先，你如果没有安装 vivado 就先安装一下 vivado，在命令行下自己运行 <code>./xsetup</code> 即可，安装完成后记得设置一下环境变量，具体的安装方法，我这里就不做详细介绍了，请自行搜索。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./xsetup</span><br></pre></td></tr></table></figure>

<h2 id="打开-vivado-新建工程"><a href="#打开-vivado-新建工程" class="headerlink" title="打开 vivado 新建工程"></a>打开 vivado 新建工程</h2><p>接下来，我们进入到 wujian100_open 的 fpga-&gt;vivado 目录下，在命令行下输入 <code>vivado</code> ，启动 vivado。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vivado</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2019/12/01/QeXyMn.md.png" alt="start_vivado.png"></p>
<p>vivado 启动完成之后，我们来创建应该新工程，点击 <code>Create project</code> ，Next-&gt;填写工程名称，Next-&gt; 选择 RTL Project，Next-&gt; 选择 wujian100 这个开发板对应的 FPGA 型号 <code>xc7a200tfbg484-1</code>，最后 Finish 即可，工程创建结束。</p>
<p><img src="https://s2.ax1x.com/2019/12/01/QejBTK.png" alt="QejBTK.png"><br><img src="https://s2.ax1x.com/2019/12/01/QexDRe.png" alt="QexDRe.png"><br><img src="https://s2.ax1x.com/2019/12/01/QexvJU.png" alt="QexvJU.png"></p>
<h2 id="添加源码综合"><a href="#添加源码综合" class="headerlink" title="添加源码综合"></a>添加源码综合</h2><p>工程创建完了之后我们添加 wujian100 的源码来进行综合。这里需要注意的是源码中有两个 top 文件，我们这里添加 wujian100_open_fpga_top.v 文件。然后添加 <code>soc</code>目录下的源码，都添加完成之后，vivado 会自动分析，这时我们会看到有错误，这是因为这四个文件是头文件，我们需要手动更改一下文件格式。</p>
<p><img src="https://s2.ax1x.com/2019/12/01/QmFW80.png" alt="QmFW80.png"></p>
<p>接下来我们继续添加约束文件，这里的管脚约束文件，我们就是所以官方提供的这个即可，时序约束文件这里使用一位群友提供的即可。把这个时序约束文件和官方的 xdc 放在一个目录下就可以了，添加完成之后，我们进行综合即可。但是在综合之前我们需要更改一下官方的 xdc，有一个地方在 vivado 下进行综合会报错，就是第 33 行这句， 把 <code>_c</code> 去掉即可。还有一个地方需要注意的是把 wujian100_open_fpga_top.v 的优先级调一下。</p>
<p>时序约束文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create_clock -name &#123;EHS&#125; [get_ports PIN_EHS] -period 50 -waveform &#123;0 25&#125;</span><br><span class="line">create_clock  -name &#123;JTAG_CLK&#125; [get_ports PAD_JTAG_TCLK] -period 1000 -waveform &#123;0 500&#125;</span><br><span class="line"></span><br><span class="line">set_clock_groups -asynchronous -name &#123;clkgroup_1&#125; -group [get_clocks &#123;EHS JTAG_CLK&#125;]</span><br><span class="line"></span><br><span class="line">set_false_path -through [get_ports PIN_EHS]</span><br><span class="line"></span><br><span class="line"><span class="comment">#set_clock_groups -name &#123;Inferred_clkgroup_0&#125; -asynchronous -group [get_clocks &#123;wujian100_open_top|PAD_JTAG_TCLK&#125;]</span></span><br><span class="line"></span><br><span class="line">set_property ASYNC_REG TRUE [get_cells &#123;x_aou_top/x_rtc0_sec_top/x_rtc_pdu_top/x_rtc_clr_sync/pclk_load_sync2_reg&#125;]</span><br><span class="line">set_property ASYNC_REG TRUE [get_cells &#123;x_aou_top/x_rtc0_sec_top/x_rtc_pdu_top/x_rtc_clr_sync/rtc_load_sync2_reg&#125;]</span><br><span class="line">set_property ASYNC_REG TRUE [get_cells &#123;x_aou_top/x_rtc0_sec_top/x_rtc_pdu_top/x_rtc_clr_sync/pclk_load_sync1_reg&#125;]</span><br><span class="line">set_property ASYNC_REG TRUE [get_cells &#123;x_aou_top/x_rtc0_sec_top/x_rtc_pdu_top/x_rtc_clr_sync/rtc_load_sync1_reg&#125;]</span><br><span class="line">set_property ASYNC_REG TRUE [get_cells &#123;x_cpu_top/CPU/x_cr_had_top/A15d/A74/A10b_reg&#125;]</span><br><span class="line">set_property ASYNC_REG TRUE [get_cells &#123;x_cpu_top/CPU/x_cr_had_top/A15d/A74/A18597_reg&#125;]</span><br><span class="line">set_property ASYNC_REG TRUE [get_cells &#123;x_cpu_top/CPU/x_cr_had_top/A15d/A1862d/A10b_reg&#125;]</span><br><span class="line">set_property ASYNC_REG TRUE [get_cells &#123;x_cpu_top/CPU/x_cr_had_top/A15d/A1862d/A18597_reg&#125;]</span><br><span class="line">set_property ASYNC_REG TRUE [get_cells &#123;x_cpu_top/CPU/x_cr_had_top/A15d/A75/A10b_reg&#125;]</span><br><span class="line">set_property ASYNC_REG TRUE [get_cells &#123;x_cpu_top/CPU/x_cr_had_top/A15d/A75/A18597_reg&#125;]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets PAD_JTAG_TCLK_c]</span></span><br><span class="line"><span class="comment"># 改成下面的</span></span><br><span class="line">set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets PAD_JTAG_TCLK]</span><br></pre></td></tr></table></figure>

<h2 id="综合完成生成-bit-文件"><a href="#综合完成生成-bit-文件" class="headerlink" title="综合完成生成 bit 文件"></a>综合完成生成 bit 文件</h2><p><img src="https://s2.ax1x.com/2019/12/01/QmM4H0.png" alt="QmM4H0.png"></p>
<p>综合完成之后呢，我们可以看到啊，这个时序约束都是符合要求的，接下来，我们就可以输出比特流文件上 FPGA 做实验了。</p>
<h2 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h2><h3 id="vivado-综合"><a href="#vivado-综合" class="headerlink" title="vivado 综合"></a>vivado 综合</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=77962964&cid=133377281&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>

<h3 id="上-FPGA-测试"><a href="#上-FPGA-测试" class="headerlink" title="上 FPGA 测试"></a>上 FPGA 测试</h3><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?aid=79137613&cid=135422810&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>
]]></content>
      <categories>
        <category>IC Design</category>
        <category>RISC-V</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>IC Design</tag>
        <tag>RISC-V</tag>
        <tag>平头哥</tag>
        <tag>wujian100</tag>
      </tags>
  </entry>
  <entry>
    <title>使用树莓派 3b 和 RTL_SDR 搭建小功率无线电监测点</title>
    <url>//posts/%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3b%E5%92%8CRTL-SDR%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%8A%9F%E7%8E%87%E6%97%A0%E7%BA%BF%E7%94%B5%E7%9B%91%E6%B5%8B%E7%82%B9.html</url>
    <content><![CDATA[<p>最近看了两部关于无线电相关的电影（『时空接触』、『黑洞频率』），对与无线电产生了很大的兴趣。现代由于互联网的发展，玩无线电的人越来越少了，了解无线电知识的人也不多了。但是还是有很多人在学习和使用软件定义无线电( Software Defined Radio – SDR )，软件无线电可以做很多神奇事情！！</p>
<a id="more"></a>
<h2 id="SDR-是个什么东西？"><a href="#SDR-是个什么东西？" class="headerlink" title="SDR 是个什么东西？"></a>SDR 是个什么东西？</h2><blockquote>
<p>“软件无线电”( Software Defined Radio – SDR )。实际上软件无线电技术的研究和开发已经有几十年的历史了，其中传统上以硬件实现的组件（例如混频器，滤波器，放大器，调制器\解调器，检测器等），通过个人计算机或嵌入式系统上的软件实现。最初源于美军的多制式电台项目，应用在军事领域。<br>在 21 世纪初，由于众多公司的努力，使得它已从军事领域转向民用领域，成为经济的、应用广泛的、全球第三代移动通信系统的战略基础。<br>到今天我们日常使用的移动通信系统中就在大量使用软件无线电技术， 比如基站中的信号处理大量的使用可编程的 FPGA 和 DSP 完成，比如手机当中的基带处理器也越来越多的采用软解调的方法(少数运算量特别大实时性要求特别高的模块除外，比如 turbo 解码器、扩频相关器等，这些模块往往在基带处理器中嵌入一些高度定制化”硬”核来实现)。</p>
</blockquote>
<p>所以我们想要监听周围的无线电信号，自然是需要一个硬件的。</p>
<h2 id="需要的硬件"><a href="#需要的硬件" class="headerlink" title="需要的硬件"></a>需要的硬件</h2><ul>
<li>RTL-SDR (或者 HackRF等)</li>
<li>Raspberry Pi 3 (或者 Linux 系统的电脑)</li>
<li>有网络</li>
<li>高频天线</li>
</ul>
<p>我选择的是一根支持 rtl-sdr 的电视棒，就是采用 RTL2832u (频率范围为 64-1700mh )解调芯片的。这是瑞晟( Realtek )的一个芯片型号，原本是做电视棒芯片的。后来被人发现这个芯片具有非常广的频率接收范围，然后就被用来做 sdr 应用了。十分廉价！</p>
<h2 id="安装-RTL-SDR-驱动程序"><a href="#安装-RTL-SDR-驱动程序" class="headerlink" title="安装 RTL_SDR 驱动程序"></a>安装 RTL_SDR 驱动程序</h2><p>硬件已经有了，接下来就是安装相关的软件驱动，才可以使用</p>
<p>打开一个 Terminal 窗口，进入到你的 home 目录下。先更新一下系统的软件，然后开始安装需要的软件依赖。具体操作如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install git</span><br><span class="line">$ sudo apt-get install cmake</span><br><span class="line">$ sudo apt-get install build-essential</span><br><span class="line">$ sudo apt-get install libusb-1.0-0-dev</span><br></pre></td></tr></table></figure>

<p>相关的依赖软件安装完成后，接下来下载 RTL2832u Osmocom 的驱动源代码，进行编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://git.osmocom.org/rtl-sdr.git</span><br><span class="line">$ <span class="built_in">cd</span> rtl-sdr</span><br><span class="line">$ mkdir -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ../ -DINSTALL_UDEV_RULES=ON</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br><span class="line">$ sudo ldconfig</span><br><span class="line">$ sudo cp ../rtl-sdr.rules /etc/udev/rules.d</span><br></pre></td></tr></table></figure>
<p>将使用电视棒作为电视设备自动加载的默认驱动程序列入黑名单，因为它不能让电视棒作为 SDR 使用，并且将会与我们刚刚安装的新 Osmocom 驱动程序发生冲突</p>
<ul>
<li><ol>
<li>以 administrator 权限打开 <code>/etc/modprobe.d</code> 文件夹</li>
</ol>
</li>
<li><ol start="2">
<li>在该目录下创建一个叫 <code>blacklist-rtl.conf</code> 的新文件，打开文件，在文件中加入 <code>blacklist dvb_usb_rtl28xxu</code> 这条指令</li>
</ol>
</li>
<li><ol start="3">
<li>保存文件，并重启</li>
</ol>
</li>
</ul>
<p>机器重启后，将电视棒插入 usb 接口，打开 Terminal 窗口，输入 <code>rtl_test -t</code> 命令，测试电视棒是否能够被正常驱动。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/rtl_test.png" alt=""><br>不用担心 PLL 未锁定或未找到 E4000 调谐器或 R820T 而不是 R820T2 等消息。如果你看到跟上图一样的内容，那么说明你的驱动程序安装成功了，并且电视棒成功运行。 接着你就可以安装一些应用程序，来收听无线电信号。</p>
<h2 id="安装-dump1090"><a href="#安装-dump1090" class="headerlink" title="安装 dump1090"></a>安装 dump1090</h2><p>电视棒的 rtl_sdr 驱动程序安装好了之后，我们在安装一个 dump1090 应用程序，这样我们就可以接收飞机的信号。<br>能很容易的捕获到飞机是飞机在飞行过程中要不断的报告自身的飞行状态(在 1090Mhz 频率进行广播)，这就是 ADS-B( 广播式自动相关监视系统) ，即一种航空交通监视系统，而且是使用全球性导航卫星系统、飞机xo的航电设备和地面基础设施， 能够在飞机和航管地面站 ( air-to-ground 即 aircraft to ATS ) 或是空对空 ( air-to-air 即 aircraft to aircraft )之间准确和迅速自动地传送飞行讯息； 其中包括有飞机的识别、位置、高度、速度和其他数据或信息。简单来说 ADS-B 是由飞机直接发出的数据包，让地面或其他飞机可以得知它的位置、高度、速度等信息。ADS-B 利用 112 个未加密的脉冲字在 978Mhz、1090Mhz 发射的信号。我们使用电视棒捕获这些信号，并通过 dump1090 将捕获到信号解析成飞机飞行的信息，生成地图。这样我们就能知道飞机的实时位置及其他信息。</p>
<p>打开一个新的 Terminal 窗口，安装 dump1090，并开启 dump1090 服务，然后我们就可以在 Terminal 窗口和浏览器中查看到飞行信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ git <span class="built_in">clone</span> git://github.com/tedsluis/dump1090.git</span><br><span class="line">$ <span class="built_in">cd</span> dump1090</span><br><span class="line">$ make    <span class="comment"># 编译源码</span></span><br><span class="line">$ ./dump1090 --interactive --net --<span class="built_in">enable</span>-agc		<span class="comment"># run dump1090</span></span><br></pre></td></tr></table></figure>
<p>收到的飞机的飞行信息如下图，dump 在启动时会开启自带的 WEB 服务器，并且 WEB 调用了谷歌地图的 API 接收到飞机的一些信息后会在页面地图上描绘出飞机的轨迹(谷歌地图目前需要科学上网)<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/dump1090.png" alt=""><br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/dump1090air.png" alt=""><br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/dump1090air2.png" alt=""><br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/air.jpg" alt=""></p>
<h2 id="安装-GQRX-收听各频率的广播"><a href="#安装-GQRX-收听各频率的广播" class="headerlink" title="安装 GQRX 收听各频率的广播"></a>安装 GQRX 收听各频率的广播</h2><p>我们可以收听广播或者火腿(无线电爱好者)的呼叫。但是这里我在树莓派上没有安装成功。因为 GUN Radio 安装不成功的问题。<br>不过我在 windows 上听到了广播。</p>
]]></content>
      <categories>
        <category>无线电</category>
      </categories>
      <tags>
        <tag>SDR</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 ARM Cortex-M3 的启动文件分析及分散加载</title>
    <url>//posts/%E5%85%B3%E4%BA%8E-ARM-Cortex-M3-%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD.html</url>
    <content><![CDATA[<h2 id="关于-ARM-Cortex-M3-的启动文件分析及分散加载"><a href="#关于-ARM-Cortex-M3-的启动文件分析及分散加载" class="headerlink" title="关于 ARM Cortex-M3 的启动文件分析及分散加载"></a>关于 ARM Cortex-M3 的启动文件分析及分散加载</h2><p>下面以 ARM Cortex-M3 裸核的启动代码为例，做一下简单的分析。首先，在启动文件中完成了三项工作：</p>
<ul>
<li>堆栈以及堆的初始化</li>
<li>定位中断向量表</li>
<li>调用 Reset Handler</li>
</ul>
<a id="more"></a>

<p>在介绍之前，我们先了解一下 ARM 芯片启动文件中涉及到的一些汇编指令的用法。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4.jpg" alt=""></p>
<p>补充一下，其中 DCD 相当于 C 语言当中的 &amp;，定义地址。</p>
<h2 id="堆栈以及堆的初始化"><a href="#堆栈以及堆的初始化" class="headerlink" title="堆栈以及堆的初始化"></a>堆栈以及堆的初始化</h2><h3 id="堆栈的初始化"><a href="#堆栈的初始化" class="headerlink" title="堆栈的初始化"></a>堆栈的初始化</h3><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%A0%86%E6%A0%88%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E7%A0%81.jpg" alt="Startup_xxx.s 中的堆栈初始化代码"></p>
<p><code>Stack_Size  EQU  0x00000400</code><br>这个语句相当于 Stack_Size 这个标号（标号：链接器的术语，下文中提到的所有“标号”，指的都是指的链接器中的标号）等于 0x00000400 相当于 C 语言中的 <code>#define  Stack_Size  0x00000400</code> ，也就是说此语句只是一个声明，并未分配地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA    STACK, NOINIT, READWRITE, ALIGN&#x3D;3</span><br></pre></td></tr></table></figure>
<p>此语句定义了一个叫 STACK 的代码段，并指明 8 字节对齐（ALIGN = 3）。其中 NOINIT 表示未初始化，READWRITE 表示可读可写，ALIGN = 3，即表示 2^3 = 8，八字节对齐。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stack_Mem    SPACE   Stack_Size</span><br></pre></td></tr></table></figure>
<p>这里是为 Stack_Mem 分配 Stack_Size 大小的一块内存区域，注意这里分配的是 RAM ，即分配了大小为 1KB 的内存空间（0x00000400 = 1024）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__initial_sp</span><br></pre></td></tr></table></figure>
<p>紧跟着栈分配内存后，所以其为栈顶（满递减栈）。此标号有一层隐含的意思就是在 M3 中堆栈是满递减堆栈，因为它指定了堆栈指针位于堆栈的高地址（在 Stack_Mem 之后），具体如下图所示。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88.jpg" alt="堆栈指针 sp 位置"></p>
<p>上图来自 Cortex_M3 的一个工程的 xxx.map 文件。可以看出栈的起始地址为 0x20000c68，大小为 1024 字节（即 0x00000400 = Stack_Size）。而堆栈指针的位置在 0x20001068，其等于栈的起始地址 0x2000c68 + 0x00000400，说明本系列的 Cortex_M3 微控制器的堆栈为满递减堆栈。<br>所以 __initial_sp 为 1KB 空间栈的栈顶，栈主要用于局部变量和形参的调用过程的临时存储，属于编译器自动分配和释放的内存，所以这里需要注意如果你的函数所占的内存过大，那么这个空间应调整其大小但一定要小于内部 SRAM 的大小。堆是程序员空间是程序员进行分配和释放的，如果程序中未释放最后由系统回收。</p>
<h3 id="堆的初始化"><a href="#堆的初始化" class="headerlink" title="堆的初始化"></a>堆的初始化</h3><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E5%A0%86%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="Startup_xxx.s 中的堆初始化代码"></p>
<p>堆的初始化过程与堆栈的初始化相同。</p>
<h2 id="中断向量表的初始化"><a href="#中断向量表的初始化" class="headerlink" title="中断向量表的初始化"></a>中断向量表的初始化</h2><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8.jpg" alt="中断向量表的初始化代码（部分）"></p>
<p><code>PRESERVE8</code> 指定了以下的代码为 8 字节对齐，这是 keil 编译器的一个编程要求，对齐情况如下图所示：</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/8%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.jpg" alt="xxx.list文件中的8字节对齐示意图"></p>
<p><code>THUMB</code> 指定了接下来的代码为 THUMB 指令集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AREA    RESET, DATA, READONLY</span><br></pre></td></tr></table></figure>
<p>此语句声明 RESET 数据段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPORT  __Vectors</span><br></pre></td></tr></table></figure>
<p>导出向量表标号，EXPORT 作用类似于 C 语言中的 extern。之后的代码就是为向量表分配存储区域。中断向量表从 FLASH 的 0x00000000 地址开始放置，以 4 个字节为一个单位，地址 0 存放的是栈顶指针（ sp ）的地址，0x00000004 存放的是复位程序的地址，往后以此类推，这里我们只设置了一个 Reset_Handler 向量。从代码上看，向量表中存放的都是中断服务函数的函数名，可我们知道 C 语言中的函数名就是一个地址。（由此我们知道，中断函数的函数名都已经知道了，我们在写对应的中断服务程序时，从对应的地址取服务例程的入口地址并跳入执行）。但是此处有一个要注意的，就是 0 号地址不是什么入口地址，而是给出的复位后的 MSP 的初值。</p>
<h2 id="调用-Reset-Handler"><a href="#调用-Reset-Handler" class="headerlink" title="调用 Reset Handler"></a>调用 Reset Handler</h2><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/reset_handler.jpg" alt="调用 Reset Handler 的代码"></p>
<p>此段代码只完成了一个功能，引导程序进入 __main 。 __main 的具体行为在后面做具体描述。<br><code>PROC</code> 与 <code>ENDP</code> 两个关键字组合在汇编中定义了一段子函数。<br>用户堆栈的初始化</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E5%A0%86%E6%A0%88%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81.jpg" alt="具体的堆栈以及堆的初始化行为"></p>
<p>这一部分也就是把初始化的堆栈地址赋值给单片机的对应寄存器以方便 C 程序进行分配释放使用。</p>
<h2 id="其他代码"><a href="#其他代码" class="headerlink" title="其他代码"></a>其他代码</h2><p>有一些芯片厂商对芯片的加密的加密级别的代码也会放在这里，芯片上电后会自动读取这一地址的值以确定芯片的加密方式。</p>
<h2 id="ARM-芯片的启动过程详解"><a href="#ARM-芯片的启动过程详解" class="headerlink" title="ARM 芯片的启动过程详解"></a>ARM 芯片的启动过程详解</h2><p>接下来介绍 __main 函数的具体实现过程。<br>首先在介绍 __main 函数之前，我们先了解一些关于 ARM 芯片在启动过程中的基本知识。<br>“ ARM 程序”是指在 ARM 系统中正在执行的程序，而非保存在 ROM 中的 .bin(.axf,.hex)映像（ image ）文件。<br>一个 ARM 程序包含 3 部分：RO ，RW 和 ZI</p>
<ul>
<li>RO 就是只读数据，是程序中指令和常量；</li>
<li>RW 是可读写的数据，程序中已初始化变量；</li>
<li>ZI 是程序中未初始化的变量和初始化为 0 的变量。<br>简单理解就是：<br>  RO 就是 readonly ，RW 就是 read/write，ZI 就是 zero initial。</li>
</ul>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/arm%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg" alt="ARM 芯片的启动过程详解"></p>
<p>注意，以上的过程并非绝对的，不同的 ARM 架构或者是不同的代码以上的执行过程是不同的。<br>复位处理程序是在汇编器中编写的短模块，系统一启动就立即执行。复位处理程序最少要为应用程序的运行模式初始化堆栈指针。对于具有本地内存系统（如缓存、TCM 、MMU 和 MPU）的处理器，某些配置必须在初始化过程的这一阶段完成。复位处理程序在执行之后，通常跳到 <strong>main 以开始 C 库初始化序列。<br>__main 中的 __scatterload 负责设置内存，而 __rt_entry 负责设置运行时的环境。</strong>scatterload 中负责把 RO/RW （非零）输出段从装载域地址复制到运行域地址（执行代码和数据复制、解压缩），并完成 ZI 段运行域数据的 0 初始化工作。然后跳到 <strong>rt_entry 设置堆栈和堆、初始化库函数和静态数据。然后，</strong>rt_entry 跳转到应用程序的入口 main() 。主应用程序结束执行后，__rt_entry 将库关闭，然后把控制权交换给调试器。函数标签 main() 具有特殊含义。Main() 函数的存在强制链接器链接到 __main 和 __rt_entry 中的代码。如果没有标记为 main() 的函数，则没有链接到初始化序列，因而部分标准 C 库功能得不到支持。</p>
<h2 id="结合代码来看芯片启动过程"><a href="#结合代码来看芯片启动过程" class="headerlink" title="结合代码来看芯片启动过程"></a>结合代码来看芯片启动过程</h2><p>上电后硬件设置 sp 、pc ，刚上电复位后，硬件会自动根据向量表地址找到向量表。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sp_pc.jpg" alt=""></p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sp_pc1.jpg" alt=""></p>
<p>在离开复位状态后， CM3 做的第一件事就是读取下列两个 32 位整数的值：</p>
<ul>
<li>1.从地址 0x0000 0000 处取出 MSP 的初始值。</li>
<li>2.从地址 0x0000 0004 处取出 PC 的初始值，这个值是复位向量， LSB 必须是 1 。 然后从这个值所对应的地址处取指。<br>硬件自动从 0x0000 0000 位置处读取数据赋给栈指针 sp，然后从 0x0000 0004 位置处读取数据赋给 pc 指针，完成复位，结果为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SP &#x3D; 0x2000 1068 </span><br><span class="line">PC &#x3D; 0x0000 011D</span><br></pre></td></tr></table></figure>
<img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/reset%E5%90%AF%E5%8A%A8.jpg" alt=""></li>
</ul>
<p>这与传统的 ARM 架构不同——其实也和绝大多数的其它单片机不同。传统的 ARM 架构总是从 0 地址开始执行第一条指令。它们的 0 地址处总是一条跳转指令。在 CM3 中，在 0 地址处提供 MSP 的初始值，然后紧跟着就是向量表。向量表中的数值是 32 位的地址，而不是跳转指令。向量表的第一个条目指向复位后应执行的第一条指令，就是我们上面分析的 Reset_Handler 这个函数。</p>
<p>进入__main</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LDR   R0, =__main</span><br><span class="line">BX　　R0</span><br></pre></td></tr></table></figure>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/__main%E4%BB%A3%E7%A0%81.jpg" alt=""></p>
<p>执行上两条指令，跳转到 <strong>main 程序段运行，</strong>main 的地址是 0x0000 0080 ，上一步指令 pc = 0x0000 011D 的地址没有对齐，硬件自动对齐到 0x0000 011C，执行 __main。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/0x0000012c.jpg" alt=""></p>
<p>pc 指针通过立即数寻址，跳转到 0x0000 0081 处执行，同上这里也会自动对齐到 0x0000 0080 处。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/0x00000088.jpg" alt=""></p>
<p>在 __scatterload 函数中又会进入 __scatterload_copy ，在 __scatterload_copy 中进行代码搬运，主要是加载已经初始化的数据段和未初始化的数据段，同时还会初始化栈空间，即 ZI 段清零（其中搬运次数由代码中声明的变量类型和变量多少来决定）。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/ZI%E6%AE%B5%E6%B8%85%E9%9B%B6.jpg" alt=""></p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/__rt_entry.jpg" alt=""></p>
<p>然后会跳转到 <strong>rt_entry 函数执行，</strong>rt_entry 是使用 ARM C 库的程序的起点。将所有分散加载区重新定位到其执行地址后，会将控制权传递给 __rt_entry 。如下图，在 __rt_entry 中主要实现如下几个功能：</p>
<ul>
<li>1.设置用户的堆和堆栈</li>
<li>2.调用 __rt_lib_init 以初始化 C 库</li>
<li>3.调用 main()</li>
<li>4.调用 __rt_lib_shutdown 以关闭 C 库</li>
<li>5.退出</li>
</ul>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/C_library.jpg" alt=""></p>
<p>__rt_lib_init 函数是库函数初始化函数，它与 __rt_lib_shutdown 配合使用。并且这个函数紧靠 __rt_stackheap_init() 后面调用，即紧跟堆和堆栈初始化后面调用，并且传递一个要用作堆的初始内存块。此函数是标准ARM库初始化函数，不能重新实现此函数。</p>
<p><strong>注意：最后两步是在程序退出 main() 函数的时候才会执行，而我们嵌入式程序一般都是死循环，所以基本上不会执行这两个过程。还有以上过程是针对使用标准 C Library 而言的，不包括使用 MDK 提供的 microlib 库的情况。</strong></p>
<p>在 __rt_entry_main 中，用户程序就开始正式执行了（进入 C 的世界）。在此之前初始化 MSP 是必需的，因为可能第 1 条指令还没来得及执行，就发生了 NMI 或是其它 fault。 MSP 初始化好后就已经为它们的服务例程准备好了堆栈。这也就是 __main 中做的事情。</p>
<h2 id="最后关于-microlib-库"><a href="#最后关于-microlib-库" class="headerlink" title="最后关于 microlib 库"></a>最后关于 microlib 库</h2><p>Microlib 是缺省 C 库的备选库。它旨在与需要装入到极少量内存中的深层嵌入式应用程序配合使用。这些应用程序不在操作系统中运行，因此 microlib 进行了高度优化以使代码变得很小，当然它的功能相比缺省 C 库少，并且根本不具备某些 ISO C 特性。某些库函数的运行速度也比较慢，比如 memcpy()。 </p>
<p>Microlib与缺省C库之间的主要差异是：</p>
<blockquote>
<p>Microlib 不符合 ISO C 库标准。不支持，某些 ISO 特性，并且其他特性具有的功能也比较少；<br>Microlib 不符合 IEEE754 二进制浮点算法标准；<br>Microlib 进行了高度优化以使代码变得很小；<br>无法对区域设置进行配置。缺省 C 区域设置是唯一可用的区域设置；<br>不能将 main() 声明为使用参数，并且不能返回内容；<br>不支持 stdio ，但未缓冲的 stdin、stdout 和 stderr 除外；<br>Microlib 对 C99 函数提供有限的支持；<br>Microlib 不支持操作系统函数；<br>Microlib 不支持与位置无关的代码；<br>Microlib 不提供互斥锁来防止非线程安全的代码；<br>Microlib 不支持宽字符或多字节字符串；<br>与stdlib 不同， microlib 不支持可选的单或双区内存模型。 Microlib 只提供双区内存模型，即单独的堆栈和堆区。</p>
</blockquote>
<h2 id="关于生成的-xxx-map-文件"><a href="#关于生成的-xxx-map-文件" class="headerlink" title="关于生成的 xxx.map 文件"></a>关于生成的 xxx.map 文件</h2><p>想要更好的了解启动代码的运行机制，我们就有必要了解一下由 Keil 的链接器“ armlink ”生成的描述文件，即 xxx.map 文件。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/map%E6%96%87%E4%BB%B6.jpg" alt="目标文件的组成"></p>
<p>上图即是 armlink 的链接器为测试代码生成的 xxx.map 文件中的一部分，其描述了镜像文件的组成信息，其中可以明显看到其由两部分构成：</p>
<ul>
<li>User Code 生成的目标文件</li>
<li>C Library 生成的目标文件</li>
</ul>
<p>可见我们在上文中所描述的启动过程中看到的 __main 、 __rt_entry 、 __scartterload 以及 __rt_lib_init 等，就是 C library 中的代码。<br>所以，我们每次烧录的可执行的 ARM 的 bin 文件中不仅有开发者编写的代码，还有 C Library 的代码。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/map%E4%B8%ADRW%E6%AE%B5.jpg" alt=""><br>上图为存放在RAM中的RW段。</p>
<h2 id="关于分散加载"><a href="#关于分散加载" class="headerlink" title="关于分散加载"></a>关于分散加载</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>由于 ARM Cortex-M3 系列是哈佛架构，哈佛架构是一种将程序指令存储和数据存储分开的存储器结构，所以它在运行时，指令存储在片内的 flash 上，数据存储在片内 SRAM 中。因此程序是可以直接在 flash 上运行的，而不是先将 flash 上的程序全部搬运到 RAM 在运行。<br>由此，我们也可以深入了解一下 ARM 映像（镜像）文件。 ARM 映像文件其实就是源文件经编译器生成的目标文件 .obj（object file）和相应的 C/C++ 运行时库（ Runtime Library ）经过连接器的处理后，生成的 axf 格式的映像文件，它可以直接烧录到目标设备的 ROM 中直接运行或加载后运行。</p>
<h3 id="映像文件的类型"><a href="#映像文件的类型" class="headerlink" title="映像文件的类型"></a>映像文件的类型</h3><p>常见的映像文件还包括 bin 、 hex 和 elf 文件，在 keil 调试过程中，调试器生成 axf 文件也是一种映像文件。<br>Bin 文件是纯粹的二进制机器代码，或者说是“顺序格式”。按照汇编代码顺序翻译成的二进制机器码，内部没有地址标记。 Bin 文件是直接的内存映像表示，二进制文件大小即为文件所包含的数据的实际大小。<br>Hex 文件是 Intel 标准的十六进制文件，通常用来保存单片机或其他处理器的目标程序代码。它保存物理程序存储区中的目标代码映像。一般的编程器都支持这种格式。就是机器代码的十六进制形式，并且是用一定文件格式的 ASCII 码来表示。在 Hex 文件里面，每一行代表一个记录。每条记录都由一个冒号“：”打头，其格式如下：<br>** :BBAAAATTHHHH…HHHHCC **</p>
<blockquote>
<p>BB:字节个数。<br>AAAA:数据记录的开始地址,高位在前,低位在后。<br>TT: Type<br>00 数据记录，用来记录数据。<br>01 记录结束，放在文件末尾，用来标识文件结束。<br>02 用来标识扩展段地址的记录<br>04 扩展地址记录(表示 32 位地址的前缀)<br>HHHH:一个字( Word )的数据记录,高字节在前,低字节在后。TT 之后共有 BB/2 个字的数据 。<br>CC: 占据一个 Byte 的 CheckSum </p>
</blockquote>
<p>ELF（ Executableand linking format ）文件是 x86 Linux 系统下的一种常用目标文件( objectfile )格式，有三种主要类型:</p>
<blockquote>
<p>(1)适于连接的可重定位文件( relocatablefile )，可与其它目标文件一起创建可执行文件和共享目标文件。<br>(2)适于执行的可执行文件( executable file )，用于提供程序的进程映像，加载到内存执行。<br>(3)共享目标文件( shared object file )，连接器可将它与其它可重定位文件和共享目标文件连接成其它的目标文件，动态连接器又可将它与可执行文件和其它共享目标文件结合起来创建一个进程映像。<br>Axf 文件由 ARM 编译器产生，除了包含 bin 的内容之外，还附加其他调试信息，这些调试信息加在可执行的二进制数据之前。调试时这些调试信息不会下载到 RAM 中，真正下载到 RAM 中的信息仅仅是可执行代码。因此，如果 ram 的大小小于 axf 文件的大小，程序是完全有可能在 ram 中调试的，只要 axf 除去调试信息后文件大小小于 ram 的大小即可。</p>
</blockquote>
<p>** 总结：**</p>
<ul>
<li>（1） axf 和 elf 都是编译器生成的可执行文件。区别是：ADS 编译出来的是 AXF 文件。gcc 编译出来的是 ELF 文件。两者虽然很像，但还是有差别的。这是文件格式的差别，不涉及调试格式。</li>
<li>（2）axf/elf 是带格式的映象，bin 是直接的内存映象的表示。</li>
<li>（3）Linux OS 下，ELF 通常就是可执行文件，通常 <code>gcc -o test test.c</code>，生成的 test 文件就是 ELF 格式的，在 Linux Shell 下输入 <code>./test</code> 就可以执行。在 Embedded 中，上电开始运行，没有 OS 系统，如果将 ELF 格式的文件烧写进去，包含一些 ELF 格式的东西，arm 运行碰到这些指令，就会导致失败，如果用 bin 文件，程序就可以一步一步运行。<br>所以最终放进 flash 的是 bin 文件。 elf 文件可转化为 hex 和 bin 两种文件， hex 也可以直接转换为 bin 文件，但是 bin 要转化为 hex 文件必须要给定一个基地址。而 hex 和 bin 不能转化为 elf 文件，因为 elf 的信息量要大。 Axf 文件可以转化为 bin 文件，KEIL 下可用以下命令 <code>fromelf -nodebug xx.axf -bin xx.bin</code> 即可。</li>
</ul>
<h3 id="映像文件的组成"><a href="#映像文件的组成" class="headerlink" title="映像文件的组成"></a>映像文件的组成</h3><p>镜像文件组成如下图所示：</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6.jpg" alt="镜像文件的组成"></p>
<p>可执行文件由映像、区（域）、输出节（段）和输入节（段）的层次结构构成：</p>
<blockquote>
<p>映像由一个或多个区组成。每个区由一个或多个输出节组成。<br>每个输出节包含一个或多个输入节。<br>输入节是对象文件中的代码和数据信息。<br>输入节：输入节包含代码、初始化数据，或描述未初始化的或在映像执行之前必须设定为 0 的内存片段。这些特性通过 RO 、 RW 和 ZI 这样的属性来表示。<br>输出节：一个输出节由若干个具有相同 RO 、 RW 或 ZI 属性的相邻输入节组成。输出节的属性与组成它的输入节的属性相同 。<br>区：一个区由一个、两个或者三个相邻的输出节组成。区中的输出节根据其属性排序。首先是 RO 输出节，然后是 RW 输出节，最后是 ZI 输出节。区通常映射到物理内存设备，如 ROM 、 RAM 或外围设备。</p>
</blockquote>
<p>有时候用户希望将不同代码放在不同存储空间，也就是通过编译器生成的映像文件需要包含多个域，每个域在加载和运行时可以有不同的地址。要生成这样的映像文件，必须通过某种方式告知编译器相关的地址映射关系。在 Keil/ADS/IAR 等编译工具中，可通过分散加载机制实现。分散加载通过配置文件实现，这样的文件就称为分散加载文件。<br>分散加载( scatter loading )为 *.scf 文件。它提供这样一种机制：可以将内存变量定位于不同的物理地址上的存储器或端口，通过访问内存变量即可达到访问外部存储器或外设的目的；同时通过分散加载，让大多数程序代码在高速的内部 RAM 中运行，从而使得系统的实时性大大增强。这样，定位在 RAM 存储器的代码和数据就在 RAM 存储器中运行，而不再从 ROM 存储器中取数据或取指令，从而大大提高了 CPU 的运行速率和效率。<br>编译过程<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg" alt="编译过程"><br>加载过程<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E7%AE%80%E5%8D%95%E5%8A%A0%E8%BD%BD.jpg" alt="简单的加载过程"></p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E8%BE%93%E5%87%BA%E7%9A%84map%E5%A4%A7%E5%B0%8F.jpg" alt="输出的map文件"></p>
<p>ROM（Flash）size = Code + RO_Data + RW_Data = 0.5kb；<br>RAM size = RW_Data + ZI_Data = 4.1kb。</p>
<p>加载时域的描述<br>sct 文件<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sct%E6%96%87%E4%BB%B6.jpg" alt=".sct文件"></p>
<p>LR_IROM1 加载区域名，用于“ Linker ”区别不同的加载区域，最多 31 个字符；用来保存永久性数据（程序和只读变量）的区域；<br>ER_IROM1 执行区域名；程序执行时，从加载区域将数据复制到相应执行区后才能被正确执行；</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LR_IROM1 0x00000000  0x00040000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x00000000  0x00010000  &#123;  ; load address &#x3D; execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x20010000  0x00010000  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LR_IROM1 0x00000000 0x00040000<br>定义一个加载时域，域基址：0x00000000，域大小为 0x00040000，对应实际 Flash 的大小<br>ER_IROM1 0x00000000 0x00010000<br>定义一个运行时域，第一个运行时域必须和加载时域起始地址相同，否则库不能加载到该时域的错误，其域大小一般也和加载时域大小相同，但是我们这里没有 flash ，只有 128k 的 RAM ，这里分配 64k 作为程序存储器，所以这里是 0x00010000 大小。</p>
<p>*.o (RESET, +First)<br>将 RESET 段最先加载到本域的起始地址外，即 RESET 的起始地址为 0，RESET 存储的是向量表</p>
<p>.ANY (+RO)<br>加载所有匹配目标文件的只读属性数据，包含：RW-Code、RO-Data。</p>
<p>RW_IRAM1 0x20010000 0x00010000<br>定义一个运行时域，域基址：0x20010000，域大小为 0x00010000 ，对应实际 RAM 大小，这时就不能从 0x20000000 开始了，因为实际 RAM 中前 64K 已经用于程序存储了，所以运行段向后偏移 0x00010000 大小，起始地址从 0x20010000 开始。之前就是因为这里的内存分配不对，地址从 0x20000000 开始，结果程序在搬运初始化过程中，把自己清零了，导致代码在进入 mian() 函数以后就跑飞了。</p>
<ul>
<li>(+RW +ZI)<br>加载所有区配目标文件的 RW-Data、ZI-Data 这里也可以用 .ANY 替代 * 号 </li>
</ul>
<p>下图为 STM32 的 sct 文件：</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/stm32sct.jpg" alt=""></p>
<p>下面为 OnSemiconductor RSL10 芯片的 sct 文件，编译环境为 eclipse 加 armlink。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SECTIONS 0x00100000</span><br><span class="line">&#123;</span><br><span class="line">    ; For Cortex-M devices, the beginning of the startup code is stored in</span><br><span class="line">    ; the .interrupt_vector section, which goes to FLASH. All other code</span><br><span class="line">	; follows this section.</span><br><span class="line">;对于 Cortex-M 设备，启动代码的开头存储在 .interrupt_vector 部分，该部分转到 FLASH 。 所有其他代码都在本节后面。</span><br><span class="line">    FLASH 0x00100000 0x60000 </span><br><span class="line">&#123;</span><br><span class="line">; Flash 起始地址为 0x00100000 大小为 0x60000  384k</span><br><span class="line"></span><br><span class="line">        * (RESET +FIRST)</span><br><span class="line">        </span><br><span class="line">        ; Remaining program code</span><br><span class="line">; 只读代码部分</span><br><span class="line">        * (+RO)</span><br><span class="line">      </span><br><span class="line">        ; All remaining DSP code </span><br><span class="line">; DSP 代码</span><br><span class="line">        * (.dsp, .dsp.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">; Define the data sections</span><br><span class="line">; 定义运行域</span><br><span class="line">    DRAM 0x20000000 (0x6000 - 2048) </span><br><span class="line">&#123;</span><br><span class="line">; DRAM 起始地址 0x20000000 大小 0x6000  大约 24k</span><br><span class="line">        ; Place the system clock variable first</span><br><span class="line">; 首先放置系统时钟变量</span><br><span class="line">        * (.systemclock +FIRST)</span><br><span class="line"></span><br><span class="line">        ; Place the defined data sections</span><br><span class="line">; 放置已定义的数据部分</span><br><span class="line">        * (.data_begin, .data_begin.*)</span><br><span class="line">        * (.data, .data.*)</span><br><span class="line">        * (.data_end, .data_end.*)</span><br><span class="line">    </span><br><span class="line">        ; Place all remaining read-write and zero-initialized data </span><br><span class="line">; 放置所有剩余的读写和零初始化数据</span><br><span class="line">        * (+RW)</span><br><span class="line">        * (+ZI)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">; Define a heap region</span><br><span class="line">; 定义堆区域 起始地址 0x20005800 大小 0x400  1k</span><br><span class="line">    ARM_LIB_HEAP 0x20005800 EMPTY 0x400</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">; Define a stack region</span><br><span class="line">; 定义栈区域 起始地址 0x20005C00  大小 0x400 1k</span><br><span class="line">    ARM_LIB_STACK 0x20005C00 EMPTY 0x400</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>CM3</tag>
        <tag>启动文件</tag>
        <tag>分散加载</tag>
      </tags>
  </entry>
  <entry>
    <title>关于</title>
    <url>//posts/%E5%85%B3%E4%BA%8E.html</url>
    <content><![CDATA[<p>欢迎您访问我的网站，希望我分享的东西会对您有一些帮助！<br>祝您 Coding 愉快！</p>
<a id="more"></a>

<p>关于我，你什么也不需要知道，哈哈哈~~</p>
<p>关于本站，我有时间就写点东西喽，嘿嘿~~，开心就好！</p>
<p>关于分享什么，聊一点技术、谈一点理想、做一点实事不枉来世一遭！</p>
<p>达则兼济天下，穷则独善其身~~</p>
<p>做一个快乐的程序员！</p>
]]></content>
      <categories>
        <category>About</category>
      </categories>
      <tags>
        <tag>About</tag>
      </tags>
  </entry>
  <entry>
    <title>使用汇编实现 pc 和 sp 的保存及恢复操作</title>
    <url>//posts/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0-pc-%E5%92%8C-sp-%E7%9A%84%E4%BF%9D%E5%AD%98%E5%8F%8A%E6%81%A2%E5%A4%8D%E6%93%8D%E4%BD%9C.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 ARM Cortex 系列的芯片中本来就有一套保护现场的机制，例如当产生了一个中断时，会自动将当前寄存器的值入栈，并在 lr（r14） 寄存器中保存将要返回的 pc 值，在中断服务程序执行完成后将 pc 恢复到之前的位置。如果在执行中断服务程序的时候又发生了优先级更高的中断，也就是说发生了中断嵌套，这是将再次进行现场保护，同时 lr 值会被压栈（上一次的 pc ），新的 lr 生成。</p>
<p>但是在一些场景下，这样的机制就不太好用了，比如说要进入 sleep 模式 cpu 掉电了，想要恢复到掉电前的状态。这样的话就需要我们自己实现保护现场了，下面就来简单介绍一下我的实现。</p>
<a id="more"></a>

<h2 id="硬件及-IDE-环境"><a href="#硬件及-IDE-环境" class="headerlink" title="硬件及 IDE 环境"></a>硬件及 IDE 环境</h2><ul>
<li>硬件: Cortex-M3 FPGA 开发板</li>
<li>IDE: IAR 8.22.1</li>
</ul>
<p>在进行 FPGA 验证之前，还跑了 RTL 的仿真，从仿真波形的结果来看也是正确的。</p>
<h2 id="c-文件"><a href="#c-文件" class="headerlink" title="c 文件"></a>c 文件</h2><p>现场保护主要就是保存当前的运行状态，在从 sleep 模式唤醒后将保存的状态恢复，使 cpu 回到到 sleep 之前的状态。在我们这里最主要的是保存 pc 和 sp 的值，cpu 唤醒之后恢复 pc 和 sp 就好，所以我们需要将进入 sleep 之前的 pc 和 sp 保存即可。</p>
<p>在进入 sleep 模式中，虽然 cpu 掉电了，但是 SRAM 还是维持着的，所以我们可以使用一个全局变量（存储在 SRAM 中）来保存 pc 和 sp 的值。</p>
<p>“xxx.c” 文件中部分代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数及变量的声明和引用</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Save_PC_SP</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">Restore_PC_SP</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> u32 pc_save</span>;</span><br><span class="line"><span class="keyword">extern</span> u32 sp_save;</span><br><span class="line"></span><br><span class="line"><span class="comment">//······</span></span><br><span class="line"><span class="comment">// 在执行 sleep 指令（WFI/WFE）之前保存 pc、sp</span></span><br><span class="line">Save_PC_SP();    <span class="comment">// 保存 pc 和 sp</span></span><br><span class="line">__WFI();         <span class="comment">// 睡眠</span></span><br><span class="line">__NOP();</span><br><span class="line">__NOP();</span><br><span class="line">__NOP();</span><br><span class="line"></span><br><span class="line"><span class="comment">//······</span></span><br></pre></td></tr></table></figure>

<h2 id="s-汇编文件"><a href="#s-汇编文件" class="headerlink" title="s 汇编文件"></a>s 汇编文件</h2><p>“xxx.s”文件中的部分代码：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;函数及变量的声明和引用</span></span><br><span class="line"><span class="symbol">PUBLIC</span>  Save_PC_SP</span><br><span class="line"><span class="symbol">PUBLIC</span>  Restore_PC_SP</span><br><span class="line"></span><br><span class="line"><span class="symbol">IMPORT</span>  pc_save</span><br><span class="line"><span class="symbol">IMPORT</span>  sp_save</span><br><span class="line"></span><br><span class="line"><span class="comment">;唤醒后判断的代码</span></span><br><span class="line">    <span class="meta">THUMB</span></span><br><span class="line"></span><br><span class="line">    PUBWEAK Reset_Handler</span><br><span class="line">    SECTION <span class="meta">.text</span>:<span class="meta">CODE</span>:REORDER:NOROOT(<span class="number">2</span>)</span><br><span class="line"><span class="symbol">Reset_Handler</span></span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R0</span>, <span class="number">=0x4001f000</span></span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R1</span>, [<span class="built_in">R0</span>]</span><br><span class="line">    <span class="keyword">CMP </span><span class="built_in">R1</span>, <span class="number">#1</span></span><br><span class="line">    <span class="keyword">BEQ </span>__iar_program_start</span><br><span class="line">    <span class="keyword">B </span>  Restore_PC_SP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;Save pc sp 的代码</span></span><br><span class="line"></span><br><span class="line">    SECTION <span class="meta">.text</span>:<span class="meta">CODE</span>:NOROOT</span><br><span class="line"><span class="symbol">Save_PC_SP</span></span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R0</span>, <span class="number">=0x4001f000</span></span><br><span class="line">    <span class="keyword">MOV </span><span class="built_in">R1</span>, <span class="number">#1</span></span><br><span class="line">    <span class="keyword">STR </span><span class="built_in">R1</span>, [<span class="built_in">R0</span>]</span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R0</span>, <span class="symbol">=sp_save</span></span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R2</span>, <span class="symbol">=pc_save</span></span><br><span class="line">    <span class="keyword">MOV </span><span class="built_in">R1</span>, <span class="built_in">R13</span></span><br><span class="line">    <span class="keyword">STR </span><span class="built_in">R1</span>, [<span class="built_in">R0</span>]</span><br><span class="line">    <span class="keyword">MOV </span><span class="built_in">R1</span>, <span class="built_in">LR</span></span><br><span class="line">    <span class="keyword">STR </span><span class="built_in">R1</span>, [<span class="built_in">R2</span>]</span><br><span class="line">    <span class="keyword">BX </span> <span class="built_in">LR</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;Restore pc sp 的代码</span></span><br><span class="line">    </span><br><span class="line">    SECTION <span class="meta">.text</span>:<span class="meta">CODE</span>:NOROOT</span><br><span class="line"><span class="symbol">Restore_PC_SP</span></span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R0</span>,  <span class="symbol">=sp_save</span></span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R1</span>,  [<span class="built_in">R0</span>]</span><br><span class="line">    <span class="keyword">MOV </span><span class="built_in">R13</span>, <span class="built_in">R1</span></span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R0</span>,  <span class="symbol">=pc_save</span></span><br><span class="line">    <span class="keyword">LDR </span><span class="built_in">R1</span>,  [<span class="built_in">R0</span>]</span><br><span class="line">    <span class="keyword">ADD </span><span class="built_in">R1</span>,  <span class="built_in">R1</span>, <span class="number">#0x8</span></span><br><span class="line">    <span class="keyword">MOV </span><span class="built_in">PC</span>,  <span class="built_in">R1</span></span><br><span class="line">    <span class="keyword">NOP</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">NOP</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">NOP</span></span><br></pre></td></tr></table></figure>

<p>在汇编文件中主要实现的是 save 和 restore 的操作，以及恢复过程的判断。因为我们的设计是从睡眠唤醒是从 Reset 起来的，这就导致第一次 cpu 的正常启动会和 restore 发生冲突，所以我这里选择了一个不会掉电的寄存器来作为是否进行 restore 的判断。</p>
<p>还有就是加 NOP 指令是因为 Cortex-M3 是三级流水线，为了防止 cpu 因为 pc 的预取而发生错误。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>CM3</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 RISC-V 架构下 RTOS 的一些知识</title>
    <url>//posts/%E5%85%B3%E4%BA%8E-RISC-V-%E6%9E%B6%E6%9E%84%E4%B8%8B-RTOS-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p>之前的 blog 有介绍了一些，wujian100 的一些知识，包括综合、测试等。最近就想在 wujian100 上看看能不能移植一下比较常见的一些 <strong><code>RTOS</code></strong> (<strong>Real Time Operating System,实时操作系统</strong>)上去试试，比如 Free RTOS、RT-Thread等。结果发现这里还是有一些坑的。虽然 FreeRTOS 和 RTT 都支持 RISC-V 的芯片了，但是 wujian100 这个是 RISC-V “E” 基础架构，也就是 <strong><code>RV32E</code></strong> 就是 <strong><code>标准嵌入式扩展</code></strong> 指令集（这个版本降低了核心的开销，CPU 寄存器裁剪了一半，为 16 个）。但是 FreeRTOS 和 RTT 目前支持的版本都是 32 个寄存器的，对于任务或者说线程的上下文切换时对栈帧的操作还是有一些差异。然后呢也想对比一下 ARM 架构和 RISC-V 架构下嵌入式实时操作系统处理的一些区别，这里呢就想做一些的简单记录。</p>
<a id="more"></a>

<h2 id="ARM-和-RISC-V-架构的区别"><a href="#ARM-和-RISC-V-架构的区别" class="headerlink" title="ARM 和 RISC-V 架构的区别"></a>ARM 和 RISC-V 架构的区别</h2><p>由于我是先学的 ARM 也相对了解一些，所以做什么总是想拿来和 ARM 对比一下，看看能不能套在 ARM 上，这也对自己理解也有一些帮助。缺点就是会产生一些先入为主的观念。</p>
<p>一个最简单的 RTOS 应该至少要实现一个多任务管理的功能，所以 RTOS 也可以叫实时多任务操作系统。那么一个简单的 RTOS 的核心就是怎么处理多任务或者说多线程之间的切换，这里我们也叫做上下文切换，所以上下文切换机制的实现就非常重要，这就要牵扯到不同架构的 CPU 会有不同的处理方式。</p>
<h3 id="ARM-架构下-RTOS-的一般处理过程"><a href="#ARM-架构下-RTOS-的一般处理过程" class="headerlink" title="ARM 架构下 RTOS 的一般处理过程"></a>ARM 架构下 RTOS 的一般处理过程</h3><p>这里以 Cortex-M3 为例，在 ARM 架构中有一组 <strong><code>特殊功能寄存器组</code></strong>，很多时候就是专门留给 OS 使用的。其中由 <kbd><strong>CONTROL[0:1]</strong></kbd> 寄存器来定义 CPU 的特权等级。这里就要提到在 ARM 架构中的双堆栈机制，在 CM3 内核中支持两个堆栈，一个是 MSP（主堆栈指针）指向的主堆栈和 PSP（线程堆栈指针）指向的线程堆栈。通过配置 CONTROL 寄存器的两个位来选择特权级别和使用不同的堆栈指针（还有一个骚操作就是从异常返回时修改 LR 的 <code>bit1</code> 和 <code>bit2</code> 也可以切换模式和堆栈，我们可以在很多开源的 RTOS 中见到）。这样通过这两个寄存器的配置就可以分开对待用户程序和系统程序，避免因用户级程序的问题对系统造成危害。同时在出入异常处理时这两个堆栈指针是通过硬件自动切换的，对于现场的保存就不需要软件来处理了。而且在 Handler 或者说异常中只能使用 MSP（主堆栈指针）。</p>
<table>
<thead>
<tr>
<th align="center">CONTROL[0]</th>
<th align="center">CONTROL[1]</th>
<th align="center">组合</th>
<th align="center">模式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">特权选择</td>
<td align="center">堆栈指针选择</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">特权级+MSP</td>
<td align="center">Handler 模式和 Kernel(OS)</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">特权级+PSP</td>
<td align="center">线程模式</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">用户级+MSP</td>
<td align="center">错误用法</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">用户级+PSP</td>
<td align="center">线程模式</td>
</tr>
</tbody></table>
<p>由于有了这样的机制，在 RTOS 中对于任务切换就带来了很多便利，通常情况下都是通过 <strong>SVCall(即 SVC，System service Call,系统服务调用)</strong>和 <strong>PendSV(Pendable request for system serivce,可挂起系统调用)</strong>这两个异常来完成系统特权和任务上下文的切换。当然也可以先不考虑特权模式和用户模式，那么就可以仅通过 PendSV 异常来完成任务上下文切换即可。这里可以参考一下 FreeRTOS 的处理代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SVCHandler 进行任务切换</span></span><br><span class="line"><span class="function">__asm <span class="keyword">void</span> <span class="title">vPortSVCHandler</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> pxCurrentTCB;    <span class="comment">// 外部参数，当前任务控制块指针</span></span><br><span class="line">    </span><br><span class="line">    PRESERVE8</span><br><span class="line">    </span><br><span class="line">    ldr r3, = pxCurrentTCB  <span class="comment">// 加载 pxCurrentTCB 的地址到 r3</span></span><br><span class="line">    ldr r1, [r3]            <span class="comment">// 加载 pxCurrentTCB 到 r1</span></span><br><span class="line">    ldr r0, [r1]            <span class="comment">// 加载 pxCurrentTCB 指向的值到 r0, 即当前第一个任务的任务栈栈顶指针</span></span><br><span class="line">    ldmia r0!, &#123;r4-r11&#125;     <span class="comment">// 以 r0 为基地址，将栈里面的内容加载到 r4-r11 寄存器，同时 r0 会递增</span></span><br><span class="line">    msr psp, r0             <span class="comment">// 将 r0 的值，即任务栈指针更新到 psp</span></span><br><span class="line">    isb</span><br><span class="line">    mov r0, #<span class="number">0</span>              <span class="comment">// 将 r0 的值，设置为 0</span></span><br><span class="line">    msr basepri, r0         <span class="comment">// 将 basepri 寄存器设置为0，即所有的中断都没有被屏蔽</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//骚操作</span></span><br><span class="line">    orr r14, #<span class="number">0x0d</span>          <span class="comment">// 当从 SVC 中断服务退出前，通过向 R14 最后4位按位或上0x0d,</span></span><br><span class="line">                            <span class="comment">// 使得硬件在退出时，使用进程堆栈指针 PSP 完成出栈操作并返回后进入线程模式、返回 Thumb 状态</span></span><br><span class="line">                            <span class="comment">//  r14 的 bit1 : 0 PSP 1 MSP；bit2: 0 特权模式  1 用户模式</span></span><br><span class="line">    </span><br><span class="line">    bx r14                  <span class="comment">// 异常返回，这个时候栈中的剩下内容将会自动加载到 CPU 寄存器</span></span><br><span class="line">                            <span class="comment">// xPSR,PC(任务入口地址),R14,R12,R3,R2,R1,R0(任务形参) 同时 PSP 的值也将更新，即指向任务栈的栈顶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__asm <span class="keyword">void</span> <span class="title">xPortPendSVHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> pxCurrentTCB;        <span class="comment">// 外部参数，当前任务控制块指针</span></span><br><span class="line">    <span class="keyword">extern</span> vTaskSwitchContext;  <span class="comment">// 外部函数，当前任务切换函数</span></span><br><span class="line">    </span><br><span class="line">    PRESERVE8</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当进入 PendSVC Handler 时，上一个任务运行环境，即：</span></span><br><span class="line">    <span class="comment">// xPSR,PC(任务入口地址),R14,R12,R3,R2,R1,R0(任务形参),这些将自动保存到任务栈中，剩下的r4-r11需要手动保存</span></span><br><span class="line">    <span class="comment">// 获取任务栈指针到 r0</span></span><br><span class="line">    mrs r0, psp</span><br><span class="line">    isb</span><br><span class="line">    </span><br><span class="line">    ldr r3, =pxCurrentTCB   <span class="comment">// 加载 pxCurrentTCB 的地址到 r3</span></span><br><span class="line">    ldr r2, [r3]            <span class="comment">// 加载 pxCurrentTCB 到 r2</span></span><br><span class="line">    </span><br><span class="line">    stmdb r0!, &#123;r4-r11&#125;     <span class="comment">// 将 CPU 寄存器 r4-r11 的值存储到 r0 指向的地址</span></span><br><span class="line">    str r0, [r2]            <span class="comment">// 将任务栈的新的栈顶指针存储到当前任务TCB的第一个成员，即栈顶指针</span></span><br><span class="line">    </span><br><span class="line">    stmdb sp!,&#123;r3,r14&#125;      <span class="comment">// 将 r3 和 r14 临时压入堆栈，因为即将调用函数 </span></span><br><span class="line">                            <span class="comment">// 调用函数时，返回地址自动保存到 r14 中，导致 r14 的值会被覆盖，所以 r14 的值需要入栈保护</span></span><br><span class="line">                            <span class="comment">// r3 保存的当前激活的任务 TCB 指针( pxCurrentTCB ),函数调用后会用到，因此也需要入栈保护</span></span><br><span class="line">    </span><br><span class="line">    mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY    <span class="comment">// 进入临界段</span></span><br><span class="line">    msr basepri, r0         <span class="comment">// 屏蔽所有中断</span></span><br><span class="line">    dsb</span><br><span class="line">    isb</span><br><span class="line">    bl vTaskSwitchContext   <span class="comment">// 调用函数 vTaskSwitchContext，寻找新的任务运行，通过使变量 pxCurrentTCB 指向新的任务来实现任务切换</span></span><br><span class="line">    mov r0, #<span class="number">0</span>              <span class="comment">// 退出临界段</span></span><br><span class="line">    msr basepri, r0</span><br><span class="line">    ldmia sp!, &#123;r3,r14&#125;     <span class="comment">// 恢复 r3, r14</span></span><br><span class="line">    </span><br><span class="line">    ldr r1, [r3]            </span><br><span class="line">    ldr r0, [r1]            <span class="comment">// 当前激活的任务 TCB 第一项保存了任务堆栈的栈顶指针，现在栈顶值存入了 r0</span></span><br><span class="line">    ldmia r0!,&#123;r4-r11&#125;      <span class="comment">// 出栈</span></span><br><span class="line">    msr psp, r0</span><br><span class="line">    isb</span><br><span class="line">    bx r14                  <span class="comment">// 异常发生时，R14 中保存异常返回标志，包括返回后进入线程模式还是处理器模式</span></span><br><span class="line">                            <span class="comment">// 使用 psp 堆栈指针还是 msp 堆栈指针，当调用 bx r14 指令后，硬件会知道要从硬件返回</span></span><br><span class="line">                            <span class="comment">// 然后出栈，这个时候堆栈指针 psp 硬件指向了 新任务堆栈的正确位置</span></span><br><span class="line">                            <span class="comment">// 当新任务的运行地址被出栈到 pc 寄存器后，新的任务也会被执行</span></span><br><span class="line">    nop    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个汇编函数就完成了 ARM 架构下的任务切换机制。其实对于任务上下文切换就是任务现场的保存和恢复，这个现场就是当前的 CPU 运行状态，也就是 CPU 各个寄存器的状态的保存与恢复。这其中也包括很重要的栈帧切换。当然仅仅靠这两个函数也是不完全可靠的，还有一些临界段的处理函数来共同保证任务的安全切换。</p>
<h3 id="RISC-V-架构下的-RTOS-一般处理过程"><a href="#RISC-V-架构下的-RTOS-一般处理过程" class="headerlink" title="RISC-V 架构下的 RTOS 一般处理过程"></a>RISC-V 架构下的 RTOS 一般处理过程</h3><p>在 RISC-V 架构中，也有不同的特权级别，目前主要定义了三种特权级别，分别是<strong>机器模式（Machine Mode，M-mode）、监管模式（Supervisor Mode,S-mode）和用户模式（User Mode,U-Mode）</strong>， 通过 <strong>CSRs(control and status registers,控制状态寄存器)</strong> 的 <code>bit11</code>、<code>bit12</code>(即 MPP 位)两个位的不同编码来实现不同特权模式的切换，在不同特权模式下都有单独的 CSRs。这里需要说明的是我这个 MPP 指的是 Machine-Level CSRs 中 mstatus 寄存器（即 M-mode status register）的控制位。</p>
<table>
<thead>
<tr>
<th align="center">Level</th>
<th align="center">MPP[12:11]</th>
<th align="center">模式</th>
<th align="center">简写</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0 0</td>
<td align="center">User/Application</td>
<td align="center">U</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0 1</td>
<td align="center">Supervisor</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1 0</td>
<td align="center">Reserved（Hypervisor）</td>
<td align="center">（保留）</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1 1</td>
<td align="center">Machine</td>
<td align="center">M</td>
</tr>
</tbody></table>
<p>但是一个 RISC-V 处理器的实现并不要求同时支持这三种特权级，接受以下的一些实现组合，降低实现成本：</p>
<table>
<thead>
<tr>
<th align="center">Number of levels</th>
<th align="left">Supported Modes</th>
<th align="center">Intended Usage</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">M</td>
<td align="center">Simple embedded systems</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">M,U</td>
<td align="center">Secure embedded systems</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">M,S,U</td>
<td align="center">Systems running Unix-like operating systems</td>
</tr>
</tbody></table>
<p>上图中可以看出，这三种模式只有 M-mode 是必须要实现的，其它两种模式是可选的。M-mode 是 RISC-V 中 <strong>hart（hardware thread，硬件线程）</strong>可以执行的最高权限模式。在 M 模式下运行的 hart 对内存，I/O 和一些对于启动和配置系统来说必要的底层功能有着完全的使用权。因此它是唯一所有标准 RISC-V 处理器都必须实现的权限模式。实际上简单的 RISC-V 微控制器仅支持 M 模式。</p>
<p>好了，上面说的是特权模式和 ARM 的区别，下面就是堆栈指针的区别。上文已经提到 ARM 中有 MSP 和 PSP 之分，且在 handler 中只能使用 MSP，也就意味着 OS 和线程模式使用不同的栈。并且出入异常的栈帧切换由硬件完成。</p>
<p>而在 RISC-V 架构处理器中，没有区分异常、中断和线程模式使用的栈帧，在进入和退出中断处理模式时没有硬件自动保存和恢复上下文（通用寄存器）的操作，因此需要软件明确地使用（汇编语言编写的）指令进行上下文的保存和恢复。并且还要区分 ecall（environment call for U/S/M-mode，不同特权模式下的环境调用异常）。</p>
<p>所以 RISC-V 这一块的处理要复杂一些，有大量的 RISC-V 汇编，具体的代码我就不贴了，有兴趣的可以去看一下 FreeRTOS 的源码。链接：<strong><a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/master/portable/GCC/RISC-V/portASM.s" target="_blank" rel="noopener">https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/master/portable/GCC/RISC-V/portASM.s</a></strong></p>
<p>下表是 RISC-V  RV32I 基础指令集寄存器结构，但 RV32E 基础指令集只有 <code>x0</code>-<code>x15</code>。</p>
<table>
<thead>
<tr>
<th align="center">Register</th>
<th align="center">ABI Name</th>
<th align="center">Description</th>
<th align="center">Saver</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x0</td>
<td align="center">zero</td>
<td align="center">Hard-wired zero</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">x1</td>
<td align="center">ra</td>
<td align="center">Return address</td>
<td align="center">Caller</td>
</tr>
<tr>
<td align="center">x2</td>
<td align="center">sp</td>
<td align="center">Stack pointer</td>
<td align="center">Callee</td>
</tr>
<tr>
<td align="center">x3</td>
<td align="center">gp</td>
<td align="center">Global pointer</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">x4</td>
<td align="center">tp</td>
<td align="center">Thread pointer</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">x5-7</td>
<td align="center">t0-2</td>
<td align="center">Temporaries</td>
<td align="center">Caller</td>
</tr>
<tr>
<td align="center">x8</td>
<td align="center">s0/fp</td>
<td align="center">Saved register/Frame pointer</td>
<td align="center">Callee</td>
</tr>
<tr>
<td align="center">x9</td>
<td align="center">s1</td>
<td align="center">Saved register</td>
<td align="center">Callee</td>
</tr>
<tr>
<td align="center">x10-11</td>
<td align="center">a0-1</td>
<td align="center">Function Arguments/return values</td>
<td align="center">Caller</td>
</tr>
<tr>
<td align="center">x12-17</td>
<td align="center">a2-7</td>
<td align="center">Function arguments</td>
<td align="center">Caller</td>
</tr>
<tr>
<td align="center">x18-27</td>
<td align="center">s2-11</td>
<td align="center">Saved registers</td>
<td align="center">Callee</td>
</tr>
<tr>
<td align="center">x28-31</td>
<td align="center">t3-6</td>
<td align="center">Temporaries</td>
<td align="center">Caller</td>
</tr>
</tbody></table>
<p>上表中虽然对各个寄存器有了一些描述，在 RISC-V 指令集中并没有指定专用的堆栈指针或子程序返回地址链接寄存器等，事实上指令编码允许将任何 x 寄存器用于这些目的。 但是，标准软件调用约定使用寄存器 x1 来保存呼叫的返回地址，而寄存器 x5 可用作备用链接寄存器。 标准调用约定使用寄存器 x2 作为堆栈指针。硬件可能会选择加速使用 x1 或 x5 的函数调用和返回。（不知道这段 Google 翻译的描述是否准确，大家可以去阅读《riscv-spec-20191213》的 2.1 节原文参考）</p>
<h2 id="在-wujian100-RISC-V-开源平台上实现简单的任务调度系统"><a href="#在-wujian100-RISC-V-开源平台上实现简单的任务调度系统" class="headerlink" title="在 wujian100 RISC-V 开源平台上实现简单的任务调度系统"></a>在 wujian100 RISC-V 开源平台上实现简单的任务调度系统</h2><p>在了解了上面的一些区别后，我准备尝试移植 FreeRTOS 或者 RT-Thread 到 wujian100 上试试，但是我发现它们大多是只支持了以 RV32I 为基础指令集的处理器。而 wujian100 是 E902，是 RV32E 基础指令集，在底层汇编的处理上有一些不同，可能还要做一些修改。所以我就想试着把我之前学习 FreeRTOS 时，实现的仅有任务调度功能的极简版 FreeRTOS 放上去试试，因为代码量比较少。</p>
<p>接下来，我就尝试在 wujian100 开源的 SDK 中移花接木，把我自己这个极简的小操作系统移植上去。在仔细翻阅了 wujian 开源的代码后发现他们这里提供了一个 AliOS 的内核，叫 rhino 内核。在他们这个内核的底层是有实现一些上下文切换的代码的，于是我就基于这个底层把我的上层接上去。当然这过程中还要修改很多东西，这里就不一一详述，直接看这段汇编代码是怎么处理的，这里我已经做了一些修改，我的两个小任务也转起来了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSTATUS_PRV1 0x1880</span></span><br><span class="line"></span><br><span class="line">.global cpu_intrpt_save</span><br><span class="line">.type cpu_intrpt_save, %function</span><br><span class="line">cpu_intrpt_save:</span><br><span class="line">    csrr    a0, mstatus  <span class="comment">// 读控制状态寄存器，写入 a0，并返回到 psr 返回值中,psr 是外部定义的一个变量，恢复时会使用</span></span><br><span class="line">    csrc    mstatus, <span class="number">8</span>  <span class="comment">// 将控制状态寄存器清零。清零对应的标志位，该语句即为清除 MIE ，即禁止全局中断使能。就是禁用中断</span></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.global cpu_intrpt_restore</span><br><span class="line">.type cpu_intrpt_restore, %function</span><br><span class="line">cpu_intrpt_restore:</span><br><span class="line">    csrw    mstatus, a0   <span class="comment">// a0 是传进来的参数，即上一次保存的控制状态寄存器的值，对于 a0 中每一个为 1 的位，把 mstatus 中对应的位进行置位</span></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.global cpu_task_switch</span><br><span class="line">.type cpu_task_switch, %function</span><br><span class="line">cpu_task_switch:                <span class="comment">// 主动任务切换调度</span></span><br><span class="line">    la     a0, g_intrpt_level_1 <span class="comment">// g_intrpt_level_1 是一个全局变量，用于保存当前中断嵌套的层级；这里是将其地址加载到 a0 中</span></span><br><span class="line">    lb     a0, (a0)             <span class="comment">//  将 a0 地址的数据加载到 a0 中</span></span><br><span class="line">    beqz   a0, __task_switch    <span class="comment">// beqz 是对于零时的分支指令，如果等于零，就执行 __task_switch 函数，也就是意味着当前没有中断嵌套</span></span><br><span class="line"></span><br><span class="line">    la     a0, pxCurrentTCB      <span class="comment">// 如果不等于零，即有中断嵌套，就进行下面的操作；加载 pxCurrentTCB 的地址到 a0,即获取当前任务指针</span></span><br><span class="line">    la     a1, g_ReadyTasksLists <span class="comment">// 加载 g_ReadyTasksLists 的地址到 a1，即获取当前最高优先级的就绪任务指针</span></span><br><span class="line">    lw     a2, (a1)  <span class="comment">// 加载就绪任务指针到 a2  (lw 指令读取一个字，即4个字节的数据 到 a2</span></span><br><span class="line">    sw     a2, (a0)  <span class="comment">// 将 a2 的低4个字节存储到 a0（即将就绪任务指针放到当前任务）</span></span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.global cpu_intrpt_switch</span><br><span class="line">.type cpu_intrpt_switch, %function</span><br><span class="line">cpu_intrpt_switch:   <span class="comment">// 中断中的任务切换 操作和上面类似</span></span><br><span class="line">    la     a0, pxCurrentTCB</span><br><span class="line">    la     a1, g_ReadyTasksLists</span><br><span class="line">    lw     a2, (a1)</span><br><span class="line">    sw     a2, (a0)</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.global cpu_first_task_start</span><br><span class="line">.type cpu_first_task_start, %function</span><br><span class="line">cpu_first_task_start:      <span class="comment">// 第一次进入任务时是不用返回的</span></span><br><span class="line">    j       __task_switch_nosave</span><br><span class="line"></span><br><span class="line">.type __task_switch, %function</span><br><span class="line">__task_switch:    <span class="comment">// 任务切换函数 </span></span><br><span class="line">    addi    sp, sp, <span class="number">-60</span>  <span class="comment">// 规划保存数据需要的栈帧大小</span></span><br><span class="line"><span class="comment">// 保存现场，将寄存器的数据保存到栈帧中</span></span><br><span class="line">    sw      x1, <span class="number">0</span>(sp)</span><br><span class="line">    sw      x3, <span class="number">4</span>(sp)</span><br><span class="line">    sw      x4, <span class="number">8</span>(sp)</span><br><span class="line">    sw      x5, <span class="number">12</span>(sp)</span><br><span class="line">    sw      x6, <span class="number">16</span>(sp)</span><br><span class="line">    sw      x7, <span class="number">20</span>(sp)</span><br><span class="line">    sw      x8, <span class="number">24</span>(sp)</span><br><span class="line">    sw      x9, <span class="number">28</span>(sp)</span><br><span class="line">    sw      x10, <span class="number">32</span>(sp)</span><br><span class="line">    sw      x11, <span class="number">36</span>(sp)</span><br><span class="line">    sw      x12, <span class="number">40</span>(sp)</span><br><span class="line">    sw      x13, <span class="number">44</span>(sp)</span><br><span class="line">    sw      x14, <span class="number">48</span>(sp)</span><br><span class="line">    sw      x15, <span class="number">52</span>(sp)</span><br><span class="line"></span><br><span class="line">    sw      ra, <span class="number">56</span>(sp)</span><br><span class="line"></span><br><span class="line">    la      a1, pxCurrentTCB <span class="comment">// 将当前任务控制块指针地址，加载到 a1</span></span><br><span class="line">    lw      a1, (a1)         <span class="comment">// 将任务控制块指针地址加载到 a1</span></span><br><span class="line">    sw      sp, (a1)         <span class="comment">// 将栈指针加载到当前任务控制块指针地址</span></span><br><span class="line"></span><br><span class="line">__task_switch_nosave:        <span class="comment">// 第一次进入任务入口，接下来切换任务指针</span></span><br><span class="line">    la      a0, g_ReadyTasksLists</span><br><span class="line">    la      a1, pxCurrentTCB</span><br><span class="line">    lw      a2, (a0)</span><br><span class="line">    sw      a2, (a1)</span><br><span class="line"></span><br><span class="line">    lw      sp, (a2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Run in machine mode */</span></span><br><span class="line">    li      t0, MSTATUS_PRV1</span><br><span class="line">    csrs    mstatus, t0  <span class="comment">// 将对于 t0 对应为 1 的每一位置位，即 mpp 设置为 11，machine mode 运行；mpie 置位，用于保存发生异常时 mie 的值；即切换到 M-mode</span></span><br><span class="line"></span><br><span class="line">    lw      t0, <span class="number">56</span>(sp)   <span class="comment">// 将 56(sp) 低 4个字节的数据加载到 t0，即返回地址</span></span><br><span class="line">    csrw    mepc, t0     <span class="comment">// 将 t0 写入 mepc  这里需要注意的是，栈区的数据，在任务初始化的时候就要初始化好，包括第一次启动</span></span><br><span class="line"><span class="comment">// 加载栈帧数据</span></span><br><span class="line">    lw      x1, <span class="number">0</span>(sp)</span><br><span class="line">    lw      x3, <span class="number">4</span>(sp)</span><br><span class="line">    lw      x4, <span class="number">8</span>(sp)</span><br><span class="line">    lw      x5, <span class="number">12</span>(sp)</span><br><span class="line">    lw      x6, <span class="number">16</span>(sp)</span><br><span class="line">    lw      x7, <span class="number">20</span>(sp)</span><br><span class="line">    lw      x8, <span class="number">24</span>(sp)</span><br><span class="line">    lw      x9, <span class="number">28</span>(sp)</span><br><span class="line">    lw      x10, <span class="number">32</span>(sp)</span><br><span class="line">    lw      x11, <span class="number">36</span>(sp)</span><br><span class="line">    lw      x12, <span class="number">40</span>(sp)</span><br><span class="line">    lw      x13, <span class="number">44</span>(sp)</span><br><span class="line">    lw      x14, <span class="number">48</span>(sp)</span><br><span class="line">    lw      x15, <span class="number">52</span>(sp)</span><br><span class="line"></span><br><span class="line">    addi    sp, sp, <span class="number">60</span></span><br><span class="line">    mret   <span class="comment">// M-mode 特有指令，返回时将 PC 指针设置为 mepc,将 mpie 复制到 mie 恢复之前的中断设置，并将特权模式设置为 mpp 中的值；这里就可以完成特权模式的切换(M-U or U-M) </span></span><br><span class="line"></span><br><span class="line">.global Default_IRQHandler</span><br><span class="line">.type   Default_IRQHandler, %function</span><br><span class="line">Default_IRQHandler:    <span class="comment">// 异常、中断处理，这里也需要保存现场，处理类似</span></span><br><span class="line">    addi    sp, sp, <span class="number">-60</span></span><br><span class="line"></span><br><span class="line">    sw      x1, <span class="number">0</span>(sp)</span><br><span class="line">    sw      x3, <span class="number">4</span>(sp)</span><br><span class="line">    sw      x4, <span class="number">8</span>(sp)</span><br><span class="line">    sw      x5, <span class="number">12</span>(sp)</span><br><span class="line">    sw      x6, <span class="number">16</span>(sp)</span><br><span class="line">    sw      x7, <span class="number">20</span>(sp)</span><br><span class="line">    sw      x8, <span class="number">24</span>(sp)</span><br><span class="line">    sw      x9, <span class="number">28</span>(sp)</span><br><span class="line">    sw      x10, <span class="number">32</span>(sp)</span><br><span class="line">    sw      x11, <span class="number">36</span>(sp)</span><br><span class="line">    sw      x12, <span class="number">40</span>(sp)</span><br><span class="line">    sw      x13, <span class="number">44</span>(sp)</span><br><span class="line">    sw      x14, <span class="number">48</span>(sp)</span><br><span class="line">    sw      x15, <span class="number">52</span>(sp)</span><br><span class="line"></span><br><span class="line">    csrr    t0, mepc</span><br><span class="line">    sw      t0, <span class="number">56</span>(sp)</span><br><span class="line"></span><br><span class="line">    la      a0, pxCurrentTCB</span><br><span class="line">    lw      a0, (a0)</span><br><span class="line">    sw      sp, (a0)</span><br><span class="line"></span><br><span class="line">    la      sp, g_top_irqstack</span><br><span class="line"></span><br><span class="line">    csrr    a0, mcause     <span class="comment">// 读取异常类型</span></span><br><span class="line">    andi    a0, a0, <span class="number">0x3FF</span></span><br><span class="line">    slli    a0, a0, <span class="number">2</span></span><br><span class="line"><span class="comment">// 处理异常</span></span><br><span class="line">    la      a1, g_irqvector</span><br><span class="line">    add     a1, a1, a0</span><br><span class="line">    lw      a2, (a1)</span><br><span class="line">    jalr    a2</span><br><span class="line"><span class="comment">// 退出异常，恢复</span></span><br><span class="line">    la      a0, pxCurrentTCB</span><br><span class="line">    lw      a0, (a0)</span><br><span class="line">    lw      sp, (a0)</span><br><span class="line"></span><br><span class="line">    csrr    a0, mcause</span><br><span class="line">    andi    a0, a0, <span class="number">0x3FF</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clear pending */</span><span class="comment">//清除挂起的异常</span></span><br><span class="line">    li      a2, <span class="number">0xE000E100</span></span><br><span class="line">    add     a2, a2, a0</span><br><span class="line">    lb      a3, <span class="number">0</span>(a2)</span><br><span class="line">    li      a4, <span class="number">1</span></span><br><span class="line">    <span class="keyword">not</span>     a4, a4</span><br><span class="line">    <span class="keyword">and</span>     a5, a4, a3</span><br><span class="line">    sb      a5, <span class="number">0</span>(a2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Run in machine mode */</span></span><br><span class="line">    li      t0, MSTATUS_PRV1</span><br><span class="line">    csrs    mstatus, t0</span><br><span class="line"></span><br><span class="line">    lw      t0, <span class="number">56</span>(sp)</span><br><span class="line">    csrw    mepc, t0</span><br><span class="line"></span><br><span class="line">    lw      x1, <span class="number">0</span>(sp)</span><br><span class="line">    lw      x3, <span class="number">4</span>(sp)</span><br><span class="line">    lw      x4, <span class="number">8</span>(sp)</span><br><span class="line">    lw      x5, <span class="number">12</span>(sp)</span><br><span class="line">    lw      x6, <span class="number">16</span>(sp)</span><br><span class="line">    lw      x7, <span class="number">20</span>(sp)</span><br><span class="line">    lw      x8, <span class="number">24</span>(sp)</span><br><span class="line">    lw      x9, <span class="number">28</span>(sp)</span><br><span class="line">    lw      x10, <span class="number">32</span>(sp)</span><br><span class="line">    lw      x11, <span class="number">36</span>(sp)</span><br><span class="line">    lw      x12, <span class="number">40</span>(sp)</span><br><span class="line">    lw      x13, <span class="number">44</span>(sp)</span><br><span class="line">    lw      x14, <span class="number">48</span>(sp)</span><br><span class="line">    lw      x15, <span class="number">52</span>(sp)</span><br><span class="line"></span><br><span class="line">    addi    sp, sp, <span class="number">60</span></span><br><span class="line">    mret</span><br></pre></td></tr></table></figure>

<p><strong>除了上面的汇编部分，还有几个主要函数如下，代码工程我后面整理好会上传到我的 Github 上。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskSwitching_example</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    prvInitTaskLists();</span><br><span class="line">    </span><br><span class="line">    Task1_Handle = xTaskCreateStatic(  Task1_Entry,</span><br><span class="line">                                       <span class="string">"Task1_Entry"</span>,</span><br><span class="line">                                       TASK1_STACK_SIZE,</span><br><span class="line">                                       <span class="literal">NULL</span>,</span><br><span class="line">									                     <span class="number">1</span>,</span><br><span class="line">                                       Task1Stack,</span><br><span class="line">                                       &amp;Task1TCB );</span><br><span class="line">    <span class="comment">// 核心就是插入函数 vListInsert, 将任务插入到就绪列表中</span></span><br><span class="line">    vListInsert(&amp;pxReadyTasksLists[<span class="number">1</span>], &amp;Task1TCB.xStateListNode);   </span><br><span class="line">    </span><br><span class="line">    Task2_Handle = xTaskCreateStatic(  Task2_Entry,</span><br><span class="line">                                       <span class="string">"Task2_Entry"</span>,</span><br><span class="line">                                       TASK2_STACK_SIZE,</span><br><span class="line">                                       <span class="literal">NULL</span>,</span><br><span class="line">									                     <span class="number">2</span>,</span><br><span class="line">                                       Task2Stack,</span><br><span class="line">                                       &amp;Task2TCB );</span><br><span class="line">    vListInsert(&amp;pxReadyTasksLists[<span class="number">2</span>], &amp;Task2TCB.xStateListNode);	</span><br><span class="line">    vTaskStartScheduler();  <span class="comment">//去启动第一个任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vTaskSwitchContext</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 轮流切换两个任务，我这里任务暂时是手动切换的，没使用优先级</span></span><br><span class="line">    <span class="keyword">if</span>( pxCurrentTCB == &amp;Task1TCB)</span><br><span class="line">    &#123;</span><br><span class="line">        g_ReadyTasksLists[<span class="number">0</span>] =&amp; Task2TCB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        g_ReadyTasksLists[<span class="number">0</span>] =&amp; Task1TCB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wjYIELD</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PSRC_ALL();</span><br><span class="line">	portDISABLE_INTERRUPTS();</span><br><span class="line">	vTaskSwitchContext();</span><br><span class="line">	cpu_task_switch();</span><br><span class="line">	portENABLE_INTERRUPTS();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个任务函数 Task1 入口函数 ；task2 和 task1 一样</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task1_Entry</span><span class="params">(<span class="keyword">void</span> *p_arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        flag1 = <span class="number">1</span>;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">"flag1 = %d \n"</span>, flag1);</span><br><span class="line">        delay( <span class="number">100</span> );</span><br><span class="line"><span class="comment">//        vTaskDelay( 20 );</span></span><br><span class="line">        flag1 = <span class="number">0</span>;</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">"flag1 = %d \n"</span>, flag1);</span><br><span class="line">        delay( <span class="number">100</span> );</span><br><span class="line"><span class="comment">//        vTaskDelay( 20 );</span></span><br><span class="line">		    wjYIELD(); <span class="comment">// 注意，这里是手动切换任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TaskSwitching_example();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，差不多就这些了。<br><img src="https://s1.ax1x.com/2020/04/09/G53CV0.jpg" alt="wujian_CamelOS"></p>
<h2 id="踩坑总结"><a href="#踩坑总结" class="headerlink" title="踩坑总结"></a>踩坑总结</h2><p>通过这次研究，明白了 ARM 和 RISC-V 架构上的异同，加深了自己对两种架构的理解，相信对以后的学习也更加有帮助。<br>还有就是 wujian100 的开源资料中并没有提供特权架构的相关文档，异常和中断向量表规划也没有具体的说明文档，目前有限的文档中只介绍了外设 IP 的说明，所以在后续的软件开发增加了很多障碍。只有去扒他们提供的 SDK 中的源代码，通过源码来了解他们的架构，还有一点就是他们提供的代码及资料和阿里体系的东西相对耦合或者说兼容。跟开源社区现有的资料和体系不能很好融合。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<ul>
<li>《RISC-V-Reader-Chinese-v2p1》</li>
<li>《riscv-spec-20191213》</li>
<li>《riscv-privileged-20190608-1》</li>
<li>《Cortex-M3权威指南》</li>
<li>《computer organization and design》</li>
<li><a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/tree/master/portable/GCC/RISC-V" target="_blank" rel="noopener">https://github.com/FreeRTOS/FreeRTOS-Kernel/tree/master/portable/GCC/RISC-V</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>IC Design</category>
        <category>RISC-V</category>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>IC Design</tag>
        <tag>RISC-V</tag>
        <tag>wujian100</tag>
      </tags>
  </entry>
  <entry>
    <title>拆解一个很有意思的开关</title>
    <url>//posts/%E6%8B%86%E8%A7%A3%E4%B8%80%E4%B8%AA%E5%BE%88%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E5%BC%80%E5%85%B3.html</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2019/08/30/mjONAf.jpg" alt="linptech-sw"></p>
<p>最近公司买了一个很有意思的开关，说是叫无源无线开关。无线嘛，就是没有电线连接，是无线的，好像是 433 无线模块通讯的。所谓无源就是没有电池或者其他直接的电源供电了，是一个自发电的开关。就是上图这个东东，我很是好奇，很想知道他这个自发电的开关内部是个什么样子，那我们拆开看看吧~ 嘿嘿~~</p>
<a id="more"></a>

<p>趁着下班了，大家都不在，我一个人开始在公司开拆！</p>
<p><img src="https://s2.ax1x.com/2019/08/30/mjXWZt.jpg" alt="外壳"></p>
<p>这个无源无线开关和其他普通开关从外观上来看都差不多。它的塑料外壳和普通开关一样，轻轻撬开即可。打开外壳我们可以看到一根铜线，这应该就是用于无线通讯的天线了。卸下按键壳，下面就是整个开关的主体模块了。开关的主体很牢固的卡在底座上，只能硬撬下来了。</p>
<p><img src="https://s2.ax1x.com/2019/08/30/mjzJFx.jpg" alt="开关主体"></p>
<p>开关主体拿下来还是可以正常使用的，当我把主板上的壳子拆下来后，开关就不可以自发电了。主板的正面有 5 个电容按键，具体功能不得而知，可能是备用、兼容或者是为调试预留的？</p>
<p>拿下电容按键，看到主板背面线圈的一瞬间，相信中学物理还可以的朋友应该都能反应过来，这个开关的自发电原理应该就是咱们学过的电磁感应原理啊！通过线圈切割磁感线然后产生电能供应给其他电路使用。我迫不及待地卸下主板，想一探究竟，看看是不是我想的这样。但是主板和底座之间有一些机械机构互相钳制，费了好大力气才将主板卸下。</p>
<p><img src="https://s2.ax1x.com/2019/08/30/mvCbVJ.jpg" alt="磁铁簧片结构"><br><img src="https://s2.ax1x.com/2019/08/30/mvCqa9.jpg" alt="主体拆解图"></p>
<p>卸下主板后，我们看到底座上确实有一个由三个铆钉固定的磁铁。哈哈，果然是这样。在主体的壳子上有一个弹簧，怼着底座上的拨动机构，在开关按下的时候，拨动机构带动簧片拨动磁铁，磁铁的移动在线圈那端是有限位的，磁铁在一瞬间移动就相当于线圈切割了一次磁感线，从而产生电能给到其他负载。</p>
<blockquote>
<ul>
<li>拨杆机构细节图，挺有意思的一个结构。<br><img src="https://s2.ax1x.com/2019/08/30/mvCL5R.jpg" alt="拨杆机构"></li>
</ul>
</blockquote>
<p>然后来详细看一下主板：</p>
<p><img src="https://s2.ax1x.com/2019/08/30/mvCXP1.jpg" alt="MainBoard"></p>
<p>在主板上主要有一颗 TI 的 <a href="http://www.ti.com.cn/product/cn/CC115L" target="_blank" rel="noopener"><code>CC115L</code></a> 超值射频发射芯片、一颗 ST 的 <a href="https://www.st.com/content/st_com/en/products/microcontrollers-microprocessors/stm8-8-bit-mcus/stm8s-series/stm8s-value-line/stm8s003f3.html" target="_blank" rel="noopener"><code>stm8s003f3p6</code></a> 8 位单片机、一个线圈以及电能采集储能电路。 <code>stm8s003</code>+<code>CC115L/CC113L</code> 的搭配在无线智能家居等场景好像应用很多。具体的芯片资料大家直接看厂商的 datasheet 吧，这里就不多做介绍了。</p>
<p>我仔细研究一下这个磁感线圈电能采集存储电路，主要有 5 个肖特基二极管，一个稳压二极管，一个 PMOS和一个 NMOS 丝印分别是 <code>1GM 、2GM</code> ，以及一个丝印为 <code>A18F</code>的未知芯片，没有找到直接对应的芯片型号，但根据电感来判断应该是一个 DC-DC 转换器，至于应该是降压还是升压就不太清楚了，因为拆开后就没有办法拨动开关产生电能，来测试对应点的电位了。我个人觉得这个线圈应该生产不了多大的电压，所以这里可能是一个升压的。通过按压，电磁线圈产生电能后，通过前级的电路采集后，到电感这里短暂存储，供控制器和射频芯片短暂地工作几十毫秒把控制信号发射出去，这样就可以控制接收端的各种设备了。简单理解了这部分的电路后，我简单绘制了一下这部分的原理图，不一定完全正确，但大体上应该是对的。有兴趣的朋友可以帮我看看，如果有什么错误的地方欢迎给我留言指正。</p>
<p><img src="https://s2.ax1x.com/2019/08/30/mvPfdH.png" alt="能量采集电路"></p>
<p>好了！这一次的拆解就到这里啦<del>，我要赶快装回去了，不能让大家发现！（逃</del>）</p>
<p>简单总结一下吧！</p>
<blockquote>
<ul>
<li>这个无源无线开关还是很 nice 的，不用布线，不用电池，自发电，节能环保！发电线圈的设计也不失为一种新的低功耗方案，在一些更小体积的应用场景可能不太合适吧。</li>
<li>神奇的事情背后都有基本的科学知识，中学的物理知识就这样实际运用在我们的日常生活中啦！</li>
<li>还有拆东西是一件很爽的事情！哈哈哈！</li>
</ul>
</blockquote>
<p>Have fun~</p>
]]></content>
      <categories>
        <category>拆机</category>
      </categories>
      <tags>
        <tag>拆解</tag>
        <tag>无线</tag>
        <tag>自发电开关</tag>
      </tags>
  </entry>
  <entry>
    <title>总线- SoC 内部的主干道</title>
    <url>//posts/%E6%80%BB%E7%BA%BF-SoC-%E5%86%85%E9%83%A8%E7%9A%84%E4%B8%BB%E5%B9%B2%E9%81%93.html</url>
    <content><![CDATA[<h2 id="总线——-SoC-内部的主干道"><a href="#总线——-SoC-内部的主干道" class="headerlink" title="总线—— SoC 内部的主干道"></a>总线—— SoC 内部的主干道</h2><p>开坑！从今天开始来聊一点数字 IC 的一些知识！首先来看一看总线<br>平日里我们都在讲总线总线，连接各模块的公共线，那它在 ARM 芯片中起到了啥木作用，来胡乱绉一通。</p>
<a id="more"></a>

<h3 id="总线的功能"><a href="#总线的功能" class="headerlink" title="总线的功能"></a>总线的功能</h3><p>总线通俗得理解可以完成以下功能：</p>
<blockquote>
<ul>
<li>提供时钟</li>
<li>分配（管理）地址 </li>
<li>响应中断</li>
<li>传输数据</li>
<li>传送控制信号</li>
</ul>
</blockquote>
<h2 id="USB-总线"><a href="#USB-总线" class="headerlink" title="USB 总线"></a>USB 总线</h2><p>以平日里最常见的 USB 为例，USB 其实也是一种总线如下图所示，通常我们计算机连接到 USB 后，USB 提供的总线可以拓展连接到我们的外设，例如 U 盘、键盘、鼠标等……但是设备本身不会与 CPU 进行通信，它们只与 USB HOST 进行通信，USB HOST 会给它们分配相应的中断。一旦 USB 设备插入 USB 接口引起物理上的电平变化便会有中断，此刻的中断并非 CPU 的中断，此时的中断是 USB HOST 的中断，此中断经一定的处理后发送至 CPU 后，CPU监测到是 USB HOST 中断，便将中断交付 USB HOST 进行处理。再来看地址的问题，CPU 是无法直接访问到你的设备的，红色方框内可以看做是一个“<code>家族</code>”，CPU 只能访问到其“<code>家长</code>” USB HOST，USB HOST 访问具体设备才用到地址访问。例如此时 U 盘的地址是 0x0007H，若此地址直接由 CPU 访问的话 CPU 最终只会访问到内存的 0x0007H，而非我们的 U 盘，因此将此地址交付 USB HOST 进行访问才能实现。这里就能看出不仅仅内存有地址，引入总线后，各个外设也有了对应的地址。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/USB.png" alt="usb"></p>
<h2 id="AMBA-总线"><a href="#AMBA-总线" class="headerlink" title="AMBA 总线"></a>AMBA 总线</h2><p>回到 ARM 上来，ARM 的总线遵循 AMBA（ARM 爸——安谋爸爸）的总线规范，ARM 为了让大家能尽可能地接外设变作了个 AMBA 总线规范，通常 AMBA 规范下常见的总线分别是 AHB（高速总线），APB（外设总线），ASB（AHB 备胎）如图所示。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/amba.png" alt="amba"></p>
<p>我们可以把 APB 总线当做乡村公路，AHB 总线当做一条省道，把这两条路连接起来的“<code>十字路</code>”可以叫做“<code>Bus bridges</code>”。AHB 上的设备通常速度较快例如：内存控制器，NAND Flash …… APB 就较慢，例如 UART，GPIO ……最直观的 UART 通常我们最快设置的波特率大概就 115200，还不到 M 级，因此就放在乡村公路跑就可以了。那么不同的路就要跑不同的频率，那么通常设计的外设的 controller 时，其控制时钟就由总线提供，以保证操作的同步性，那么在 IP 中我们就可以看到有叫做 HCLK（AHB）的信号和 PCLK（APB）的信号。我们还可以看到在 M3 和总线之间还有一个模块叫做 BusMatrix，其主要负责多主设备和多从设备的交互和仲裁，目的是为了提高不同主机访问不同外设情况下的带宽，另外一个就是简化 Bus Master 的协议设计（今后有机会进去分析）。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/hclk_pclk.jpg" alt=""></p>
<h2 id="FCLK、HCLK、PCLK"><a href="#FCLK、HCLK、PCLK" class="headerlink" title="FCLK、HCLK、PCLK"></a>FCLK、HCLK、PCLK</h2><p>我们都知道的是芯片内部的“<code>心跳</code>”是由外部晶振给的，外部晶振通常就十几二十兆，但芯片内部动辄七八十兆甚至上 G，那这里就离不开一个叫 CLKCNTL 的东西，它负责提各个部分的“<code>心跳</code>”。刚才我们也说到 APB 和 AHB 是不同速度的公路，因此它们的工作频率是不同的（实际上可以相同的，但其分类的意义就不大了），而 CPU 本身的工作频率也是不同的。如图所示，给 ARM 用的是 FCLK（全局时钟）， 你可以将 PLL 出来的 70MHz 频率分频多少给 FCLK，将 70MHz 频率分频多少给 HCLK,PCLK 这就是 CLKCNTL 做的事，CLKCNTL 分配出来的 FCLK,HCLK,PCLK 三者成一定的倍数关系。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/ambaclk.png" alt=""></p>
<p>具体到 AHB,APB 总线协议和使用应用，今后我们将会逐一胡扯乱绉。技术不到家全靠虾扯蛋，错误应该是满天飞，望各位大神指正。先挖个坑，下次更 AHB 总线下 SRAM 的控制器设计。</p>
<p><strong>By Ricky</strong></p>
]]></content>
      <categories>
        <category>IC Design</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>IC Design</tag>
        <tag>SoC</tag>
        <tag>AMBA</tag>
      </tags>
  </entry>
  <entry>
    <title>我的毕业设计--基于ROS的移动机器人</title>
    <url>//posts/%E6%88%91%E7%9A%84%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8EROS%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA.html</url>
    <content><![CDATA[<p>在做毕设的时候就有这个想法，想把毕设过程中学到的和遇到坑全都一点点的记录下来。但是由于毕设时间也比较紧张，又要上班，所以一直拖到现在也没有写些什么。好在最近毕设也答辩结束了，也毕业了，稍稍轻松了一些，准备最近花一些时间来整理一些毕设的东西，写几篇文字记录一下。接下来整体介绍一下这个机器人。</p>
<a id="more"></a>

<p>简单来说，我的毕设就是做一个可以进行室内 SLAM 建图的移动机器人。首先呢，我把我的机器人分为上层和底层两个部分。上层为决策层，主要是在 Jetson TX2 开发板上，运行 ROS 机器人操作系统以及 SLAM 算法。通过激光雷达或者深度相机获取深度数据，进行机器人的同时定位与地图构建。底层为具体的控制层，主要是 STM32 通过串口通讯与上层进行通信，接收决策层的速度控制指令，以及进行电机速度控制。机器人的系统框架如下图所示。</p>
<p><img src="https://imgchr.com/i/BVUJfK" alt=""><br><img src="https://imgchr.com/i/BVU26g" alt=""></p>
<p>各部分的具体介绍，将在后面我有空的时候慢慢更新，哈哈哈~~</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title>拆解某宝上热销的一款蓝牙耳机</title>
    <url>//posts/%E6%8B%86%E8%A7%A3%E6%9F%90%E5%AE%9D%E4%B8%8A%E7%83%AD%E9%94%80%E7%9A%84%E4%B8%80%E6%AC%BE%E8%93%9D%E7%89%99%E8%80%B3%E6%9C%BA.html</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2019/08/28/mHGnqP.png" alt="mHGnqP.png"></p>
<p>前些天在某宝上购买了一个蓝牙耳机，想着跑步的时候可以听听音乐。我对耳机的要求也不高，听个响就行。于是，就下单了这个在某宝上热销的(10w+)超便宜的蓝牙耳机，只要 <code>￥19.9</code> 还包邮！</p>
<p>用了几天，这个耳机对于只是听个响的我来说绝对 ok！也是对的起它这个价位了。但是没用几天，因为我的疏忽，没有将耳机从口袋拿出来，所以就跟着衣服一起在洗衣机里搅了 40 分钟……</p>
<a id="more"></a>

<p>当我将它拿出来，晾干后，还能开机，正常连接手机。哈哈哈，没坏！我大喜过望，于是我赶忙播放音乐试试，结果发现就在连接上的一瞬间会有音乐。哎！乐极生悲了。它还是坏了，那就在扔掉之前看看它里面都有些什么吧…….</p>
<p>我想按键控制区貌似比较好拆一些，先拆这个吧。结果，没办法还是不好拆，那就暴力点吧！</p>
<p><img src="https://s2.ax1x.com/2019/08/28/mHUruj.jpg" alt="mHUruj.jpg"></p>
<p>拆开后我们可以看到，蓝牙耳机的主要器件都分布在主板的正面。包括 一颗蓝牙 SoC 芯片，一个麦克风，三个贴了防水的按键，两个 LED 灯，一颗 26MHz 有源晶振以及 PCB 板载天线和一些阻容元器件。从主板正面看到有电感，因此可以推断芯片内部应该是集成了 BUCK 的，以降低芯片内部工作电压，降低功耗，从而提高待机时间，达到长时间使用的目的。</p>
<p><img src="https://s2.ax1x.com/2019/08/28/mHs0nU.jpg" alt="mHs0nU.jpg"></p>
<p>关于这个耳机的蓝牙主控芯片，貌似是支持蓝牙 5.0 的，但是我的手机不是所以也就不得而知了。我想根据这个丝印信息，找到关于这颗 SoC 芯片的一些信息，但是在网上我是怎么也没有找到对应的生产公司。这颗 SoC 上丝印的信息是 <code>DCFB14D7B</code>，找了半天好像也就这个公司的 logo 和芯片上的比较符合，一个叫<a href="http://www.abell.net.cn/" target="_blank" rel="noopener"><strong>欧标</strong></a>的公司。神奇的是这个公司貌似是做对讲机、中继台等无线通讯整机产品的公司。在官网上没有找到任何一个地方提到过他们有设计过蓝牙 SoC，但是由于他们也是做无线通讯相关产品的公司，所以我觉得很大概率上是这个公司的芯片。</p>
<p><img src="https://s2.ax1x.com/2019/08/28/mHfAJg.jpg" alt="mHfAJg.jpg"><br><img src="https://s2.ax1x.com/2019/08/28/mH5myd.jpg" alt="mH5myd.jpg"></p>
<p>我在搜索的过程中，还发现了一位智利的老哥拆解过一个，在全球速卖通上购买的 TWS 蓝牙耳机，也是使用的这颗蓝牙芯片（<a href="http://blog.victroniko.cl/blog/post/teardown-bluetooth-tws-t012-es" target="_blank" rel="noopener">他的拆解</a>）。照这样看，我觉得这个公司的蓝牙芯片应该是占据了中低端蓝牙耳机的大部分份额，神奇的是竟然还不为人所熟知！哦，对了这也是一个深圳南山区的公司，深圳南山区卧虎藏龙啊！哈哈哈！</p>
<p>主板的背面到没有什么东西了，主要就是一个 Micro USB 充电口，三个测试点以及连接两个听筒和电池的连接线。整个板的大小也就 <code>42mm * 5mm</code> ，集成度还是很高的。从 PCB 的生产日期（<code>20190612</code>）看，这批耳机貌似还是比较新的。</p>
<p><img src="https://s2.ax1x.com/2019/08/28/mHdq1O.jpg" alt="mHdq1O.jpg"></p>
<p>然后我们拆开电池仓看看，这是一块标称 <code>3.7v/200mAH</code> 的锂电池，接了两根从 PCB 拉过来的电源线。在电池的电源端我们还看到一块很小的 PCB，上面有两颗芯片。一颗是 <code>DW01A</code>，这是一颗锂电池保护 IC。主要是为了防止因为过充、过放、大电流等因素导致锂电池寿命缩短或者损坏的锂电池专用 IC。另外一颗是 <code>8205</code>，这是一颗双 MOS 开关芯片，主要是用来配合 DW01A 来共同构成锂电池保护电路。一路 MOS 用来控制防止过充，另一路 MOS 用来控制防止过放。</p>
<p><img src="https://s2.ax1x.com/2019/08/29/mHTPwn.jpg" alt="mHTPwn.jpg"><br><img src="https://s2.ax1x.com/2019/08/29/mHTCes.jpg" alt="mHTCes.jpg"></p>
<p>好了，到这里我们的拆解就基本完成了~ </p>
<p>总结一下：</p>
<blockquote>
<ul>
<li>这个耳机虽然便宜，但是做工基本 Ok，对得起它这个价位了。</li>
<li>耳机内部虽然简单，但也是五章俱全了，该有的都有。</li>
<li>一个神奇的蓝牙芯片公司，做了低功耗设计，工作和待机时间都还可以。</li>
</ul>
</blockquote>
<p>Have fun ~</p>
<hr>
<p>后记：有朋友给我指正了，这颗 AB 芯片是中科蓝讯这个公司的，在此说明一下。但是我还是没有找到关于这颗芯片更详细的资料了，Datasheet 也没有，那就这样吧！哦，对了这依然是一家深圳南山的公司，哈哈哈！</p>
]]></content>
      <categories>
        <category>拆机</category>
      </categories>
      <tags>
        <tag>拆解</tag>
        <tag>蓝牙</tag>
        <tag>耳机</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Jetson TX2 上安装 ROS 机器人操作系统</title>
    <url>//posts/%E5%9C%A8-Jetson-TX2-%E4%B8%8A%E5%AE%89%E8%A3%85-ROS-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html</url>
    <content><![CDATA[<h3 id="ROS-机器人操作系统"><a href="#ROS-机器人操作系统" class="headerlink" title="ROS 机器人操作系统"></a>ROS 机器人操作系统</h3><p>关于 ROS ( Robot Operating System 机器人操作系统)，这里做一下简单的介绍。ROS 就是一个机器人软件平台，类似于个人电脑的操作系统( Windows、Linux、Mac OS 等)，智能手机的操作系统( Android、iOS 等)。机器人和电脑、手机一样可以通过各种硬件组合的硬件模块组成，自然就出现了用来管理这些硬件的操作系统。操作系统提供了基于硬件抽象的软件开发环境，存在提供各种服务的应用程序。<br>ROS 就是这样一个提供了类似操作系统的硬件抽象。在 ROS 维基中将 ROS 定义为 “ ROS 是一个开放源代码的机器人元操作系统。它提供了我们对操作系统期望的服务，包括硬件抽象、低级设备控制、常用功能的实现、进程之间的消息传递以及功能包管理。它还提供了用于在多台计算机之间获取、构建、编写和运行代码的工具和库。 ”<br>因此，ROS 并不是一种新的操作系统，确切的说，ROS 是一种元级操作系统。是基于现有操作系统的，利用应用程序和分布式计算资源之间的虚拟化层来运用分布式计算资源来执行调度、加载、监视、错误处理等任务的系统。同时提供一个或多个操作系统下的数据通信。</p>
<a id="more"></a>

<p>对于 ROS 的安装，之前官方网站上是没有中文教程的，对于我这种塑料英语，直接看官网英文教程还是蛮有难度的。不过好在现在 ROS 官网已经有中文版的安装教程了。直接参考官网上的教程安装就好了！<br>官网安装教程：<a href="http://wiki.ros.org/cn/kinetic/Installation" target="_blank" rel="noopener">http://wiki.ros.org/cn/kinetic/Installation</a></p>
<h3 id="ROS-版本"><a href="#ROS-版本" class="headerlink" title="ROS 版本"></a>ROS 版本</h3><p>虽然官方已经有了中文版本的安装教程，但是我这里还是简单记录一下。<br>首先，ROS 目前大家使用的主流版本还是 ROS 1.0 的版本，ROS 1.0 版本目前只支持 Linux 系统。而对 ROS 兼容性最好的就是 Ubuntu 操作系统了，恰好我们的 Jetson TX2 就是 Ubuntu 系统。</p>
<p>这里还要说明的是，我们在 TX2 上安装 ROS 系统，并不是要直接在 TX2 上来做开发的(虽然也可以)， TX2 主要是作为部署端的。因此，还需要有一台 Ubuntu 电脑也需要安装上 ROS 来进行开发工作，安装步骤相同。</p>
<p>其次， Ubuntu 和 ROS 都有很多版本，各版本之间是存在兼容性问题的。ROS 和 Ubuntu 之间的版本对应关系如下表：</p>
<table>
<thead>
<tr>
<th align="center">ROS 版本</th>
<th align="center">发布日期</th>
<th align="center">对应的 Ubuntu 版本</th>
<th align="center">停止支持日期</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ROS Melodic</td>
<td align="center">2018.5.23</td>
<td align="center">Ubuntu 18.04(Bionic)/Ubuntu 17.10(Artful)</td>
<td align="center">2023.5</td>
</tr>
<tr>
<td align="center">ROS Lunar</td>
<td align="center">2017.5.23</td>
<td align="center">Ubuntu 17.04(Zesty)/Ubuntu 16.10(Yakkety)/Ubuntu16.04(Xenial)</td>
<td align="center">2019.5</td>
</tr>
<tr>
<td align="center">ROS Kinetic(推荐)</td>
<td align="center">2016.5.23</td>
<td align="center">Ubuntu 16.04(Xenial)/Ubuntu 15.10(Wily)</td>
<td align="center">2021.4</td>
</tr>
<tr>
<td align="center">ROS Jade</td>
<td align="center">2015.5.23</td>
<td align="center">Ubuntu 15.04(Wily)/Ubuntu LTS 14.04(Trusty)</td>
<td align="center">2017.5</td>
</tr>
<tr>
<td align="center">ROS Kinetic</td>
<td align="center">2014.7.22</td>
<td align="center">Ubuntu LTS 14.04(Trusty)</td>
<td align="center">2019.4</td>
</tr>
</tbody></table>
<p>目前主流版本还是 ROS Kinetic 且支持时间较长，今年新出的 Melodic 版资料相对较少。所以推荐安装 ROS Kinetic 版本。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="软件中心配置"><a href="#软件中心配置" class="headerlink" title="软件中心配置"></a>软件中心配置</h4><p>打开软件和更新对话框，配置你的 Ubuntu 软件仓库( repositories )以允许“restricted”，“universe”和“multiverse”这三种安装模式。如下图：<br><img src="https://photo.ishield.cn/pic/5b89420e9dc6d659595a1950" alt=""><br>配置完成关闭窗口。</p>
<h4 id="添加source-list"><a href="#添加source-list" class="headerlink" title="添加source.list"></a>添加source.list</h4><p>设置你的电脑可以从 packages.ros.org 接收软件。<br>打开一个 Terminal ( Ctrl+Alt+T )，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo sh -c &#39;echo “deb http:&#x2F;&#x2F;packages.ros.org&#x2F;ros&#x2F;ubuntu $(lsb_release -sc)main”&gt; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;ros-latest.list&#39;</span><br></pre></td></tr></table></figure>
<p>这个镜像国内会比较慢，建议更换为国内镜像源，就是把上面的命令更换一下。官方<a href="http://wiki.ros.org/ROS/Installation/UbuntuMirrors" target="_blank" rel="noopener">镜像</a></p>
<h4 id="添加密钥"><a href="#添加密钥" class="headerlink" title="添加密钥"></a>添加密钥</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-key adv --keyserver hkp：&#x2F;&#x2F;ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116</span><br></pre></td></tr></table></figure>
<p>如果你遇到连接到 keyserver 的问题，你可以在以上命令尝试替换 hkp://pgp.mit.edu:80 或 hkp://keyserver.ubuntu.com:80<br>密钥可以根据服务器的操作发生变更，如有变化，请参考<a href="http://wiki.ros.org/cn/kinetic/Installation/Ubuntu" target="_blank" rel="noopener">官方wiki</a>页面。</p>
<h4 id="安装-ROS"><a href="#安装-ROS" class="headerlink" title="安装 ROS"></a>安装 ROS</h4><p>首先，确保你的系统软件是最新版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>
<p>接下来，就可以安装 ROS 了，但是 ROS Kinetic 也有好几个版本，这里我们安装全功能版本(包括ROS、rqt、RViz、机器人相关的库、仿真和导航等等。部署端一般基础版就可以了)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install ros-kinetic-desktop-full</span><br></pre></td></tr></table></figure>
<p>这里可能会要等待几分钟，因网速而定。如果一切顺利的话，那就安装完了。<br>安装完成后，可以使用下面的命令查看可使用的软件包(可以搜索到大约1600多个功能包)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-cache search ros-kinetic</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果想个别安装功能包，请使用如下命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install ros-kinetic-[功能包名称]</span><br></pre></td></tr></table></figure>
<p>现在是安装完了，但是我们还需要初始化 ROS 以及配置环境变量</p>
</blockquote>
<h4 id="初始化-rosdep"><a href="#初始化-rosdep" class="headerlink" title="初始化 rosdep"></a>初始化 rosdep</h4><p>在开始使用 ROS 之前还需要初始化 rosdep 。rosdep 可以方便地在需要编译某些源码的时候为其安装一些系统依赖，同时也是某些 ROS 核心功能组件所必需用到的工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rosdep init</span><br><span class="line">$ rosdep update</span><br></pre></td></tr></table></figure>
<h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><p>如果每次打开一个新的终端时 ROS 环境变量都能够自动配置好(即添加到 bash 会话中)，那将会方便很多：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &quot;source &#x2F;opt&#x2F;ros&#x2F;kinetic&#x2F;setup.bash&quot; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line">$ source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<p>可以使用 gedit 或者 vi 等编辑器打开 bashrc 文件查看是否配置成功。在 bashrc 文件最底部我们可以看到已经有了很多设置。不要修改以前的设置，如果你需要修改的话在最底部添加就好了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set ROS Kinetic</span></span><br><span class="line"><span class="built_in">source</span> /opt/ros/kinetic/setup.bash</span><br><span class="line"><span class="built_in">source</span> ~/catkin_ws/devel/setup.bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set ROS Network</span></span><br><span class="line"><span class="built_in">export</span> ROS_HOSTNAME=xxx.xxx.xxx.xxx</span><br><span class="line"><span class="built_in">export</span> ROS_MASTER_URI=http://<span class="variable">$&#123;ROS_HOSTNAME&#125;</span>:11311</span><br></pre></td></tr></table></figure>

<h4 id="安装构建依赖"><a href="#安装构建依赖" class="headerlink" title="安装构建依赖"></a>安装构建依赖</h4><p>到目前为止，已经安装了运行核心 ROS 包所需的内容。为了创建和管理自己的 ROS 工作区，有各种各样的工具和需求分别分布。例如：rosinstall 是一个经常使用的命令行工具，它能够轻松地从一个命令下载许多 ROS 包的源树。</p>
<p>要安装这个工具和其他构建 ROS 包的依赖项，请运行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br></pre></td></tr></table></figure>
<p>好！到这里，ROS 就基本安装完成了。下面就来测试一下，看看是否可以正常运行。</p>
<h3 id="测试-ROS"><a href="#测试-ROS" class="headerlink" title="测试 ROS"></a>测试 ROS</h3><p>首先，启动 ROS 环境<br>输入 roscore 命令，测试测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ roscore</span><br><span class="line">... logging to &#x2F;home&#x2F;ubuntu&#x2F;.ros&#x2F;log&#x2F;3e61b674-03cf-11e8-ac54-9cb70ddc3658&#x2F;roslaunch-ubuntu-31481.log</span><br><span class="line">Checking log directory for disk usage. This may take awhile.</span><br><span class="line">Press Ctrl-C to interrupt</span><br><span class="line">Done checking log file disk usage. Usage is &lt;1GB.</span><br><span class="line">started roslaunch server http:&#x2F;&#x2F;ubuntu:11311&#x2F;</span><br><span class="line">ros_comm version 1.12.12</span><br><span class="line">SUMMARY</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">PARAMETERS</span><br><span class="line"> * &#x2F;rosdistro: kinetic</span><br><span class="line"> * &#x2F;rosversion: 1.12.12</span><br><span class="line">NODES</span><br><span class="line">auto-starting new master</span><br><span class="line">process[master]: started with pid [31495]</span><br><span class="line">ROS_MASTER_URI&#x3D;http:&#x2F;&#x2F;ubuntu:11311&#x2F;</span><br><span class="line">setting &#x2F;run_id to 3e61b674-03cf-11e8-ac54-9cb70ddc3658</span><br><span class="line">process[rosout-1]: started with pid [31508]</span><br><span class="line">started core service [&#x2F;rosout]</span><br></pre></td></tr></table></figure>
<p>如果看到 started core service [/rosout] ，那就说明安装成功了！退出按『Ctrl+c』。</p>
<p>如果你安装过程中出现了问题，可以尝试换个网络，或者多试几次吧，有时候服务器就是连不上！*_*</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>Jetson TX2</tag>
      </tags>
  </entry>
  <entry>
    <title>数字 IC 设计流程</title>
    <url>//posts/%E6%95%B0%E5%AD%97-IC-%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B.html</url>
    <content><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p>最近即将开始要带着学弟们入门数字 IC 的设计，但很多学弟对于接下来要做什么是迷茫的，很多练就了各式各样的基本功却不知道如何施展，因此这里简单介绍一下数字 IC 设计的全过程及相关的设计工具及涉及到的相关职位，如果有写的不合适或者不正确的地方还请各位提出~</p>
<a id="more"></a>

<p>详见下图:</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E5%85%A8%E8%BF%87%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7.png" alt=""></p>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>看了上图之后很多学弟就又问了，那平时我们都是 vivado，quartus，FPGA …… 为啥感觉和上面的都不沾边呢，这里说一点个人的看法，如果不是做硬件并行加速或者 FPGA 的嵌入式开发，那么平日 FPGA 的最大作用就是 —— 功能验证性工具。因为流片的价格非常昂贵，很少有实验室或者学校会让你不断地流片来实现你的设计，另外的，一个实验室如果没有同时具备设计，验证，版图 ……（全栈）技能同学的话要想能流片（同时具备以上技能）其实也很难的。那么这时 FPGA 就可以验证你的设计是否在一定程度上是正确的。</p>
<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>我们最后再来看一下数字前端的设计流程，如下图所示~</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E6%95%B0%E5%AD%97%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<p>之前的 sdram 设计剩余部分,我们将尽快更新~</p>
<p><strong>By Ricky</strong></p>
]]></content>
      <categories>
        <category>IC Design</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>IC Design</tag>
      </tags>
  </entry>
  <entry>
    <title>提升数字 IC 设计效率从 Vim 开始</title>
    <url>//posts/%E6%8F%90%E5%8D%87%E6%95%B0%E5%AD%97-IC-%E8%AE%BE%E8%AE%A1%E6%95%88%E7%8E%87%E4%BB%8E-Vim-%E5%BC%80%E5%A7%8B.html</url>
    <content><![CDATA[<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><p>这篇文章主要分享给在 Windows 下进行数字 IC 开发的盆友们，如果早已 linux，请大神自行忽略，另外建议在 Windows 下的盆友早日脚踏两只船。<br>相信大家都有过为了追一个信号而不断地缩放 RTL 图的经历，有没有一种办法能一键式一条龙服务呢？有！用 Vim！</p>
<p>Vim，一种类似于 notepad 的文本编辑器，其拥有你喜欢的一切功能（护眼模式，关键词高亮 …… 废话没有这些还叫代码文本编辑器），其针对 Verilog 的项目维护是真的善良，黑暗中的阳光。</p>
<a id="more"></a>

<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/top_vim.jpg" alt=""></p>
<p>但这阳光大多数情况下照亮于 Linux 或者 Unix 系统下，那我们试试怎么让光照进 Windows。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/cmd_vim.jpg" alt=""></p>
<h2 id="安装-Cygwin"><a href="#安装-Cygwin" class="headerlink" title="安装 Cygwin"></a>安装 Cygwin</h2><blockquote>
<p>Cygwin 是一个在 Windows 平台上运行的 Unix 模拟环境，是 Cygnus solutions 公司开发的自由软件（该公司开发了很多好东西，著名的还有 eCos，不过现已被 Redhat 收购）。它对于学习 Unix/Linux 操作环境，或者从 Unix 到 Windows 的应用程序移植，或者进行某些特殊的开发工作，尤其是使用 gnu 工具集在 Windows 上进行嵌入式系统开发，非常有用。随着嵌入式系统开发在国内日渐流行，越来越多的开发者对 Cygwin 产生了兴趣。</p>
</blockquote>
<p>下载好 Cygwin 后选择好安装路径，然后选择镜像网址，建议选择国内的镜像地址速度会快一些。可以使用网易的镜像地址：<code>http://mirrors.163.com</code> ,在 URL 栏自行输入镜像地址点击 <code>add</code> 添加后使用。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/cygwin_setup.jpg" alt=""></p>
<p>然后就进入选择安装包，初次进入建议都选择，高手可以有需要的时候可以再进来这个安装页面选择安装。<br>安装完成之后，把 Cygwin 添加到右键菜单，打开便是当前的路径下，这才是 Windows 该有的体验不是吗？而完成这一切只需简单地修改一下注册表。（以下步骤参考网络资源）：</p>
<blockquote>
<ul>
<li>使用<code>Win + R</code>打开运行窗口, 输入 regedit, 回车, 启动注册表编辑程序，找到 HKEY_CLASSES_ROOT\Directory\Background\shell 表项;</li>
<li>右键点击<code>shell</code>，选择<code>新建</code>-&gt;<code>项</code>，命名为<code>Cygwin</code>，或者其他，你右键时看到的就是<code>Cygwin</code>,或者是你自定义的名称;</li>
<li>右键点击刚才创建的<code>Cygwin</code>，选择<code>新建</code>-&gt;<code>项</code>,命名为<code>command</code>，表示点击该菜单项时要执行的命令;</li>
<li>双击<code>command</code>下<code>(默认)</code>数据项，在<code>数值数据(V)</code>下输入如下内容：<br><code>&quot;D:\Coding\Cygwin\bin\mintty.exe&quot;-i/Cygwin-Terminal.ico /bin/env _T=%V /bin/bash -l&quot;</code><br>（你的 Cygwin 安装路径）</li>
</ul>
</blockquote>
<p>这样就可以直接在对应的文件夹通过右击菜单打开命令行窗口。<br>Cygwin 配置好后，接下来我们继续配置一下 Vim 。</p>
<h2 id="Vim-配置"><a href="#Vim-配置" class="headerlink" title="Vim 配置"></a>Vim 配置</h2><ol>
<li><p>让<code>bash</code>命令行支持中文输入，打开 Cygwin 终端，在终端中输入如下命令 <code>vim ~/.inputrc</code>，打开inputrc 文件，将下面几行的注释去掉（去掉#），保存并退出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> meta-flag on</span><br><span class="line"><span class="built_in">set</span> convert-meta off</span><br><span class="line"><span class="built_in">set</span> input-meta on</span><br><span class="line"><span class="built_in">set</span> output-meta on</span><br></pre></td></tr></table></figure>
</li>
<li><p>让 <code>ls</code> 命令支持中文显示，在终端中输入命令 <code>vim ~/.bashrc</code> ，打开 <code>bashrc</code> 文件修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> ls=<span class="string">'ls -hF –-show-control-chars –-color=tty'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置一个个人喜好的 Vim，打开 Cygwin 终端，输入<code>vim ~/.vimrc</code>，编辑如下设置</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> fenc=utf-<span class="number">8</span> <span class="comment">"设定默认解码 </span></span><br><span class="line"><span class="keyword">set</span> fencs=utf-<span class="number">8</span>,usc-bom,gb18030,gbk,gb2312,cp936,euc-jp</span><br><span class="line"><span class="keyword">set</span> nocp <span class="comment">"或者 set nocompatible 用于关闭 VI 的兼容模式 </span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span> <span class="comment">"显示行号 </span></span><br><span class="line"><span class="keyword">set</span> ai <span class="comment">"或者 set autoindent vim 使用自动对齐，也就是把当前行的对齐格式应用到下一行 </span></span><br><span class="line"><span class="keyword">set</span> si <span class="comment">"或者 set smartindent 依据上面的对齐格式，智能的选择对齐方式</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span> <span class="comment">"设置 tab 键为4个空格</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">sw</span>=<span class="number">4</span> <span class="comment">"或者 set shiftwidth 设置当行之间交错时使用4个空格</span></span><br><span class="line"><span class="keyword">set</span> ruler <span class="comment">"设置在编辑过程中,于右下角显示光标位置的状态行 </span></span><br><span class="line"><span class="keyword">set</span> incsearch <span class="comment">"设置增量搜索,这样的查询比较smart </span></span><br><span class="line"><span class="keyword">set</span> showmatch <span class="comment">"高亮显示匹配的括号 </span></span><br><span class="line"><span class="keyword">set</span> matchtime=<span class="number">5</span> <span class="comment">"匹配括号高亮时间(单位为 1/10 s) </span></span><br><span class="line"><span class="keyword">set</span> ignorecase <span class="comment">"在搜索的时候忽略大小写 </span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span> <span class="comment">"高亮语法</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>成功后界面如下图所示</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/vim_v.jpg" alt=""></p>
<h2 id="使用-Vim-提升开发效率"><a href="#使用-Vim-提升开发效率" class="headerlink" title="使用 Vim 提升开发效率"></a>使用 Vim 提升开发效率</h2><p>首先，你需要进入项目工程的顶层目录，假设你整个项目最顶层的目录名叫 Vimtest，那么你就先进入这个目录，然后调用 ctags 工具生成整个工程目录的标签列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Vimtest  <span class="comment"># youproject name</span></span><br><span class="line">$ ctags -R *</span><br></pre></td></tr></table></figure>

<p>顺利的话，你将会看到在 Vimtest 下新创建了一个叫 tags 的文件，在这个文件里将会以“<code>定义名称 文件位置：行数</code>”的格式将你所有项目中的模块，信号，参数定义全部列出，而此处参数<code>-R</code>的含义是递归执行，也就是从顶层目录向下自动遍历全部子目录进行文件检索和定义收录。在默认配置下，ctags 可以自动识别<code>.v</code>和<code>.vhdl</code>后缀文件的语法，如果你同时希望收录测试平台中的<code>.sv</code>文件的话，可能你需要额外增加一个 System Verilog 的语法说明文件。<br>有了这个标签列表之后应该如何使用呢？总不能每次都打开这个 tags 文件然后挨个查询吧？当然不是，接下来我们需要把这个 tags 文件和 Vim 结合起来。首先我们需要再次打开<code>.vimrc</code> 文件<br>打开 cygwin 终端，输入 <code>vim ~/.vimrc</code>， 打开文件后输入一下内容:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">set tags=tags;</span><br><span class="line"><span class="keyword">set</span> autochdir</span><br><span class="line"><span class="keyword">nnoremap</span> t :<span class="keyword">tag</span></span><br></pre></td></tr></table></figure>

<p>第一行命令的含义是指定标签列表名称为 tags，命令最末的<code>;</code>号不可省略，其含义是告知 Vim 首先在当前目录下寻找 tags 文件，如果找不到则自动向更上一级目录查找，现在你明白为什么我们一开始要把 tags 文件生成在项目的顶层目录了吧。第二行命令不是必须的，其含义是每次打开新的文件时，自动将终端切换到该文件的所在目录下。</p>
<p>下面就是见证奇迹的时刻了。你可以进入项目目录下的任何一个子目录，然后 vim top.v（我的工程顶层文件名，你可以叫别的名字）。如果你的<code>vimrc</code>配置跟我上文写的一模一样，那么你就按一下<code>t</code>，如果你的<code>vimrc</code>里没有<code>nnoremap t:tag</code>这一句的话，请手工输入<code>:tag</code>（此处有空格）。然后接着输入任何项目中存在的模块名称，信号名称或者参数名称。比如项目中有一个模块名叫<code>uart</code>，那么完整的命令应该是<code>:tag uart</code>。注意，如果你并不记得模块的完整名称也没关系，随时按下 tab 键都可以自动补全，即使你连开头都不记得了，还可以用<code>/keyword</code>的办法进行搜索。输入完毕后按下回车，如果 Vim 在标签列表中只找到唯一匹配定义的话，就会立刻跳转到对应文件的对应行；如果找到的匹配结果不止一个，就会把所有结果列出来让你用数字序号选择跳转目标。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/vim_tag.jpg" alt=""></p>
<p>很多老手看到这里可能觉得不够过瘾，就只是这样而已，我也早就会了，只不过嫌太麻烦而已，还不是要不停输入模块名称吗，能快到哪里去？呵呵，最会偷懒的我怎么可能只是做到这样的程度而已呢？<br>大家觉得，平时在修改代码设计的时候，最需要进行频繁文件跳转的是什么时候？是不是当你找到了一个关键的寄存器，想顺着信号的传播路径一直跟踪下去的时候？当你跟着这个信号来到一个模块例化面前，是不是恨不能立刻跟着信号钻进这个模块的代码里去？其实，这非常简单。</p>
<p>根据我们前面的介绍，你肯定已经想到了，可以通过<code>:tag module_name</code>跳转到这个模块的设计文件，但是这样太麻烦了，万一模块名字老长还带有大小写，写一遍就得费老半天功夫。有一个相对简单的办法，把光标移动到模块名称上，按下<code>ctrl+]</code>，你会发现自己立刻飞到了该模块的设计文件中！但是！！等等！！我刚才要跟踪的信号是什么名字来着？忘记了对不对？这个方法还是不够方便。<br>有没有更简单的办法？这个办法最好能从我们决定要进入这个模块的那一刻起，只用一个按键操作就能立刻进入这个模块的设计文件，同时光标最好还能直接定位到我们要追踪的信号位置，这个信号的名字最好还能被高亮显示！当！然！没！问！题！</p>
<p>在 vimrc 文件中加入</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nnoremap</span> []</span><br></pre></td></tr></table></figure>

<p>重新打开任何 Vim 文件，假装自己跟踪到了某个模块例化的某个信号上，类似<code>.clk</code>，通常你跟踪到这里的时候，光标应该是放在 clk上面，这时你在键盘上快速按下<code>[</code>和<code>]</code>这两个键，发生了什么？？！！！我是谁？？！我在哪里？！！！恭喜你！成功进入了该模块！！！并且光标飞到了之前 clk 所连接的 module 上！！好了我们可以和过去为了追信号而需要不断 zoom in zoom out 的 RTL 图说再见了~</p>
<p><strong>By Ricky</strong></p>
<p>参考源:<br><a href="https://www.jianshu.com/p/fac45920628d" target="_blank" rel="noopener">https://www.jianshu.com/p/fac45920628d</a><br><a href="https://blog.csdn.net/samxx8/article/details/38777189" target="_blank" rel="noopener">https://blog.csdn.net/samxx8/article/details/38777189</a><br><a href="https://blog.csdn.net/hao508506/article/details/52440220" target="_blank" rel="noopener">https://blog.csdn.net/hao508506/article/details/52440220</a><br><a href="http://kellen.wang/zh/useful-skills-of-vim-while-coding-verilog/" target="_blank" rel="noopener">http://kellen.wang/zh/useful-skills-of-vim-while-coding-verilog/</a></p>
]]></content>
      <categories>
        <category>IC Design</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>IC Design</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Kindle 做树莓派的显示屏</title>
    <url>//posts/%E7%94%A8-Kindle-%E5%81%9A%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%98%BE%E7%A4%BA%E5%B1%8F.html</url>
    <content><![CDATA[<h2 id="一、工具"><a href="#一、工具" class="headerlink" title="一、工具"></a>一、工具</h2><ol>
<li>树莓派3b 一台</li>
<li>Kindle PaperWhite 1 一台</li>
<li>无线键鼠一套</li>
<li>无线路由器 or USB 数据线</li>
</ol>
<a id="more"></a>

<h2 id="二、Kindle-越狱"><a href="#二、Kindle-越狱" class="headerlink" title="二、Kindle 越狱"></a>二、Kindle 越狱</h2><p>首先，按照网上的教程把 Kindle 越狱。但是我手上这台 kindle 是 <code>5.6.1.1</code> 的最高版本了。不能直接越狱，需要先把其刷机，强行固件降级到 <code>5.4.4</code> 版本才能越狱。越狱前注意事项，建议遵守：</p>
<ul>
<li>确认 Kindle 已绑定亚马逊账号；</li>
<li>确认 Kindle 电量处于充满状态；</li>
<li>确认 Kindle 的特惠广告已关闭；</li>
<li>确认 Kindle 已停用 设备密码和家长监护设置；</li>
<li>确认 Kindle 已开启飞行模式处于离线状态。</li>
</ul>
<h3 id="2-1-固件降级"><a href="#2-1-固件降级" class="headerlink" title="2.1 固件降级"></a>2.1 固件降级</h3><p>如果你的 KPW1 也和我一样是高于 <code>5.4.4</code> 的版本，需要先把固件降级到 <code>5.4.4</code>。可以前往书伴的 『<a href="https://bookfere.com/update" target="_blank" rel="noopener">固件大全</a>』 下载 <code>5.4.4</code> 版本固件，然后把 Kindle 连接到电脑直到出现 Kindle 磁盘。把下载到的固件文件 <code>update_kindle_5.4.4.bin</code> 放到 Kindle 的根目录。<strong>不要拔出数据线，直接长按电源键直到开始更新。</strong> 没有问题继续下一步。</p>
<h3 id="2-2-开始越狱"><a href="#2-2-开始越狱" class="headerlink" title="2.2 开始越狱"></a>2.2 开始越狱</h3><p>下载越狱文件『<a href="https://pan.baidu.com/s/1o86ja8i" target="_blank" rel="noopener">kindle-jailbreak-1.14.N.zip</a>』。解压得到压缩包 kindle-5.4-jailbreak.zip，将其再次解压，得到一个名为 kindle-5.4-jailbreak 的文件夹。文件夹内有如下所示七个文件：</p>
<ul>
<li>bridge.conf</li>
<li>bridge.sh</li>
<li>developer.keystore</li>
<li>gandalf</li>
<li>jb.sh</li>
<li>json_simple-1.1.jar</li>
<li>Update_jb_$(cd mnt &amp;&amp; cd us &amp;&amp; sh jb.sh).bin</li>
</ul>
<p>把这些文件拷贝到 Kindle 根目录，安全弹出磁盘。在 Kindle 中依次点击『 <code>首页 -&gt; 菜单（屏幕右上角）-&gt; 设置 -&gt; 菜单（屏幕右上角）-&gt; 更新您的 Kindle</code>』。点击菜单后系统不会重启也不会有其它任何反应，在这期间不要有任何操作，直到屏幕下方出现 『 <strong>** JAILBREAK **</strong> 』的字样时，表示越狱已成功。</p>
<p><img src="https://s1.ax1x.com/2020/05/24/tS3hOU.jpg" alt="越狱"></p>
<h3 id="2-3-升级固件"><a href="#2-3-升级固件" class="headerlink" title="2.3 升级固件"></a>2.3 升级固件</h3><p>最后前往书伴的 『<a href="https://bookfere.com/update" target="_blank" rel="noopener">固件大全</a>』下载最新的 5.6.1.1 版本固件，将固件文件放到 Kindle 根目录，依次点击菜单『 <code>首页 -&gt; 菜单（屏幕右上角）-&gt; 设置 -&gt; 菜单（屏幕右上角）-&gt; 更新您的 Kindle</code>』。等待更新完毕，便得到一个有着最新版本固件的越狱了的 Kindle 系统，你可以进行安装MRPI、KUAL、kterm 、USBNetwork 等插件来完成接下来的操作。</p>
<h2 id="三、安装插件"><a href="#三、安装插件" class="headerlink" title="三、安装插件"></a>三、安装插件</h2><h3 id="3-1-安装-MobileRead-Package-Installer-MRPI-——-插件安装器"><a href="#3-1-安装-MobileRead-Package-Installer-MRPI-——-插件安装器" class="headerlink" title="3.1 安装 MobileRead Package Installer (MRPI) —— 插件安装器"></a>3.1 安装 MobileRead Package Installer (MRPI) —— 插件安装器</h3><ul>
<li>下载 MRPI：<a href="https://pan.baidu.com/s/1H3Df7hh9yptXgtS28uzv1Q" target="_blank" rel="noopener">百度网盘</a>【提取码：xwbg】</li>
<li>官方指南：<a href="http://www.mobileread.com/forums/showthread.php?t=251143" target="_blank" rel="noopener">KUAL: Kindle Unified Application Launcher (v 2.6)</a></li>
</ul>
<p>★ 安装步骤：</p>
<blockquote>
<ol>
<li>用 USB 数据线将 Kindle 连接到电脑上，直到出现 Kindle 磁盘；</li>
<li>解压缩下载到的 kual-mrinstaller-1.7.N-xxx.tar.xz 得到一个文件夹；</li>
<li>把文件夹内的 extensions 和 mrpackages 拷贝到 Kindle 根目录下。</li>
</ol>
</blockquote>
<h3 id="3-2-安装-KUAL-——-插件程序启动器"><a href="#3-2-安装-KUAL-——-插件程序启动器" class="headerlink" title="3.2 安装 KUAL —— 插件程序启动器"></a>3.2 安装 KUAL —— 插件程序启动器</h3><p>KUAL (即 Kindle Unified Application Launcher)，是一款插件启动器。安装KUAL之后，你可以下载或自己编写插件并通过KUAL启动。</p>
<ul>
<li>下载 KUAL：<a href="https://pan.baidu.com/s/1DadoxnlX7u3pjVjrntt_Yw" target="_blank" rel="noopener">百度网盘</a>【提取码：4kb1】</li>
<li>官方指南：<a href="http://www.mobileread.com/forums/showthread.php?t=203326" target="_blank" rel="noopener">KUAL: Kindle Unified Application Launcher (v 2.6)</a></li>
</ul>
<p>★ 安装步骤：</p>
<blockquote>
<ol>
<li>用 USB 数据线将 Kindle 连接到电脑上，直到出现 Kindle 磁盘；</li>
<li>解压缩下载到的 KUAL-v2.x-xxx.tar.xz 得到一个文件夹；</li>
<li>在文件夹中找到 KUAL-KDK-2.0.azw2 拷贝到 Kindle 的 Documents 文件夹中；</li>
<li>弹出 Kindle 磁盘，打开 Kindle，可以看到一个名 Kindle LAUNCHER 的文档，正常情况下，点开此图标应显示菜单。</li>
</ol>
</blockquote>
<h3 id="3-3-安装-Kterm"><a href="#3-3-安装-Kterm" class="headerlink" title="3.3 安装 Kterm"></a>3.3 安装 Kterm</h3><p><code>kterm</code> 是 Kindle 的终端控制台，安装之后可以在 Kindle 进行 shell 的交互操作。</p>
<ul>
<li>下载 Kterm: <a href="https://github.com/bfabiszewski/kterm/releases/download/v2.6/kterm-kindle-2.6.zip" target="_blank" rel="noopener">官方页面</a> | <a href="http://pan.baidu.com/s/1c0ja8hE" target="_blank" rel="noopener">百度网盘</a></li>
<li>官方说明： <a href="https://www.fabiszewski.net/kindle-terminal/" target="_blank" rel="noopener">https://www.fabiszewski.net/kindle-terminal/</a></li>
</ul>
<p>★ 安装步骤：</p>
<blockquote>
<ol>
<li>首先确保安装好了 <code>KUAL</code> 和 <code>MRPI</code>;</li>
<li>下载 kterm-kindle-2.6.zip，解压得到 <code>Kterm</code> 文件夹；</li>
<li>将 Kterm 整个文件夹，复制到 Kindle 根目录下的 extensions 文件夹中；弹出 kindle，重启即可。</li>
</ol>
</blockquote>
<p>点击 Kindle 中的 <code>Kindle LAUNCHER -&gt; Kterm</code>，即可打开 shell 使用。如果 Kindle 和树莓派连接到了同一个 wifi 下的话，就可以直接通过 Kterm 窗口使用 SSH 登录到树莓派使用了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh pi@10.0.0.31    <span class="comment"># ssh $user@ip</span></span><br></pre></td></tr></table></figure>
<p>接着输入账户密码就可以登录了。</p>
<p><img src="https://s1.ax1x.com/2020/05/24/tSZ8CF.png" alt="Kindle Shell"></p>
<h3 id="3-4-安装-USBNetwork-Hack-–-无线管理-Kindle"><a href="#3-4-安装-USBNetwork-Hack-–-无线管理-Kindle" class="headerlink" title="3.4 安装 USBNetwork Hack – 无线管理 Kindle"></a>3.4 安装 USBNetwork Hack – 无线管理 Kindle</h3><p>USBNetwork 是一款 Kindle 插件，它可以让我们通过 WiFi 直接连接到 Kindle 并对其进行传送文件、管理等操作。可以通过 USB 连接 Kindle 和树莓派，通过把 Kindle 当成一块 USB 网卡，这样 Kindle 就可以和树莓派建立物理连接了。</p>
<ul>
<li>下载 USBNetwork：<a href="http://www.mobileread.com/forums/showthread.php?t=225030" target="_blank" rel="noopener">官方页面</a> | <a href="https://pan.baidu.com/s/1qAgVhwfLXY2Z6VyHh5PCEw" target="_blank" rel="noopener">百度网盘</a>【提取码：9tgy】</li>
<li>官方指南：<a href="http://www.mobileread.com/forums/showthread.php?t=186645" target="_blank" rel="noopener">K5/PW USBNetwork</a></li>
</ul>
<p>★ 安装步骤：</p>
<blockquote>
<ol>
<li>首先确保安装了 <code>KUAL</code> 及其插件 <code>MRPI</code>；</li>
<li>用 USB 数据线将 Kindle 连接到电脑上，直到出现 Kindle 磁盘；</li>
<li>解压缩下载到的 <code>kindle-usbnet-0.22.N-xxx.tar.xz</code> 压缩包，得到一个文件夹；</li>
<li>把文件夹内的 <code>Update_usbnet_0.22.N_install_touch_pw.bin</code> 拷贝到 Kindle 里 mrpackages 文件夹中；</li>
<li>弹出 Kindle 磁盘，点击 Kindle 中的 <code>Kindle LAUNCHER</code>，依次点击 <code>Helper -&gt; Install MR Packages</code>；</li>
<li>耐心等待 usbnet 安装，直到安装完成后 Kindle 重启完毕；</li>
<li>重启完成后，重新用 USB 数据线将 Kindle 连接到电脑上，直到出现 Kindle 磁盘；</li>
<li>在 Kindle 根目录可以看到『 usbnet 』文件夹，把此文件夹里名为『 DISABLED_auto 』的文件名改为『 auto 』；</li>
<li>然后在此文件夹里的『 etc 』文件夹中找到『 config 』，并用纯文本编辑器（不建议使用记事本，建议使用 VS Code 等代码编辑器）打开。找到『 USE_WIFI 』改为 <code>true</code>，『 USE_WIFI_SSHD_ONLY 』改为 <code>false</code> ，保存并关闭；</li>
<li>这样就可以通过 <code>WIFI</code> 和 <code>USBNet</code> 登录 Kindle 了。完成这些步骤之后，点击弹出/移除设备，断开 Kindle 与电脑的连接，重启 Kindle。</li>
</ol>
</blockquote>
<h2 id="四、-配置树莓派，连接-Kindle"><a href="#四、-配置树莓派，连接-Kindle" class="headerlink" title="四、 配置树莓派，连接 Kindle"></a>四、 配置树莓派，连接 Kindle</h2><p>连接 Kindle 和 树莓派有两种方式，一种是把 Kindle 和树莓派连接到同一个 WIFI；另一种就是让 Kindle 作为 USB 网卡，通过 USBNet 的方式用 USB 数据线物理连接树莓派。但是想让 Kindle 作为屏幕使用，其实就是通过 screen、tmux 等软件共享屏幕。我这里安装的是 tmux。</p>
<h3 id="4-1-安装-tmux"><a href="#4-1-安装-tmux" class="headerlink" title="4.1 安装 tmux"></a>4.1 安装 tmux</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install tmux</span><br></pre></td></tr></table></figure>

<p>在 <code>~/.bashrc</code> 文件最后添加一段脚本，自动运行 tmux。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start tmux on console(not ssh)</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">command</span> -v tmux&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$(tty)</span>"</span> =~ /dev/tty ]] &amp;&amp; [ -z <span class="string">"<span class="variable">$TMUX</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">          <span class="comment"># We're on a TTY and *not* in tmux</span></span><br><span class="line">          <span class="built_in">exec</span> tmux -u</span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-通过-WIFI-连接树莓派"><a href="#4-2-通过-WIFI-连接树莓派" class="headerlink" title="4.2 通过 WIFI 连接树莓派"></a>4.2 通过 WIFI 连接树莓派</h3><p>点击 Kindle 中的 <code>Kindle LAUNCHER -&gt; Kterm</code>,通过 SSH 连接树莓派；在这之前你需要先查看一下树莓派的 IP 地址是多少。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh pi@10.0.0.31 -t <span class="string">"tmux attach"</span></span><br></pre></td></tr></table></figure>
<p>接着输入账户密码就可以登录了。</p>
<h3 id="4-3-通过-USBNet-连接树莓派"><a href="#4-3-通过-USBNet-连接树莓派" class="headerlink" title="4.3 通过 USBNet 连接树莓派"></a>4.3 通过 USBNet 连接树莓派</h3><p>首先打开  <code>Kindle LAUNCHER -&gt; USBNetwork -&gt; Toggle USBNetwork</code>，将模式切换到 <code>USB Network</code> 模式；当前状态可点击 <code>USBNetwork Status</code> 查看，成功的话提示USBNetwork enabled。<br>可以打开 <code>kterm</code> 使用 <code>ifconfig</code> 命令查看网卡的地址。注意这里默认是 <code>192.168.15.x</code> 网段，和网上常见的 <code>192.168.2.x</code> 网段不同。这个配置是可以在 <code>usbnet</code> 的 <code>config</code> 文件修改的。</p>
<p>接下来将树莓派和 kindle 用 USB 数据线连接，输入 <code>lsusb</code> 命令，，如果看到 <code>Linux-USB Ethernet/RNDIS Gadget</code> 这样的设备说明连接成功。</p>
<p>编辑 <code>/etc/network/interfaces</code> 添加网卡配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vi /etc/network/interfaces</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Kindle USBNet</span></span><br><span class="line">allow-hotplug usb0</span><br><span class="line">mapping hotplug</span><br><span class="line">script grep</span><br><span class="line">map usb0</span><br><span class="line">iface usb0 inet static</span><br><span class="line">address 192.168.15.1</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">broadcast 192.168.15.255</span><br><span class="line">up iptables -I INPUT 1 -s 192.168.15.1 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>重启树莓派，输入 <code>ifconfig usb0</code> 检查网卡是否连接成功，连接成功会显示一个 usb0 网卡设备。<br>这时你可以 <code>ping 192.168.15.244</code>，检查网络是否通畅。一切 ok 的话就就可以启动 Kterm 连接树莓派了。<br>打开 <code>Kterm</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh  pi@192.168.15.1 -t <span class="string">"tmux attach"</span></span><br></pre></td></tr></table></figure>
<p>接着输入账户密码就可以登录了。</p>
<p><img src="https://s1.ax1x.com/2020/05/24/tSeEa6.png" alt="同屏"></p>
<p>最后，如果你想要横屏，那么你就在打开 Kterm 之前，随便打开一本书，切换成横屏即可。切换回竖屏同理。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.shuyz.com/posts/phicomm_n1_with_kindle_as_screen/" target="_blank" rel="noopener">https://www.shuyz.com/posts/phicomm_n1_with_kindle_as_screen/</a><br><a href="https://www.fabiszewski.net/kindle-terminal/" target="_blank" rel="noopener">https://www.fabiszewski.net/kindle-terminal/</a><br><a href="https://bookfere.com/post/512.html" target="_blank" rel="noopener">https://bookfere.com/post/512.html</a><br><a href="http://blog.yarm.is/kindleberry-pi-zero-w.html" target="_blank" rel="noopener">http://blog.yarm.is/kindleberry-pi-zero-w.html</a></p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>Kindle</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetson TX2 重新编译内核添加usb等驱动</title>
    <url>//posts/Jetson-TX2-%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%B7%BB%E5%8A%A0usb%E7%AD%89%E9%A9%B1%E5%8A%A8.html</url>
    <content><![CDATA[<h3 id="Jetson-TX2-重新编译内核添加usb驱动"><a href="#Jetson-TX2-重新编译内核添加usb驱动" class="headerlink" title="Jetson TX2 重新编译内核添加usb驱动"></a>Jetson TX2 重新编译内核添加usb驱动</h3><p>上一篇我们已经简单说明了怎么给 Jetson TX2 刷机，Jetson TX2 虽然已经成功完成刷机了，但是 Nvidia 的默认配置是禁用了一些驱动的，比如说板子上的 UART 串口就不可以用，需要用户自己安装，重新编译新的镜像。<br>本文这里就简单介绍一下，添加驱动并重新编译镜像。<br>在 GitHub 上有别人开源的编译新镜像的脚本文件，在 Jetsonhacks 的仓库里有。这里我们就使用他的脚本文件。</p>
<a id="more"></a>

<h3 id="下载脚本"><a href="#下载脚本" class="headerlink" title="下载脚本"></a>下载脚本</h3><p>首先从 GitHub 上下载编译脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;jetsonhacks&#x2F;buildJetsonTX2Kernel.git</span><br></pre></td></tr></table></figure>
<p>如果你是 JetPack3.2.1 版本，直接使用 git 下载的话没有问题，因为目前他更新到的最新版本是 JetPack 3.2.1 内核版本为 28.2.1 (2018-8-20)。但是我安装的是 JetPack 3.1 对应的内核版本是 28.1 所以是不能直接使用的。因此需要下载对应的内核版本的脚本才可以使用。<br>JetPack 3.1 版本的话就需要下载这个。<br><code>https://github.com/jetsonhacks/buildJetsonTX2Kernel/archive/vL4T28.1.tar.gz</code></p>
<h3 id="解压，获取源码"><a href="#解压，获取源码" class="headerlink" title="解压，获取源码"></a>解压，获取源码</h3><p>下载好之后，解压缩，进入解压出来的文件夹，打开 Terminal 运行 getKernelSources.sh 脚本获取内核源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;getKernelSources.sh</span><br></pre></td></tr></table></figure>
<h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><p>下载完成之后就会打开一个 xconfig 配置界面。<br>设置你的镜像名称。打开设置 Genral Setup-&gt;Local version - append to kernel release，双击 Local version - append to kernel release<br>在文本框中输入名字，如我这里为 -jetsonbot-v0.1 ， 回车；如下图所示：<br><img src="https://photo.ishield.cn/pic/5b8269849dc6d6533b592669" alt=""></p>
<p>在 xconfig 中按 Ctrl+F ，会弹出一个搜索框，输入你想要添加的设备驱动，比如可以添加 USB ACM， CH341 和 cp210x 串口驱动等，在搜索结果中选择对应的驱动，选中框打上勾即可。<br>我这里搜索的是 ACM 驱动，如下图所示：<br><img src="https://photo.ishield.cn/pic/5b826b089dc6d6533b59266f" alt=""></p>
<p>设置好了之后，一定要保存你的设置， File-&gt;Save</p>
<h3 id="编译新内核"><a href="#编译新内核" class="headerlink" title="编译新内核"></a>编译新内核</h3><p>保存好设置，关闭 xconfig 配置窗口，准备开始编译内核，编译过程大约需要 20 分钟。<br>运行 makeKernel.sh 脚本，开始编译新的内核。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;makeKernel.sh</span><br></pre></td></tr></table></figure>

<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>编译过程中，你可以去喝杯 coffee 放松一下，等待编译完成。<br>编译结束后，运行 copyImage.sh 脚本，将新编译的镜像文件拷贝到  /boot 目录下。拷贝完成重启 TX2 即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;copyImage.sh</span><br><span class="line">$ reboot</span><br></pre></td></tr></table></figure>

<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>至此，我们添加有 USB 串口相关驱动的镜像就在 TX2 上被安装好了，这样就可以愉快的使用串口了。快使用新镜像进行开发吧！</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>Jetson TX2</tag>
        <tag>Nvidia</tag>
        <tag>内核编译</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>SDRAM 两次踏进同一条河</title>
    <url>//posts/SDRAM-%E4%B8%A4%E6%AC%A1%E8%B8%8F%E8%BF%9B%E5%90%8C%E4%B8%80%E6%9D%A1%E6%B2%B3.html</url>
    <content><![CDATA[<blockquote>
<p><em>人不能两次踏进同一条河，但 SDRAM 可以</em><br><em>——SDRAM的刷新</em></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周去了趟深圳，所以摸鱼拖更了，在那边发现真的是机遇越大的地方努力的脚步就越匆忙，某企业的 boss 是位国家科学技术奖的获得者，公司已经上市了，却依然吃 13 元的小店套餐，而且饭几乎是倒进嘴里的，5 分钟左右吃完马上就又去和合作对象谈判去了！<br>……<br>所以我们更要加油了，不然只会被大佬们越拉越远 …… 加油吧！</p>
<a id="more"></a>

<p>在初窥 sdram 中我们留了一个坑——首先我们在第一页就可以看到它的刷新周期是 64ms（这个重要参数将在后面进行具体介绍）<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/sdram_64ms.jpg" alt=""></p>
<p>今天我们就来填这个坑……</p>
<p>「人不能两次踏进同一条河流」是古希腊哲学家赫拉克利特说的。阐述「变」的哲学在米利都学派和毕达戈拉斯学派之后，爱菲斯的赫拉克利特创立了一种变的哲学。他的哲学充满了辩证法思想，对后来辩证法的发展产生过重大影响。</p>
<p>他形象地表达了他关于变的思想，说：「太阳每天都是新的。」他把存在的东西比作一条河，声称人不能两次踏进同一条河。因为当人第二次进入这条河时，是新的水流而不是原来的水流在流淌。SDRAM 不断地刷新，但却能保证刷新后的数据与刷新前一致，人踏进河是为什么我不知道，但是 SDRAM 正是为了保证内部电容的电量最终实现数据的不丢失才会不断地刷新。我们人做不到的事，就用 RTL 让 SDRAM 帮我们做了吧。</p>
<h2 id="参数分析"><a href="#参数分析" class="headerlink" title="参数分析"></a>参数分析</h2><p>首先我们来看 SDRAM 参数：8K Refresh Cycles/64 ms，意味着：</p>
<ul>
<li>刷新速率 = 64ms / 8192 行 =&gt; 7us；</li>
<li>刷新时钟周期 = 7us * CPU 运行频率；</li>
</ul>
<p>例：CPU 运行频率 50MHz 时钟周期 = 7.81us * 50MHz = 390.5；64ms 为刷新周期最大值，为保证可靠运行，实际刷新实间要稍小于 64ms；例：时钟周期 = 390.5 ≈ 380</p>
<p>这就意味着每 380 个时钟周期，我们便需要对我们的 SDRAM 进行一次刷新，那么进行刷新的时候需要进行哪些操作呢？我们还是回到我们的数据手册中。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/auto-refresh.jpg" alt=""></p>
<p>如图示，我们可以看到首先是要进行一次预充电操作(precharge)（同时选中所有的 bank），在经过 tRP 延时后进行一次自刷新操作(auto refresh)，再经过一次 tRC 后又进行一次自刷新操作(auto refresh)【注：实际使用中可以只进行一次自刷新操作】，最后进入到我们下一步 ……</p>
<p>那么根据第一篇《初窥 SDRAM》后我们知道以上的几个操作对应的指令码分别为：</p>
<table>
<thead>
<tr>
<th align="center">CMD</th>
<th align="center">CS</th>
<th align="center">RAS</th>
<th align="center">CAS</th>
<th align="center">WE</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Precharge</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">Auto-Refresh</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">Nop</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>延时 tRP，tRC 则分别对应 15ns（至少 1 个周期，实际操作中取 1 个周期），60ns （至少 3 个周期，实际操作中取 4 个周期）。</p>
<p>那么我们的设计即可为：一个 8us 的定时器，控制刷新的周期，作为刷新的开始信号；一个命令计数器，用于记录对应的延时节点（tRP，tRC）；最后即为达到对应节点输出对应指令即可。</p>
<p>由此踏进的河流变和 8us 前的河流是同一条河流的 ……</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>具体实现代码如下:<br>上代码！<br><font color=#FF4500 > <div><div class="fold_hider"><div class="close hider_title">sdram_autoref.v</div></div><div class="fold">
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File name: sdram_autoref</span></span><br><span class="line"><span class="comment">Function: Auto refresh for IS42S16320D-7TL SDRAM</span></span><br><span class="line"><span class="comment">Module name: sdram_autoref</span></span><br><span class="line"><span class="comment">Author: Ricky</span></span><br><span class="line"><span class="comment">Time: 20181130</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> sdram_autoref(</span><br><span class="line">	<span class="comment">//system signals</span></span><br><span class="line">	<span class="keyword">input</span>                   sys_clk    ,</span><br><span class="line">	<span class="keyword">input</span>                   sys_rst_n  ,</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//others</span></span><br><span class="line">	<span class="keyword">input</span>                   init_flag  ,</span><br><span class="line">	<span class="keyword">input</span>                   ref_en     ,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>              ref_req    ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>             ref_flag   ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>   [<span class="number">3</span>:<span class="number">0</span>]      cmd_reg    ,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>  [<span class="number">12</span>:<span class="number">0</span>] 	sdram_addr  	</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================================================================== </span></span><br><span class="line"><span class="comment">**********************Define Parameter and inside Signals***********************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Note: sys_clk=50MHz</span></span><br><span class="line"><span class="comment">      tRP|min=15ns &gt;&gt;&gt; 20ns &gt;&gt;&gt; 1sys_clk &gt;&gt;&gt; [4:0] cnt_cmd</span></span><br><span class="line"><span class="comment">      tRC|min=60ns &gt;&gt;&gt; 80ns &gt;&gt;&gt; 4sys_clk &gt;&gt;&gt; [4:0] cnt_cmd</span></span><br><span class="line"><span class="comment">      8K refresh cycles every 64ms &gt;&gt;&gt; 8us &gt;&gt;&gt; 380sys_clk</span></span><br><span class="line"><span class="comment">===============================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>]     cnt_cmd      ;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">8</span>:<span class="number">0</span>]     cnt_ref      ;</span><br><span class="line"><span class="keyword">reg</span>   	      flag_ref     ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">localparam</span> delay_8us = <span class="number">380</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//define sdram autorefresh cmd</span></span><br><span class="line"><span class="keyword">localparam</span>  precharge    = <span class="number">4'b0010</span>;</span><br><span class="line"><span class="keyword">localparam</span>  auto_refresh = <span class="number">4'b0001</span>;</span><br><span class="line"><span class="keyword">localparam</span>  nop          = <span class="number">4'b0111</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================================================================== </span></span><br><span class="line"><span class="comment">**********************************Main Logic************************************</span></span><br><span class="line"><span class="comment">==============================================================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//auto_refresh counter</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(~sys_rst_n)</span><br><span class="line">        cnt_ref &lt;= <span class="number">9'b0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt_ref &gt;= delay_8us)</span><br><span class="line">            cnt_ref &lt;= <span class="number">9'b0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(init_flag == <span class="number">1'b1</span>)</span><br><span class="line">            cnt_ref &lt;= cnt_ref + <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ref flag signal</span></span><br><span class="line"><span class="keyword">always</span>  @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(sys_rst_n == <span class="number">1'b0</span>)</span><br><span class="line">                flag_ref        &lt;=      <span class="number">1'b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ref_flag == <span class="number">1'b1</span>)</span><br><span class="line">                flag_ref        &lt;=      <span class="number">1'b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ref_en == <span class="number">1'b1</span>)</span><br><span class="line">                flag_ref        &lt;=      <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cmd counter</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(~sys_rst_n) </span><br><span class="line">        cnt_cmd &lt;= <span class="number">4'd0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (flag_ref == <span class="number">1'b1</span>)</span><br><span class="line">             cnt_cmd &lt;= cnt_cmd + <span class="number">1'b1</span>; </span><br><span class="line">    <span class="keyword">else</span>     cnt_cmd &lt;= <span class="number">4'b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cmd</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(~sys_rst_n) </span><br><span class="line">        cmd_reg &lt;= nop;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span>(cnt_cmd)</span><br><span class="line">            <span class="number">1</span>:       cmd_reg &lt;= precharge;</span><br><span class="line">            <span class="number">2</span>:       cmd_reg &lt;= auto_refresh;</span><br><span class="line">            <span class="number">6</span>:       cmd_reg &lt;= auto_refresh;</span><br><span class="line">            <span class="keyword">default</span>  cmd_reg &lt;= nop;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//request signal(8K refresh cycles every 64ms &gt;&gt;&gt; 8us &gt;&gt;&gt; 380sys_clk)</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n)<span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(~sys_rst_n)</span><br><span class="line">        ref_req &lt;= <span class="number">1'b0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ref_en)</span><br><span class="line">        ref_req &lt;= <span class="number">1'b0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt_ref &gt;= delay_8us)</span><br><span class="line">        ref_req &lt;= <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> sdram_addr = <span class="number">13'b0010000000000</span>;</span><br><span class="line"><span class="keyword">assign</span> ref_flag   = (cnt_cmd &gt;= <span class="number">9</span>)? <span class="number">1'b1</span> : <span class="number">1'b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</div></div><br></font></p>
<p>实现后我们可以看到毎 8us 完成一次所有 bank 的刷新</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/vsimrun.jpg" alt=""></p>
<h2 id="仿真波形"><a href="#仿真波形" class="headerlink" title="仿真波形"></a>仿真波形</h2><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/refresh-wave.jpg" alt=""><br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/refresh-wave1.jpg" alt=""></p>
<p><strong>By Ricky</strong></p>
]]></content>
      <categories>
        <category>IC Design</category>
        <category>SDRAM</category>
      </categories>
      <tags>
        <tag>IC Design</tag>
        <tag>SDRAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Nvidia Jetson TX2 刷机并安装JetPack3.1</title>
    <url>//posts/Nvidia-Jetson-TX2-%E5%88%B7%E6%9C%BA%E5%B9%B6%E5%AE%89%E8%A3%85JetPack3.1.html</url>
    <content><![CDATA[<h2 id="Nvidia-Jetson-TX2-刷机并安装-JetPack3-1"><a href="#Nvidia-Jetson-TX2-刷机并安装-JetPack3-1" class="headerlink" title="Nvidia Jetson TX2 刷机并安装 JetPack3.1"></a>Nvidia Jetson TX2 刷机并安装 JetPack3.1</h2><p>上篇，我已经简单介绍了一下我的整个小车的物理框架和软件架构。下面我可能会分成几次推文，介绍一下搭建小车的具体过程。<br>本次主要记录一下给 Nvidia Jetson TX2 开发板刷机的过程。</p>
<a id="more"></a>

<h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><p>1.一块Jetson TX2 开发板</p>
<p>2.一台安装 Ubuntu 系统的独立主机(不建议使用虚拟机，推荐使用 Ubuntu 16.04)</p>
<p>3.一台路由器</p>
<p>4.两根网线，一根 micro usb 数据线</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1.首先需要从 Nvidia 的官方网站上下载 Jet Pack3.1 的安装包，使用 Ubuntu host 直接下载或者下载好拷贝到 host 上也可以。(我当时最新的是 Jet Pack3.1 ，现在已经到 3.3 了，你也可以使用最新的版本。下载的话需要 Nvidia 账号才可以)<br>下载网址：<a href="https://developer.nvidia.com/embedded/jetpack" target="_blank" rel="noopener">https://developer.nvidia.com/embedded/jetpack</a></p>
<p>2.将 TX2 开发板和主机都通过网线连接到一台路由器上。准备好 TX2 开发板和 Ubuntu Host 之后就可以开始刷机了。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载好 Jet Pack3.1 安装包后，打开 Terminal 进入到安装包所在的目录，执行下面这条命令运行安装包。运行效果如下图。(如果文件没有执行权限可以使用 chmod -x file 命令来改变执行权限)</p>
<p><code>$
 ./JetPack-L4T-3.1-linux-x64.run</code></p>
<p>运行完会弹出 JetPack L4T 3.1 Installer, 一路 Next 就好，如下图：<br><img src="https://files.catbox.moe/n9dnwk.png" alt=""></p>
<p>注意选择 Jetson TX2 开发板<br><img src="https://photo.ishield.cn/pic/5b702af99dc6d6522bb72f67" alt=""></p>
<p>点击 Next 之后会提示输入密码，待安装完成后，就会进入 JetPack L4T Component Manager。(这里要注意，如果网络不好可能会要等很久也出不来安装包信息，所以一定要保证网络环境好，可能有一些包还需要科学上网。)<br>如果你的包加载好了，检查一下 CUDA Toolkit 和 OpenCV for Tegra 这两个包是否选择了，这两个一定要安装。选择好之后，点击 Next 。在弹出的弹框中勾选所有协议，等待各种包下载完成。<br><img src="https://photo.ishield.cn/pic/5b702c3e9dc6d6522bb72f6c" alt=""><br><img src="https://photo.ishield.cn/pic/5b702b289dc6d6522bb72f68" alt=""></p>
<p>下载完成后，选择 Host 和 TX2 的连接方式，我们选择第一项，通过同一路由器连接在同一网络。网口选择保持默认就好。<br><img src="https://files.catbox.moe/hvd0oi.png" alt=""></p>
<p>接下来就是将包移动到 TX2 开发板上。文件较大，可能要等一会。执行下一步后，会出现一个提示重启 TX2 的步骤。按照提示进行操作。</p>
<p>第一步，将 TX2 关机， 拔下电源，使用 micro usb 数据线将 TX2 与 Host 相连。</p>
<p>第二步，重新插上电源，启动 TX2 ，同时按住 rec 和 rst 两个按键两秒钟， 然后松开 rst 按键，按住 rec 按键 3 秒钟。</p>
<p>第三步，这时在 Host 端，重新打开一个 terminal，查看 usb 端口信息(使用命令 lsusb 就可以查看)，这时应该就可以看 ID 为 0955:7C18 的叫 Nvidia Corp 的端口，就说明 TX2 已经进入 REC 模式并和 host 连接好了，这时回到有重启步骤的窗口，按回车 Enter，就开始 TX2 固件更新了。<br><img src="https://photo.ishield.cn/pic/5b702bda9dc6d6522bb72f6a" alt=""><br><img src="https://photo.ishield.cn/pic/5b702bf19dc6d6522bb72f6b" alt=""></p>
<p>安装完成后 TX2 就会重新启动，然后接下来会进行 CUDA 等一些软件的安装。</p>
<p>至此，Nvidia TX2 的安装就基本完成了。就可以愉快的在 Jetson TX2 上进行开发啦！</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>在 TX2 上进行基本开发的环境就已经基本搭建好了，但是大型的开发可能 TX2 本身自带的 30 多个 G 内存可能是不够的，因此我们可能还需要一个容量较大的 SSD 来放系统。还有就是 TX2 开发板默认的镜像设置可能会有一些端口没有开放，为了跟好的开发，所以后面需要我们自己重新编译镜像。这些在后面我会继续介绍。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>Jetson TX2</tag>
        <tag>Nvidia</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title>读书</title>
    <url>//posts/%E8%AF%BB%E4%B9%A6.html</url>
    <content><![CDATA[<p>前段时间，自己陆陆续续收集和整理了，好多电子书，还买了一个Kindle。也买了好些书，可是到现在也没看几本。下半年还是要多读书，多写字，多赚钱！</p>
<p>这里简单列一下我的书单，我兴趣爱好广泛，所以读的书也就比较杂，姑且就简单分为两类吧！技术类的和消遣的书吧。</p>
<a id="more"></a>

<h3 id="技术类："><a href="#技术类：" class="headerlink" title="技术类："></a>技术类：</h3><h4 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h4><ul>
<li><input checked="" disabled="" type="checkbox"> OpenCV3编程入门</li>
<li><input checked="" disabled="" type="checkbox"> 低功耗蓝牙开发权威指南</li>
<li><input checked="" disabled="" type="checkbox"> Cortex-M3权威指南</li>
</ul>
<h4 id="在读"><a href="#在读" class="headerlink" title="在读"></a>在读</h4><ul>
<li><input disabled="" type="checkbox"> C和指针</li>
<li><input disabled="" type="checkbox"> C专家编程</li>
<li><input disabled="" type="checkbox"> C陷阱与缺陷</li>
</ul>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><ul>
<li><input disabled="" type="checkbox"> C++沉思录</li>
<li><input disabled="" type="checkbox"> 深入理解计算机系统</li>
<li><input disabled="" type="checkbox"> 程序员的数学 1，2，3</li>
<li><input disabled="" type="checkbox"> 信息简史</li>
<li><input disabled="" type="checkbox"> 大话设计模式</li>
<li><input disabled="" type="checkbox"> 计算机原理与设计：Verilog HDL版</li>
<li><input disabled="" type="checkbox"> 经典算法大全</li>
<li><input disabled="" type="checkbox"> 算法导论</li>
</ul>
<h3 id="消遣类："><a href="#消遣类：" class="headerlink" title="消遣类："></a>消遣类：</h3><h4 id="已读-1"><a href="#已读-1" class="headerlink" title="已读"></a>已读</h4><ul>
<li><input checked="" disabled="" type="checkbox"> 他改变了中国</li>
<li><input checked="" disabled="" type="checkbox"> 人类简史</li>
<li><input checked="" disabled="" type="checkbox"> 三体 I</li>
<li><input checked="" disabled="" type="checkbox"> 三体: 黑暗森林</li>
</ul>
<h4 id="在读-1"><a href="#在读-1" class="headerlink" title="在读"></a>在读</h4><ul>
<li><input disabled="" type="checkbox"> 三体: 死神永生</li>
<li><input disabled="" type="checkbox"> 浪潮之巅</li>
<li><input disabled="" type="checkbox"> 太阳的距离</li>
<li><input disabled="" type="checkbox"> 数学之美</li>
</ul>
<h4 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h4><ul>
<li><input disabled="" type="checkbox"> 未来简史</li>
<li><input disabled="" type="checkbox"> 宇宙最初三分钟</li>
<li><input disabled="" type="checkbox"> 爱因斯坦传</li>
<li><input disabled="" type="checkbox"> Alibaba 2017技术集锦</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>初窥 SDRAM</title>
    <url>//posts/%E5%88%9D%E7%AA%A5-SDRAM.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次挖的坑现在来填，在我们把 SDRAM 控制器接进 AHB 总线之前，我们先来设计一个 SDRAM 控制器。</p>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/hexo_img.jpg" alt=""></p>
<a id="more"></a>

<p>引用知乎上看见的一段话：</p>
<blockquote>
<p>在做这个 SDRAM 控制器之前，博主有一个疑问，对于学生来说，是否有必要学习用纯 Verilog 写一个 SDRAM 控制器？因为目前广告厂（X）和牙膏厂（A）都有了 DDR IP Core，而 SDRAM 的控制 IP 更是漫天飞舞，对于要实现一个应用可以直接调用 IP Core，只需要对其接口操作即可。对于开发者来说，与其费时费力用 Verilog 去写一个性能差而且老的 SDRAM 控制器，还不如直接调用官方经过打磨的更为先进 IP Core。所以博主特地来号称平均学历 211，平均月薪 7、8 万的知（bi）乎提出了这个问题，得到的解答博主总结大致如下。</p>
<p>对于学生这个身份来说，应该是要以学习为主要目的，虽然说目前企业为了加快项目进度会直接使用 IP Core，但是我们以学为本的初衷不应该为了避过难点而直接不去尝试，就比如我们刚开始学 Verilog 的时候肯定都会写过分频器，那么为什么不直接去学更简单精度更高 PLL IP Core 呢？从一个新手逐渐成长成一个老手都是由简单到复杂，由基础到提升，这是一个必经的过程。这也就是很多高校还是会开设汇编语言编写单片机的课程，学 FPGA 全用 IP Core 和学单片机全用库函数是一个道理。这是其一。</p>
<p>第二，写一个 SDRAM 控制器还是可以锻炼一些典型的技能。</p>
<ul>
<li>看官方文档</li>
<li>根据时序图设计 SDRAM 逻辑，使用状态机</li>
<li>配合仿真模型写测试仿真</li>
<li>调试，提高频率，让你的 SDRAM 跑的更快</li>
<li>研究时序约束</li>
</ul>
<p>这一套做下来，你就可以提高一个层次了，经历过和没经历过是有质的区别。其实博主在提问的时候心中早已有了答案，只是还没有足够的信念去完成这个事情，当时看到很多业界前辈都支持去写的时候，博主心里也是比较开心的。之前博主已经学一些 SDRAM 的基础知识，只是当时水平还不够，没有坚持下去，心里一直不甘。趁着最近两个月之内没有什么事情要忙，所以决定要再次死磕 SDRAM。</p>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="SDRAM-基本介绍"><a href="#SDRAM-基本介绍" class="headerlink" title="SDRAM 基本介绍"></a>SDRAM 基本介绍</h3><p>关于 SDRAM 的基本概念，在这再引用《终极内存指南》这篇文章中的一段话:</p>
<blockquote>
<p>SDRAM（Synchronous Dynamic Random Access Memory），同步动态随机存储器。同步是指 Memory 工作需要同步时钟，内部的命令的发送与数据的传输都以它为基准；动态是指存储阵列需要不断刷新来保证存储的数据不丢失，因为 SDRAM 中存储数据是通过电容来工作的，大家知道电容在自然放置状态是会有放电的，如果电放完了，也就意味着 SDRAM 中的数据丢失了，所以 SDRAM 需要在电容的电量放完之前进行刷新；随机是指数据不是线性依次存储，而是自由指定地址进行数据的读写。</p>
</blockquote>
<p>下面再简单看一下 SDRAM 的内部结构。<br>对于 SDRAM 的内容结构，就如同 Excel 的表格（如下图所示），即一个单元格就是一个存储地址。要确定具体的存储位置，只需要知道行地址（row-address ）和列地址（column address ）即可。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/Excel.jpg" alt="excel"></p>
<p>一个常见的 SDRAM 中的一个 BANK 就有如上图所示的 13 行 9 列，通常一个 SDRAM 中有 4 个 BANK，那么 SDRAM（DDR 类似）的计算公式就是：</p>
<blockquote>
<p>SDRAM(DDR容量) = 2^(row-address) × 2^(column-address) × 2^(bank-address) × datawidth<br>= 2^(row-address) × 2^(column-address) × bank数 × datawidth</p>
</blockquote>
<p>以 DE10-LITE 开发板板载的 SDRAM-IS42S16320D-7TL 为例，标称为 64MB。根据芯片手册（如下图所示）我们可以看见其行地址宽度为 13，列地址宽度为 9（此时数据位宽为 32），则根据公式我们可以算出其容量确实为 64MB</p>
<blockquote>
<p>2^13 × 2^9 × 4 × 32 = 536870912 b<br>⇒ 536870912 b ÷ 1024 = 524288 kb<br>⇒ 524288 kb ÷ 1024 = 512 Mb<br>⇒ 512 Mb ÷ 8 = 64 MB</p>
</blockquote>
<p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/DE10_lite_sdram.jpg" alt=""></p>
<h3 id="SDRAM-芯片介绍"><a href="#SDRAM-芯片介绍" class="headerlink" title="SDRAM 芯片介绍"></a>SDRAM 芯片介绍</h3><p>既然都打开了芯片手册（IS42S16320D-7TL），那就不要关上了，那我们再来看看芯片手册中的那些重要参数。<br>首先我们在第一页就可以看到它的刷新周期是 64ms（这个重要参数将在后面进行具体介绍）<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/sdram_64ms.jpg" alt=""></p>
<p>在上文中我们已经提到了该芯片的行地址和列地址，我们需要注意的是其行列地址是复用的，其他相关引脚的功能描述都有介绍。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/IS42S16320D_7TL_sdram.jpg" alt=""></p>
<h3 id="SDRAM-的初始化及寄存器的配置"><a href="#SDRAM-的初始化及寄存器的配置" class="headerlink" title="SDRAM 的初始化及寄存器的配置"></a>SDRAM 的初始化及寄存器的配置</h3><p>SDRAM 初始化时序图如图所示，首先上电后，电源 Vcc 及 CLK 稳定时间至少 100us，然后对所有 BANK 进行预充电（precharge），经过 tRP 后给 auto refresh 命令，再经过 tRC 后再次 auto refresh 命令，再进过 tRC 后进行模式寄存器的配置。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/sdram_%E6%97%B6%E5%BA%8F.jpg" alt=""></p>
<p>那么以上命令是如何实现的呢，当时就是给与相应管脚的高低电平控制，由此实现，那么这就回到了我们数电的功能真值表（在之前我们就有提到过，数字 IC 终归是数字电路，不要把它搞成了编程项目），我们将下图的真值表以使用顺序总结为表格形式，方便接下来的 RTL 表述。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/%E7%9C%9F%E5%80%BC%E8%A1%A8.jpg" alt=""></p>
<table>
<thead>
<tr>
<th align="center">CMD</th>
<th align="center">CS</th>
<th align="center">RAS</th>
<th align="center">CAS</th>
<th align="center">WE</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Precharge</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">Auto-Refresh</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">Nop</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">Mode</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>在了解到命令描述后我们还需要注意时间的间隔，在时序图中只告知了我们 T = 100us，而其余的 tRP，tRC，tMRD 均未告诉我们，这是因为通常一个芯片手册中有多种型号的芯片，因此我们需要去查看 AC characteristic 表格，根据芯片型号去确定时间。我们的板载芯片型号为 IS42S16320D-7TL，因此我们选择 <code>-7</code> 对应的时间，则 tRP = 15ns，tRC = 60ns，tMRD = 14ns</p>
<p>接下来我们就要进入到模式配置，模式配置的配置说明如下图所示：<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/Mode_reg_config.jpg" alt=""></p>
<p>A0-A2 为突发长度控制，即表示单次读或者写的时候的数据『长度』，本次突发长度参数我们设为 010。A3 突发模式通常设为 0。A4-A6 为潜伏期控制，专门针对读命令时，当给出读命令后，若有设置 CAS latency 则会延迟相应的周期数后给出数据，本次潜伏期参数我们设为 011，A9 突发模式通常设为 0。则最终我们初始化设置参数为 13’b0_0000_0011_0010</p>
<p>至此，我们便可以开始着手设计我们的初始化模块了，首先时序图上 T = 100us Min，则我们取 200us = 200,000ns 在不经过 PLL 的前提下，DE10LITE 开发板默认提供的时钟频率为 50MHz，则一个周期为 20ns，因此 T 延时可以取 10,000clk。延时后我们执行 precharge 命令。之后执行 tRP = 15ns Min，我们的 tRP 延迟就可以取 1clk（至少满足 15ns 的最低要求），然后执行 auto refresh 命令，tRC = 60ns Min 则延迟可取为 4clk，然后再次执行 auto refresh 命令，在这期间一共 9 个 clk。具体的设计可以首先设计一个 200us 的不自清零的计数器；设计一个对应的 200us 计数器标志位；针对 tRP 和 tRC 设计一个计数器，分别实现监测计数到对应的周期发出对应的命令；命令寄存器用来存放对应的命令；最后完成初始化操作后给一个初始化完成的标志位信号。</p>
<p>下面是具体实现的描述语言：<br><font color=#FF4500 > <div><div class="fold_hider"><div class="close hider_title">sdram_init.v</div></div><div class="fold">
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File name: sdram_init</span></span><br><span class="line"><span class="comment">Function: Power on initialization for IS42S16320D-7TL SDRAM</span></span><br><span class="line"><span class="comment">Module name: sdram_init</span></span><br><span class="line"><span class="comment">Author: Ricky</span></span><br><span class="line"><span class="comment">Time: 20181119</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> sdram_init(</span><br><span class="line">	<span class="comment">//system signals</span></span><br><span class="line">	<span class="keyword">input</span>					sys_clk				,</span><br><span class="line">	<span class="keyword">input</span>					sys_rst_n			,</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//others</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span>		    [<span class="number">3</span>:<span class="number">0</span>] 	cmd_reg				,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>		    [<span class="number">12</span>:<span class="number">0</span>] 	sdram_addr			,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>				init_flag</span><br><span class="line">	</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================================================================== </span></span><br><span class="line"><span class="comment">**********************Define Parameter and inside Signals***********************</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Note: 	syssys_clk=50MHz</span></span><br><span class="line"><span class="comment">		T|min=100us &gt;&gt;&gt; 200us=200,000ns &gt;&gt;&gt; 10,000sys_clk &gt;&gt;&gt; [13:0] cnt_200us</span></span><br><span class="line"><span class="comment">		tRP|min=15ns &gt;&gt;&gt; 20ns &gt;&gt;&gt; 1sys_clk &gt;&gt;&gt; [4:0] cnt_cmd</span></span><br><span class="line"><span class="comment">		tRC|min=60ns &gt;&gt;&gt; 80ns &gt;&gt;&gt; 4sys_clk &gt;&gt;&gt; [4:0] cnt_cmd</span></span><br><span class="line"><span class="comment">===============================================================================*/</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">13</span>:<span class="number">0</span>] 		cnt_200us		;</span><br><span class="line"><span class="keyword">wire</span> 			cnt_200us_flag	;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>]		cnt_cmd			;</span><br><span class="line"></span><br><span class="line"><span class="comment">//define sdram initial cmd</span></span><br><span class="line"><span class="keyword">localparam</span>		precharge    = <span class="number">4'b0010</span>;</span><br><span class="line"><span class="keyword">localparam</span>		auto_refresh = <span class="number">4'b0001</span>;</span><br><span class="line"><span class="keyword">localparam</span>		nop			 = <span class="number">4'b0111</span>;</span><br><span class="line"><span class="keyword">localparam</span> 		modeset		 = <span class="number">4'b0000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================================================================== </span></span><br><span class="line"><span class="comment">**********************************Main Logic************************************</span></span><br><span class="line"><span class="comment">==============================================================================*/</span></span><br><span class="line"><span class="comment">//T=200us  counter</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(~sys_rst_n)</span><br><span class="line">		cnt_200us &lt;= <span class="number">13'd0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span>(cnt_200us_flag == <span class="number">1'b0</span>)</span><br><span class="line">			cnt_200us &lt;= cnt_200us + <span class="number">1'b1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cnt_200us &lt;= cnt_200us;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cmd counter</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(~sys_rst_n) </span><br><span class="line">		cnt_cmd &lt;= <span class="number">4'd0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span> (cnt_200us_flag == <span class="number">1'b1</span> &amp;&amp; init_flag == <span class="number">1'b0</span>)</span><br><span class="line">			cnt_cmd &lt;= cnt_cmd + <span class="number">1'b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cmd</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> sys_clk <span class="keyword">or</span> <span class="keyword">negedge</span> sys_rst_n) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(~sys_rst_n) </span><br><span class="line">		cmd_reg &lt;= nop;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span>(cnt_200us_flag == <span class="number">1'b1</span>)</span><br><span class="line">			<span class="keyword">case</span>(cnt_cmd)</span><br><span class="line">				<span class="number">0</span>: 			cmd_reg &lt;= precharge	;</span><br><span class="line">				<span class="number">1</span>: 			cmd_reg &lt;= auto_refresh	;</span><br><span class="line">				<span class="number">5</span>: 			cmd_reg &lt;= auto_refresh	;</span><br><span class="line">				<span class="number">9</span>: 			cmd_reg &lt;= modeset	;</span><br><span class="line">				<span class="keyword">default</span>: 	        cmd_reg &lt;= nop		;</span><br><span class="line">			<span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> cnt_200us_flag = (cnt_200us &gt;= <span class="number">10000</span>) ? <span class="number">1'b1</span>:<span class="number">1'b0</span>;</span><br><span class="line"><span class="keyword">assign</span> init_flag = (cnt_cmd &gt;= <span class="number">9</span>) ? <span class="number">1'b1</span>:<span class="number">1'b0</span>;</span><br><span class="line"><span class="keyword">assign</span> sdram_addr = (cmd_reg == modeset) ? <span class="number">13'b0000000110010</span> : <span class="number">13'b0010000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</div></div><br></font></p>
<p><font color=#FF4500 > <div><div class="fold_hider"><div class="close hider_title">sdram_top.v</div></div><div class="fold">
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">File name: sdram_top</span></span><br><span class="line"><span class="comment">Author: Ricky</span></span><br><span class="line"><span class="comment">Time: 20181121</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">module</span> sdram(</span><br><span class="line">	<span class="comment">//system signals</span></span><br><span class="line">	<span class="keyword">input</span>			sys_clk			,</span><br><span class="line">	<span class="keyword">input</span>			sys_rst_n		,</span><br><span class="line">	<span class="comment">//sdram pin</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>		sdram_clk		,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>     [<span class="number">12</span>:<span class="number">0</span>]	sdram_addr		,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>     [<span class="number">1</span>:<span class="number">0</span>] 	sdram_bank		,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>		sdram_cas_n		,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>		sdram_cke		,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>		sdram_cs_n		,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>	[<span class="number">1</span>:<span class="number">0</span>]	sdram_dqm		,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>		sdram_ras_n		,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">wire</span>		sdram_we_n		,</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">inout</span>		[<span class="number">15</span>:<span class="number">0</span>]	sdram_dq</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================================================================== </span></span><br><span class="line"><span class="comment">**********************Define Parameter and inside Signals***********************</span></span><br><span class="line"><span class="comment">===============================================================================*/</span></span><br><span class="line"><span class="keyword">wire</span> init_flag		;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] init_cmd_reg	;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">12</span>:<span class="number">0</span>] init_addr	;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*============================================================================== </span></span><br><span class="line"><span class="comment">**********************************Main Logic************************************</span></span><br><span class="line"><span class="comment">==============================================================================*/</span></span><br><span class="line"><span class="keyword">assign</span> sdram_addr = init_addr;</span><br><span class="line"><span class="keyword">assign</span> &#123;sdram_cs_n, sdram_ras_n, sdram_cas_n, sdram_we_n&#125; = init_cmd_reg;</span><br><span class="line"><span class="keyword">assign</span> sdram_clk = ~sys_clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> sdram_dqm = <span class="number">2'b00</span>;</span><br><span class="line"><span class="keyword">assign</span> sdram_cke = <span class="number">1'b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//instantiating sdram_init module</span></span><br><span class="line">sdram_init sdram_init(</span><br><span class="line">	<span class="comment">//system signals</span></span><br><span class="line">	.		sys_clk			(sys_clk)			,</span><br><span class="line">	.		sys_rst_n		(sys_rst_n)			,</span><br><span class="line">		<span class="comment">//others</span></span><br><span class="line">	.		cmd_reg			(init_cmd_reg)		,</span><br><span class="line">	.		sdram_addr		(init_addr)			,</span><br><span class="line">	.		init_flag       (init_flag)</span><br><span class="line">	</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</div></div><br></font></p>
<p><font color=#FF4500 > <div><div class="fold_hider"><div class="close hider_title">sdram_tb.v</div></div><div class="fold">
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File name: sdram_tb</span></span><br><span class="line"><span class="comment">Function: Testbench for power on initialization for IS42S16320D-7TL SDRAM</span></span><br><span class="line"><span class="comment">Author: Ricky</span></span><br><span class="line"><span class="comment">Time: 20181123</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> sdram_tb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>			sys_clk;</span><br><span class="line"><span class="keyword">reg</span> 		sys_rst_n;</span><br><span class="line"><span class="keyword">wire</span>				sdram_clk		;</span><br><span class="line"><span class="keyword">wire</span>		[<span class="number">12</span>:<span class="number">0</span>]	sdram_addr		;</span><br><span class="line"><span class="keyword">wire</span> 		[<span class="number">1</span>:<span class="number">0</span>] 	sdram_bank		;</span><br><span class="line"><span class="keyword">wire</span>				sdram_cas_n		;</span><br><span class="line"><span class="keyword">wire</span>				sdram_cke		;</span><br><span class="line"><span class="keyword">wire</span>				sdram_cs_n		;	</span><br><span class="line"><span class="keyword">wire</span>		[<span class="number">1</span>:<span class="number">0</span>]	sdram_dqm		;</span><br><span class="line"><span class="keyword">wire</span>				sdram_ras_n		;</span><br><span class="line"><span class="keyword">wire</span>				sdram_we_n		;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span>		[<span class="number">15</span>:<span class="number">0</span>]	sdram_dq		;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">	sys_clk = <span class="number">1</span>;</span><br><span class="line">	sys_rst_n &lt;= <span class="number">0</span>;</span><br><span class="line">	#<span class="number">100</span></span><br><span class="line">	sys_rst_n &lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 20ns/clock</span></span><br><span class="line"><span class="keyword">always</span> #<span class="number">10</span> sys_clk = ~sys_clk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* defparam	sdram_model_plus.addr_bits =	13			;</span></span><br><span class="line"><span class="comment">defparam	sdram_model_plus.data_bits = 	16			;	</span></span><br><span class="line"><span class="comment">defparam	sdram_model_plus.col_bits  =	9 			;</span></span><br><span class="line"><span class="comment">defparam	sdram_model_plus.mem_sizes =	2*1024*1024	; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//instantiating sdram_init module</span></span><br><span class="line">sdram sdraminit(</span><br><span class="line">	<span class="comment">//system signals</span></span><br><span class="line">	<span class="variable">.sys_clk</span>                 (sys_clk  )		,</span><br><span class="line">	<span class="variable">.sys_rst_n</span>               (sys_rst_n)		,</span><br><span class="line">	<span class="comment">//sdram pin</span></span><br><span class="line">	<span class="variable">.sdram_clk</span>               (sdram_clk)		,</span><br><span class="line">	<span class="variable">.sdram_addr</span>              (sdram_addr)		,</span><br><span class="line">	<span class="variable">.sdram_bank</span>              (sdram_bank)		,</span><br><span class="line">	<span class="variable">.sdram_cas_n</span>             (sdram_cas_n)		,</span><br><span class="line">	<span class="variable">.sdram_cke</span>               (sdram_cke)		,	</span><br><span class="line">	<span class="variable">.sdram_cs_n</span>              (sdram_cs_n)		,</span><br><span class="line">	<span class="variable">.sdram_dqm</span>               (sdram_dqm)		,</span><br><span class="line">	<span class="variable">.sdram_ras_n</span>             (sdram_ras_n)		,</span><br><span class="line">	<span class="variable">.sdram_we_n</span>              (sdram_we_n)		,</span><br><span class="line">	</span><br><span class="line">	<span class="variable">.sdram_dq</span>                 (sdram_dq)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//instantiating sdram_model module</span></span><br><span class="line">sdram_model_plus sdram(</span><br><span class="line">	<span class="variable">.Dq</span>					(sdram_dq)				, </span><br><span class="line">	<span class="variable">.Addr</span>				(sdram_addr)			, </span><br><span class="line">	<span class="variable">.Ba</span>					(sdram_bank)			, </span><br><span class="line">	<span class="variable">.Clk</span>				(sdram_clk)				, </span><br><span class="line">	<span class="variable">.Cke</span>				(sdram_cke)				, </span><br><span class="line">	<span class="variable">.Cs_n</span>				(sdram_cs_n)			, </span><br><span class="line">	<span class="variable">.Ras_n</span>				(sdram_ras_n)			, </span><br><span class="line">	<span class="variable">.Cas_n</span>				(sdram_cas_n)			, </span><br><span class="line">	<span class="variable">.We_n</span>				(sdram_we_n)			, </span><br><span class="line">	<span class="variable">.Dqm</span>				(sdram_dqm)				,</span><br><span class="line">	<span class="variable">.Debug</span>				(<span class="number">1'b1</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</div></div><br></font></p>
<p>仿真模型（见附件）一共有两个分别是镁光官方仿真模型以及国内大神基于镁光模型进行修改后便于调试的版本，使用任意一版均可。这里我采用的是 sdram_model.v</p>
<p><font color=#FF4500 > <div><div class="fold_hider"><div class="close hider_title">sdram_model.v</div></div><div class="fold">
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************************************************************</span></span><br><span class="line"><span class="comment">作者：    李晟</span></span><br><span class="line"><span class="comment">2003-08-27    V0.1    李晟 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 添加内存模块倒空功能，在外部需要创建事件：sdram_r ,本SDRAM的内容将会按Bank 顺序damp out 至文件</span></span><br><span class="line"><span class="comment"> sdram_data.txt 中</span></span><br><span class="line"><span class="comment">×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*/</span></span><br><span class="line"><span class="comment">//2004-03-04    陈乃奎    修改原程序中将BANK的数据转存入TXT文件的格式</span></span><br><span class="line"><span class="comment">//2004-03-16    陈乃奎    修改SDRAM 的初始化数据</span></span><br><span class="line"><span class="comment">//2004/04/06    陈乃奎    将SDRAM的操作命令以字符形式表示，以便用MODELSIM监视</span></span><br><span class="line"><span class="comment">//2004/04/19    陈乃奎    修改参数 parameter tAC  =   8;</span></span><br><span class="line"><span class="comment">//2010/09/17    罗瑶    修改sdram的大小，数据位宽，dqm宽度;</span></span><br><span class="line"><span class="comment">/****************************************************************************************</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*    File Name:  sdram_model.V  </span></span><br><span class="line"><span class="comment">*      Version:  0.0f</span></span><br><span class="line"><span class="comment">*         Date:  July 8th, 1999</span></span><br><span class="line"><span class="comment">*        Model:  BUS Functional</span></span><br><span class="line"><span class="comment">*    Simulator:  Model Technology (PC version 5.2e PE)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Dependencies:  None</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*       Author:  Son P. Huynh</span></span><br><span class="line"><span class="comment">*        Email:  sphuynh@micron.com</span></span><br><span class="line"><span class="comment">*        Phone:  (208) 368-3825</span></span><br><span class="line"><span class="comment">*      Company:  Micron Technology, Inc.</span></span><br><span class="line"><span class="comment">*        Model:  sdram_model (1Meg x 16 x 4 Banks)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  Description:  64Mb SDRAM Verilog model</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Limitation:  - Doesn't check for 4096 cycle refresh</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*         Note:  - Set simulator resolution to "ps" accuracy</span></span><br><span class="line"><span class="comment">*                - Set Debug = 0 to disable $display messages</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   Disclaimer:  THESE DESIGNS ARE PROVIDED "AS IS" WITH NO WARRANTY </span></span><br><span class="line"><span class="comment">*                WHATSOEVER AND MICRON SPECIFICALLY DISCLAIMS ANY </span></span><br><span class="line"><span class="comment">*                IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR</span></span><br><span class="line"><span class="comment">*                A PARTICULAR PURPOSE, OR AGAINST INFRINGEMENT.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*                Copyright ?1998 Micron Semiconductor Products, Inc.</span></span><br><span class="line"><span class="comment">*                All rights researved</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Rev   Author          Phone         Date        Changes</span></span><br><span class="line"><span class="comment">* ----  ----------------------------  ----------  ---------------------------------------</span></span><br><span class="line"><span class="comment">* 0.0f  Son Huynh       208-368-3825  07/08/1999  - Fix tWR = 1 Clk + 7.5 ns (Auto)</span></span><br><span class="line"><span class="comment">*       Micron Technology Inc.                    - Fix tWR = 15 ns (Manual)</span></span><br><span class="line"><span class="comment">*                                                 - Fix tRP (Autoprecharge to AutoRefresh)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 0.0a  Son Huynh       208-368-3825  05/13/1998  - First Release (from 64Mb rev 0.0e)</span></span><br><span class="line"><span class="comment">*       Micron Technology Inc.</span></span><br><span class="line"><span class="comment">****************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns / 100ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> sdram_model_plus (Dq, Addr, Ba, Clk, Cke, Cs_n, Ras_n, Cas_n, We_n, Dqm,Debug);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> addr_bits =    <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">parameter</span> data_bits =    <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">parameter</span> col_bits  =    <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">parameter</span> mem_sizes =    <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span> -<span class="number">1</span>;<span class="comment">//1 Meg </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inout</span>     [data_bits - <span class="number">1</span> : <span class="number">0</span>] Dq;</span><br><span class="line">    <span class="keyword">input</span>     [addr_bits - <span class="number">1</span> : <span class="number">0</span>] Addr;</span><br><span class="line">    <span class="keyword">input</span>                 [<span class="number">1</span> : <span class="number">0</span>] Ba;</span><br><span class="line">    <span class="keyword">input</span>                         Clk;</span><br><span class="line">    <span class="keyword">input</span>                         Cke;</span><br><span class="line">    <span class="keyword">input</span>                         Cs_n;</span><br><span class="line">    <span class="keyword">input</span>                         Ras_n;</span><br><span class="line">    <span class="keyword">input</span>                         Cas_n;</span><br><span class="line">    <span class="keyword">input</span>                         We_n;</span><br><span class="line">    <span class="keyword">input</span>                 [<span class="number">1</span> : <span class="number">0</span>] Dqm;          <span class="comment">//高低各8bit</span></span><br><span class="line">    <span class="comment">//added by xzli</span></span><br><span class="line">    <span class="keyword">input</span>              Debug;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>       [data_bits - <span class="number">1</span> : <span class="number">0</span>] Bank0 [<span class="number">0</span> : mem_sizes];<span class="comment">//存储器类型数据</span></span><br><span class="line">    <span class="keyword">reg</span>       [data_bits - <span class="number">1</span> : <span class="number">0</span>] Bank1 [<span class="number">0</span> : mem_sizes];</span><br><span class="line">    <span class="keyword">reg</span>       [data_bits - <span class="number">1</span> : <span class="number">0</span>] Bank2 [<span class="number">0</span> : mem_sizes];</span><br><span class="line">    <span class="keyword">reg</span>       [data_bits - <span class="number">1</span> : <span class="number">0</span>] Bank3 [<span class="number">0</span> : mem_sizes];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>                   [<span class="number">1</span> : <span class="number">0</span>] Bank_addr [<span class="number">0</span> : <span class="number">3</span>];                <span class="comment">// Bank Address Pipeline</span></span><br><span class="line">    <span class="keyword">reg</span>        [col_bits - <span class="number">1</span> : <span class="number">0</span>] Col_addr [<span class="number">0</span> : <span class="number">3</span>];                 <span class="comment">// Column Address Pipeline</span></span><br><span class="line">    <span class="keyword">reg</span>                   [<span class="number">3</span> : <span class="number">0</span>] Command [<span class="number">0</span> : <span class="number">3</span>];                  <span class="comment">// Command Operation Pipeline</span></span><br><span class="line">    <span class="keyword">reg</span>                   [<span class="number">3</span> : <span class="number">0</span>] Dqm_reg0, Dqm_reg1;               <span class="comment">// DQM Operation Pipeline</span></span><br><span class="line">    <span class="keyword">reg</span>       [addr_bits - <span class="number">1</span> : <span class="number">0</span>] B0_row_addr, B1_row_addr, B2_row_addr, B3_row_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>       [addr_bits - <span class="number">1</span> : <span class="number">0</span>] Mode_reg;</span><br><span class="line">    <span class="keyword">reg</span>       [data_bits - <span class="number">1</span> : <span class="number">0</span>] Dq_reg, Dq_dqm;</span><br><span class="line">    <span class="keyword">reg</span>       [col_bits - <span class="number">1</span> : <span class="number">0</span>] Col_temp, Burst_counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>                           Act_b0, Act_b1, Act_b2, Act_b3;   <span class="comment">// Bank Activate</span></span><br><span class="line">    <span class="keyword">reg</span>                           Pc_b0, Pc_b1, Pc_b2, Pc_b3;       <span class="comment">// Bank Precharge</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>                   [<span class="number">1</span> : <span class="number">0</span>] Bank_precharge     [<span class="number">0</span> : <span class="number">3</span>];       <span class="comment">// Precharge Command</span></span><br><span class="line">    <span class="keyword">reg</span>                           A10_precharge      [<span class="number">0</span> : <span class="number">3</span>];       <span class="comment">// Addr[10] = 1 (All banks)</span></span><br><span class="line">    <span class="keyword">reg</span>                           Auto_precharge     [<span class="number">0</span> : <span class="number">3</span>];       <span class="comment">// RW AutoPrecharge (Bank)</span></span><br><span class="line">    <span class="keyword">reg</span>                           Read_precharge     [<span class="number">0</span> : <span class="number">3</span>];       <span class="comment">// R  AutoPrecharge</span></span><br><span class="line">    <span class="keyword">reg</span>                           Write_precharge    [<span class="number">0</span> : <span class="number">3</span>];       <span class="comment">//  W AutoPrecharge</span></span><br><span class="line">    <span class="keyword">integer</span>                       Count_precharge    [<span class="number">0</span> : <span class="number">3</span>];       <span class="comment">// RW AutoPrecharge (Counter)</span></span><br><span class="line">    <span class="keyword">reg</span>                           RW_interrupt_read  [<span class="number">0</span> : <span class="number">3</span>];       <span class="comment">// RW Interrupt Read with Auto Precharge</span></span><br><span class="line">    <span class="keyword">reg</span>                           RW_interrupt_write [<span class="number">0</span> : <span class="number">3</span>];       <span class="comment">// RW Interrupt Write with Auto Precharge</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>                           Data_in_enable;</span><br><span class="line">    <span class="keyword">reg</span>                           Data_out_enable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>                   [<span class="number">1</span> : <span class="number">0</span>] Bank, Previous_bank;</span><br><span class="line">    <span class="keyword">reg</span>       [addr_bits - <span class="number">1</span> : <span class="number">0</span>] Row;</span><br><span class="line">    <span class="keyword">reg</span>        [col_bits - <span class="number">1</span> : <span class="number">0</span>] Col, Col_brst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Internal system clock</span></span><br><span class="line">    <span class="keyword">reg</span>                           CkeZ, Sys_clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">24</span>:<span class="number">0</span>]    dd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Commands Decode</span></span><br><span class="line">    <span class="keyword">wire</span>      Active_enable    = ~Cs_n &amp; ~Ras_n &amp;  Cas_n &amp;  We_n;</span><br><span class="line">    <span class="keyword">wire</span>      Aref_enable      = ~Cs_n &amp; ~Ras_n &amp; ~Cas_n &amp;  We_n;</span><br><span class="line">    <span class="keyword">wire</span>      Burst_term       = ~Cs_n &amp;  Ras_n &amp;  Cas_n &amp; ~We_n;</span><br><span class="line">    <span class="keyword">wire</span>      Mode_reg_enable  = ~Cs_n &amp; ~Ras_n &amp; ~Cas_n &amp; ~We_n;</span><br><span class="line">    <span class="keyword">wire</span>      Prech_enable     = ~Cs_n &amp; ~Ras_n &amp;  Cas_n &amp; ~We_n;</span><br><span class="line">    <span class="keyword">wire</span>      Read_enable      = ~Cs_n &amp;  Ras_n &amp; ~Cas_n &amp;  We_n;</span><br><span class="line">    <span class="keyword">wire</span>      Write_enable     = ~Cs_n &amp;  Ras_n &amp; ~Cas_n &amp; ~We_n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Burst Length Decode</span></span><br><span class="line">    <span class="keyword">wire</span>      Burst_length_1   = ~Mode_reg[<span class="number">2</span>] &amp; ~Mode_reg[<span class="number">1</span>] &amp; ~Mode_reg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">wire</span>      Burst_length_2   = ~Mode_reg[<span class="number">2</span>] &amp; ~Mode_reg[<span class="number">1</span>] &amp;  Mode_reg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">wire</span>      Burst_length_4   = ~Mode_reg[<span class="number">2</span>] &amp;  Mode_reg[<span class="number">1</span>] &amp; ~Mode_reg[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">wire</span>      Burst_length_8   = ~Mode_reg[<span class="number">2</span>] &amp;  Mode_reg[<span class="number">1</span>] &amp;  Mode_reg[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CAS Latency Decode</span></span><br><span class="line">    <span class="keyword">wire</span>      Cas_latency_2    = ~Mode_reg[<span class="number">6</span>] &amp;  Mode_reg[<span class="number">5</span>] &amp; ~Mode_reg[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">wire</span>      Cas_latency_3    = ~Mode_reg[<span class="number">6</span>] &amp;  Mode_reg[<span class="number">5</span>] &amp;  Mode_reg[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write Burst Mode</span></span><br><span class="line">    <span class="keyword">wire</span>      Write_burst_mode = Mode_reg[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span>      Debug;        <span class="comment">// Debug messages : 1 = On; 0 = Off</span></span><br><span class="line">    <span class="keyword">wire</span>      Dq_chk           = Sys_clk &amp; Data_in_enable;      <span class="comment">// Check setup/hold time for DQ</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span>        [<span class="number">31</span>:<span class="number">0</span>]    mem_d;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">event</span>    sdram_r,sdram_w,compare;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">assign</span>    Dq               = Dq_reg;                        <span class="comment">// DQ buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Commands Operation</span></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">define</span>   ACT       0</span></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">define</span>   NOP       1</span></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">define</span>   READ      2</span></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">define</span>   READ_A    3</span></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">define</span>   WRITE     4</span></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">define</span>   WRITE_A   5</span></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">define</span>   PRECH     6</span></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">define</span>   A_REF     7</span></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">define</span>   BST       8</span></span><br><span class="line">    <span class="meta">`<span class="meta-keyword">define</span>   LMR       9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    // Timing Parameters for -75 (PC133) and CAS Latency = 2</span></span><br><span class="line"><span class="comment">//    parameter tAC  =   8;    //test 6.5</span></span><br><span class="line"><span class="comment">//    parameter tHZ  =   7.0;</span></span><br><span class="line"><span class="comment">//    parameter tOH  =   2.7;</span></span><br><span class="line"><span class="comment">//    parameter tMRD =   2.0;     // 2 Clk Cycles</span></span><br><span class="line"><span class="comment">//    parameter tRAS =  44.0;</span></span><br><span class="line"><span class="comment">//    parameter tRC  =  66.0;</span></span><br><span class="line"><span class="comment">//    parameter tRCD =  20.0;</span></span><br><span class="line"><span class="comment">//    parameter tRP  =  20.0;</span></span><br><span class="line"><span class="comment">//    parameter tRRD =  15.0;</span></span><br><span class="line"><span class="comment">//    parameter tWRa =   7.5;     // A2 Version - Auto precharge mode only (1 Clk + 7.5 ns)</span></span><br><span class="line"><span class="comment">//    parameter tWRp =  0.0;     // A2 Version - Precharge mode only (15 ns)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Timing Parameters for -7 (PC143) and CAS Latency = 3</span></span><br><span class="line">    <span class="keyword">parameter</span> tAC  =   <span class="number">6</span><span class="variable">.5</span>;    <span class="comment">//test 6.5</span></span><br><span class="line">    <span class="keyword">parameter</span> tHZ  =   <span class="number">5</span><span class="variable">.5</span>;</span><br><span class="line">    <span class="keyword">parameter</span> tOH  =   <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">parameter</span> tMRD =   <span class="number">2</span><span class="variable">.0</span>;     <span class="comment">// 2 Clk Cycles</span></span><br><span class="line">    <span class="keyword">parameter</span> tRAS =  <span class="number">48</span><span class="variable">.0</span>;</span><br><span class="line">    <span class="keyword">parameter</span> tRC  =  <span class="number">70</span><span class="variable">.0</span>;</span><br><span class="line">    <span class="keyword">parameter</span> tRCD =  <span class="number">20</span><span class="variable">.0</span>;</span><br><span class="line">    <span class="keyword">parameter</span> tRP  =  <span class="number">20</span><span class="variable">.0</span>;</span><br><span class="line">    <span class="keyword">parameter</span> tRRD =  <span class="number">14</span><span class="variable">.0</span>;</span><br><span class="line">    <span class="keyword">parameter</span> tWRa =   <span class="number">7</span><span class="variable">.5</span>;     <span class="comment">// A2 Version - Auto precharge mode only (1 Clk + 7.5 ns)</span></span><br><span class="line">    <span class="keyword">parameter</span> tWRp =  <span class="number">0</span><span class="variable">.0</span>;     <span class="comment">// A2 Version - Precharge mode only (15 ns)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Timing Check variable</span></span><br><span class="line">    <span class="keyword">integer</span>   MRD_chk;</span><br><span class="line">    <span class="keyword">integer</span>   WR_counter [<span class="number">0</span> : <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">time</span>      WR_chk [<span class="number">0</span> : <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">time</span>      RC_chk, RRD_chk;</span><br><span class="line">    <span class="keyword">time</span>      RAS_chk0, RAS_chk1, RAS_chk2, RAS_chk3;</span><br><span class="line">    <span class="keyword">time</span>      RCD_chk0, RCD_chk1, RCD_chk2, RCD_chk3;</span><br><span class="line">    <span class="keyword">time</span>      RP_chk0, RP_chk1, RP_chk2, RP_chk3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span>    test_file;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//*****display the command of the sdram**************************************</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">parameter</span>    Mode_Reg_Set    =<span class="number">4'b0000</span>;</span><br><span class="line">    <span class="keyword">parameter</span>    Auto_Refresh    =<span class="number">4'b0001</span>;</span><br><span class="line">    <span class="keyword">parameter</span>    Row_Active    =<span class="number">4'b0011</span>;</span><br><span class="line">    <span class="keyword">parameter</span>    Pre_Charge    =<span class="number">4'b0010</span>;</span><br><span class="line">    <span class="keyword">parameter</span>    PreCharge_All    =<span class="number">4'b0010</span>;</span><br><span class="line">    <span class="keyword">parameter</span>    Write        =<span class="number">4'b0100</span>;</span><br><span class="line">    <span class="keyword">parameter</span>    Write_Pre    =<span class="number">4'b0100</span>;</span><br><span class="line">    <span class="keyword">parameter</span>    Read        =<span class="number">4'b0101</span>;</span><br><span class="line">    <span class="keyword">parameter</span>    Read_Pre    =<span class="number">4'b0101</span>;</span><br><span class="line">    <span class="keyword">parameter</span>    Burst_Stop    =<span class="number">4'b0110</span>;</span><br><span class="line">    <span class="keyword">parameter</span>    Nop        =<span class="number">4'b0111</span>;</span><br><span class="line">    <span class="keyword">parameter</span>    Dsel        =<span class="number">4'b1111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span>    [<span class="number">3</span>:<span class="number">0</span>]    sdram_control;</span><br><span class="line">    <span class="keyword">reg</span>            cke_temp;</span><br><span class="line">    <span class="keyword">reg</span>        [<span class="number">8</span>*<span class="number">13</span>:<span class="number">1</span>]    sdram_command;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> Clk)</span><br><span class="line">    cke_temp&lt;=Cke;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span>    sdram_control=&#123;Cs_n,Ras_n,Cas_n,We_n&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(sdram_control <span class="keyword">or</span> cke_temp)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(sdram_control)</span><br><span class="line">            Mode_Reg_Set:    sdram_command&lt;=<span class="string">"Mode_Reg_Set"</span>;</span><br><span class="line">            Auto_Refresh:    sdram_command&lt;=<span class="string">"Auto_Refresh"</span>;</span><br><span class="line">            Row_Active:    sdram_command&lt;=<span class="string">"Row_Active"</span>;</span><br><span class="line">            Pre_Charge:    sdram_command&lt;=<span class="string">"Pre_Charge"</span>;</span><br><span class="line">            Burst_Stop:    sdram_command&lt;=<span class="string">"Burst_Stop"</span>;</span><br><span class="line">            Dsel:        sdram_command&lt;=<span class="string">"Dsel"</span>;</span><br><span class="line"></span><br><span class="line">            Write:        <span class="keyword">if</span>(cke_temp==<span class="number">1</span>)</span><br><span class="line">                        sdram_command&lt;=<span class="string">"Write"</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        sdram_command&lt;=<span class="string">"Write_suspend"</span>;</span><br><span class="line">                        </span><br><span class="line">            Read:        <span class="keyword">if</span>(cke_temp==<span class="number">1</span>)</span><br><span class="line">                        sdram_command&lt;=<span class="string">"Read"</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        sdram_command&lt;=<span class="string">"Read_suspend"</span>;</span><br><span class="line">                        </span><br><span class="line">            Nop:        <span class="keyword">if</span>(cke_temp==<span class="number">1</span>)</span><br><span class="line">                        sdram_command&lt;=<span class="string">"Nop"</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        sdram_command&lt;=<span class="string">"Self_refresh"</span>;</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">default</span>:    sdram_command&lt;=<span class="string">"Power_down"</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//*****************************************************</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//test_file=$fopen("test_file.txt");</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        Dq_reg = &#123;data_bits&#123;<span class="number">1'bz</span>&#125;&#125;;</span><br><span class="line">        &#123;Data_in_enable, Data_out_enable&#125; = <span class="number">0</span>;</span><br><span class="line">        &#123;Act_b0, Act_b1, Act_b2, Act_b3&#125; = <span class="number">4'b0000</span>;</span><br><span class="line">        &#123;Pc_b0, Pc_b1, Pc_b2, Pc_b3&#125; = <span class="number">4'b0000</span>;</span><br><span class="line">        &#123;WR_chk[<span class="number">0</span>], WR_chk[<span class="number">1</span>], WR_chk[<span class="number">2</span>], WR_chk[<span class="number">3</span>]&#125; = <span class="number">0</span>;</span><br><span class="line">        &#123;WR_counter[<span class="number">0</span>], WR_counter[<span class="number">1</span>], WR_counter[<span class="number">2</span>], WR_counter[<span class="number">3</span>]&#125; = <span class="number">0</span>;</span><br><span class="line">        &#123;RW_interrupt_read[<span class="number">0</span>], RW_interrupt_read[<span class="number">1</span>], RW_interrupt_read[<span class="number">2</span>], RW_interrupt_read[<span class="number">3</span>]&#125; = <span class="number">0</span>;</span><br><span class="line">        &#123;RW_interrupt_write[<span class="number">0</span>], RW_interrupt_write[<span class="number">1</span>], RW_interrupt_write[<span class="number">2</span>], RW_interrupt_write[<span class="number">3</span>]&#125; = <span class="number">0</span>;</span><br><span class="line">        &#123;MRD_chk, RC_chk, RRD_chk&#125; = <span class="number">0</span>;</span><br><span class="line">        &#123;RAS_chk0, RAS_chk1, RAS_chk2, RAS_chk3&#125; = <span class="number">0</span>;</span><br><span class="line">        &#123;RCD_chk0, RCD_chk1, RCD_chk2, RCD_chk3&#125; = <span class="number">0</span>;</span><br><span class="line">        &#123;RP_chk0, RP_chk1, RP_chk2, RP_chk3&#125; = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">$timeformat</span> (-<span class="number">9</span>, <span class="number">0</span>, <span class="string">" ns"</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="comment">//$readmemh("bank0.txt", Bank0);</span></span><br><span class="line">        <span class="comment">//$readmemh("bank1.txt", Bank1);</span></span><br><span class="line">        <span class="comment">//$readmemh("bank2.txt", Bank2);</span></span><br><span class="line">        <span class="comment">//$readmemh("bank3.txt", Bank3);</span></span><br><span class="line"><span class="comment">/*      </span></span><br><span class="line"><span class="comment">       for(dd=0;dd&lt;=mem_sizes;dd=dd+1)</span></span><br><span class="line"><span class="comment">            begin</span></span><br><span class="line"><span class="comment">                Bank0[dd]=dd[data_bits - 1 : 0];</span></span><br><span class="line"><span class="comment">                Bank1[dd]=dd[data_bits - 1 : 0]+1;</span></span><br><span class="line"><span class="comment">                Bank2[dd]=dd[data_bits - 1 : 0]+2;</span></span><br><span class="line"><span class="comment">                Bank3[dd]=dd[data_bits - 1 : 0]+3;</span></span><br><span class="line"><span class="comment">            end</span></span><br><span class="line"><span class="comment">*/</span>            </span><br><span class="line">      initial_sdram(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">task</span>    initial_sdram; </span><br><span class="line"> </span><br><span class="line">         <span class="keyword">input</span>        data_sign;</span><br><span class="line">         <span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>]    data_sign;</span><br><span class="line">          </span><br><span class="line">               <span class="keyword">for</span>(dd=<span class="number">0</span>;dd&lt;=mem_sizes;dd=dd+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                mem_d = &#123;data_sign,data_sign,data_sign,data_sign,data_sign,data_sign,data_sign,data_sign&#125;;</span><br><span class="line">                <span class="keyword">if</span>(data_bits==<span class="number">16</span>)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        Bank0[dd]=mem_d[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">                        Bank1[dd]=mem_d[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">                        Bank2[dd]=mem_d[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">                        Bank3[dd]=mem_d[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(data_bits==<span class="number">32</span>)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        Bank0[dd]=mem_d[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">                        Bank1[dd]=mem_d[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">                        Bank2[dd]=mem_d[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">                        Bank3[dd]=mem_d[<span class="number">31</span>:<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span>    </span><br><span class="line">          </span><br><span class="line">               <span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// System clock generator</span></span><br><span class="line">    <span class="keyword">always</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">               @(<span class="keyword">posedge</span> Clk)</span><br><span class="line">                   <span class="keyword">begin</span></span><br><span class="line">                        Sys_clk = CkeZ;</span><br><span class="line">                        CkeZ = Cke;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            @(<span class="keyword">negedge</span> Clk) </span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                        Sys_clk = <span class="number">1'b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> Sys_clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// Internal Commamd Pipelined</span></span><br><span class="line">        Command[<span class="number">0</span>] = Command[<span class="number">1</span>];</span><br><span class="line">        Command[<span class="number">1</span>] = Command[<span class="number">2</span>];</span><br><span class="line">        Command[<span class="number">2</span>] = Command[<span class="number">3</span>];</span><br><span class="line">        Command[<span class="number">3</span>] = <span class="meta">`NOP;</span></span><br><span class="line"></span><br><span class="line">        Col_addr[<span class="number">0</span>] = Col_addr[<span class="number">1</span>];</span><br><span class="line">        Col_addr[<span class="number">1</span>] = Col_addr[<span class="number">2</span>];</span><br><span class="line">        Col_addr[<span class="number">2</span>] = Col_addr[<span class="number">3</span>];</span><br><span class="line">        Col_addr[<span class="number">3</span>] = &#123;col_bits&#123;<span class="number">1'b0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        Bank_addr[<span class="number">0</span>] = Bank_addr[<span class="number">1</span>];</span><br><span class="line">        Bank_addr[<span class="number">1</span>] = Bank_addr[<span class="number">2</span>];</span><br><span class="line">        Bank_addr[<span class="number">2</span>] = Bank_addr[<span class="number">3</span>];</span><br><span class="line">        Bank_addr[<span class="number">3</span>] = <span class="number">2'b0</span>;</span><br><span class="line"></span><br><span class="line">        Bank_precharge[<span class="number">0</span>] = Bank_precharge[<span class="number">1</span>];</span><br><span class="line">        Bank_precharge[<span class="number">1</span>] = Bank_precharge[<span class="number">2</span>];</span><br><span class="line">        Bank_precharge[<span class="number">2</span>] = Bank_precharge[<span class="number">3</span>];</span><br><span class="line">        Bank_precharge[<span class="number">3</span>] = <span class="number">2'b0</span>;</span><br><span class="line"></span><br><span class="line">        A10_precharge[<span class="number">0</span>] = A10_precharge[<span class="number">1</span>];</span><br><span class="line">        A10_precharge[<span class="number">1</span>] = A10_precharge[<span class="number">2</span>];</span><br><span class="line">        A10_precharge[<span class="number">2</span>] = A10_precharge[<span class="number">3</span>];</span><br><span class="line">        A10_precharge[<span class="number">3</span>] = <span class="number">1'b0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dqm pipeline for Read</span></span><br><span class="line">        Dqm_reg0 = Dqm_reg1;</span><br><span class="line">        Dqm_reg1 = Dqm;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read or Write with Auto Precharge Counter</span></span><br><span class="line">        <span class="keyword">if</span> (Auto_precharge[<span class="number">0</span>] == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">            Count_precharge[<span class="number">0</span>] = Count_precharge[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> (Auto_precharge[<span class="number">1</span>] == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">            Count_precharge[<span class="number">1</span>] = Count_precharge[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> (Auto_precharge[<span class="number">2</span>] == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">            Count_precharge[<span class="number">2</span>] = Count_precharge[<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> (Auto_precharge[<span class="number">3</span>] == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">            Count_precharge[<span class="number">3</span>] = Count_precharge[<span class="number">3</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// tMRD Counter</span></span><br><span class="line">        MRD_chk = MRD_chk + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tWR Counter for Write</span></span><br><span class="line">        WR_counter[<span class="number">0</span>] = WR_counter[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        WR_counter[<span class="number">1</span>] = WR_counter[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        WR_counter[<span class="number">2</span>] = WR_counter[<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        WR_counter[<span class="number">3</span>] = WR_counter[<span class="number">3</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Auto Refresh</span></span><br><span class="line">        <span class="keyword">if</span> (Aref_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t AREF : Auto Refresh"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="comment">// Auto Refresh to Auto Refresh</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">$time</span> - RC_chk &lt; tRC)&amp;&amp;Debug) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRC violation during Auto Refresh"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Precharge to Auto Refresh</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">$time</span> - RP_chk0 &lt; tRP || <span class="built_in">$time</span> - RP_chk1 &lt; tRP || <span class="built_in">$time</span> - RP_chk2 &lt; tRP || <span class="built_in">$time</span> - RP_chk3 &lt; tRP)&amp;&amp;Debug) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRP violation during Auto Refresh"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Precharge to Refresh</span></span><br><span class="line">            <span class="keyword">if</span> (Pc_b0 == <span class="number">1'b0</span> || Pc_b1 == <span class="number">1'b0</span> || Pc_b2 == <span class="number">1'b0</span> || Pc_b3 == <span class="number">1'b0</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: All banks must be Precharge before Auto Refresh"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Record Current tRC time</span></span><br><span class="line">            RC_chk = <span class="built_in">$time</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Load Mode Register</span></span><br><span class="line">        <span class="keyword">if</span> (Mode_reg_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// Decode CAS Latency, Burst Length, Burst Type, and Write Burst Mode</span></span><br><span class="line">            <span class="keyword">if</span> (Pc_b0 == <span class="number">1'b1</span> &amp;&amp; Pc_b1 == <span class="number">1'b1</span> &amp;&amp; Pc_b2 == <span class="number">1'b1</span> &amp;&amp; Pc_b3 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                Mode_reg = Addr;</span><br><span class="line">                <span class="keyword">if</span> (Debug) <span class="keyword">begin</span></span><br><span class="line">                    <span class="built_in">$display</span> (<span class="string">"at time %t LMR  : Load Mode Register"</span>, <span class="built_in">$time</span>);</span><br><span class="line">                    <span class="comment">// CAS Latency</span></span><br><span class="line">                    <span class="keyword">if</span> (Addr[<span class="number">6</span> : <span class="number">4</span>] == <span class="number">3'b010</span>)</span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            CAS Latency      = 2"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (Addr[<span class="number">6</span> : <span class="number">4</span>] == <span class="number">3'b011</span>)</span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            CAS Latency      = 3"</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            CAS Latency      = Reserved"</span>);</span><br><span class="line">                    <span class="comment">// Burst Length</span></span><br><span class="line">                    <span class="keyword">if</span> (Addr[<span class="number">2</span> : <span class="number">0</span>] == <span class="number">3'b000</span>)</span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            Burst Length     = 1"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (Addr[<span class="number">2</span> : <span class="number">0</span>] == <span class="number">3'b001</span>)</span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            Burst Length     = 2"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (Addr[<span class="number">2</span> : <span class="number">0</span>] == <span class="number">3'b010</span>)</span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            Burst Length     = 4"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (Addr[<span class="number">2</span> : <span class="number">0</span>] == <span class="number">3'b011</span>)</span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            Burst Length     = 8"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (Addr[<span class="number">3</span> : <span class="number">0</span>] == <span class="number">4'b0111</span>)</span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            Burst Length     = Full"</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            Burst Length     = Reserved"</span>);</span><br><span class="line">                    <span class="comment">// Burst Type</span></span><br><span class="line">                    <span class="keyword">if</span> (Addr[<span class="number">3</span>] == <span class="number">1'b0</span>)</span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            Burst Type       = Sequential"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (Addr[<span class="number">3</span>] == <span class="number">1'b1</span>)</span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            Burst Type       = Interleaved"</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            Burst Type       = Reserved"</span>);</span><br><span class="line">                    <span class="comment">// Write Burst Mode</span></span><br><span class="line">                    <span class="keyword">if</span> (Addr[<span class="number">9</span>] == <span class="number">1'b0</span>)</span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            Write Burst Mode = Programmed Burst Length"</span>);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (Addr[<span class="number">9</span>] == <span class="number">1'b1</span>)</span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            Write Burst Mode = Single Location Access"</span>);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"                            Write Burst Mode = Reserved"</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: all banks must be Precharge before Load Mode Register"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// REF to LMR</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">$time</span> - RC_chk &lt; tRC) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRC violation during Load Mode Register"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// LMR to LMR</span></span><br><span class="line">            <span class="keyword">if</span> (MRD_chk &lt; tMRD) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tMRD violation during Load Mode Register"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            MRD_chk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Active Block (Latch Bank Address and Row Address)</span></span><br><span class="line">        <span class="keyword">if</span> (Active_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (Ba == <span class="number">2'b00</span> &amp;&amp; Pc_b0 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                &#123;Act_b0, Pc_b0&#125; = <span class="number">2'b10</span>;</span><br><span class="line">                B0_row_addr = Addr [addr_bits - <span class="number">1</span> : <span class="number">0</span>];</span><br><span class="line">                RCD_chk0 = <span class="built_in">$time</span>;</span><br><span class="line">                RAS_chk0 = <span class="built_in">$time</span>;</span><br><span class="line">                <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t ACT  : Bank = 0 Row = %d"</span>, <span class="built_in">$time</span>, Addr);</span><br><span class="line">                <span class="comment">// Precharge to Activate Bank 0</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">$time</span> - RP_chk0 &lt; tRP) <span class="keyword">begin</span></span><br><span class="line">                    <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRP violation during Activate bank 0"</span>, <span class="built_in">$time</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Ba == <span class="number">2'b01</span> &amp;&amp; Pc_b1 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                &#123;Act_b1, Pc_b1&#125; = <span class="number">2'b10</span>;</span><br><span class="line">                B1_row_addr = Addr [addr_bits - <span class="number">1</span> : <span class="number">0</span>];</span><br><span class="line">                RCD_chk1 = <span class="built_in">$time</span>;</span><br><span class="line">                RAS_chk1 = <span class="built_in">$time</span>;</span><br><span class="line">                <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t ACT  : Bank = 1 Row = %d"</span>, <span class="built_in">$time</span>, Addr);</span><br><span class="line">                <span class="comment">// Precharge to Activate Bank 1</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">$time</span> - RP_chk1 &lt; tRP) <span class="keyword">begin</span></span><br><span class="line">                    <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRP violation during Activate bank 1"</span>, <span class="built_in">$time</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Ba == <span class="number">2'b10</span> &amp;&amp; Pc_b2 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                &#123;Act_b2, Pc_b2&#125; = <span class="number">2'b10</span>;</span><br><span class="line">                B2_row_addr = Addr [addr_bits - <span class="number">1</span> : <span class="number">0</span>];</span><br><span class="line">                RCD_chk2 = <span class="built_in">$time</span>;</span><br><span class="line">                RAS_chk2 = <span class="built_in">$time</span>;</span><br><span class="line">                <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t ACT  : Bank = 2 Row = %d"</span>, <span class="built_in">$time</span>, Addr);</span><br><span class="line">                <span class="comment">// Precharge to Activate Bank 2</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">$time</span> - RP_chk2 &lt; tRP) <span class="keyword">begin</span></span><br><span class="line">                    <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRP violation during Activate bank 2"</span>, <span class="built_in">$time</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Ba == <span class="number">2'b11</span> &amp;&amp; Pc_b3 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                &#123;Act_b3, Pc_b3&#125; = <span class="number">2'b10</span>;</span><br><span class="line">                B3_row_addr = Addr [addr_bits - <span class="number">1</span> : <span class="number">0</span>];</span><br><span class="line">                RCD_chk3 = <span class="built_in">$time</span>;</span><br><span class="line">                RAS_chk3 = <span class="built_in">$time</span>;</span><br><span class="line">                <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t ACT  : Bank = 3 Row = %d"</span>, <span class="built_in">$time</span>, Addr);</span><br><span class="line">                <span class="comment">// Precharge to Activate Bank 3</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">$time</span> - RP_chk3 &lt; tRP) <span class="keyword">begin</span></span><br><span class="line">                    <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRP violation during Activate bank 3"</span>, <span class="built_in">$time</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Ba == <span class="number">2'b00</span> &amp;&amp; Pc_b0 == <span class="number">1'b0</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: Bank 0 is not Precharged."</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Ba == <span class="number">2'b01</span> &amp;&amp; Pc_b1 == <span class="number">1'b0</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: Bank 1 is not Precharged."</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Ba == <span class="number">2'b10</span> &amp;&amp; Pc_b2 == <span class="number">1'b0</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: Bank 2 is not Precharged."</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Ba == <span class="number">2'b11</span> &amp;&amp; Pc_b3 == <span class="number">1'b0</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: Bank 3 is not Precharged."</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Active Bank A to Active Bank B</span></span><br><span class="line">            <span class="keyword">if</span> ((Previous_bank != Ba) &amp;&amp; (<span class="built_in">$time</span> - RRD_chk &lt; tRRD)) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRRD violation during Activate bank = %d"</span>, <span class="built_in">$time</span>, Ba);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Load Mode Register to Active</span></span><br><span class="line">            <span class="keyword">if</span> (MRD_chk &lt; tMRD ) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tMRD violation during Activate bank = %d"</span>, <span class="built_in">$time</span>, Ba);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Auto Refresh to Activate</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">$time</span> - RC_chk &lt; tRC)&amp;&amp;Debug) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRC violation during Activate bank = %d"</span>, <span class="built_in">$time</span>, Ba);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Record variables for checking violation</span></span><br><span class="line">            RRD_chk = <span class="built_in">$time</span>;</span><br><span class="line">            Previous_bank = Ba;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Precharge Block</span></span><br><span class="line">        <span class="keyword">if</span> (Prech_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (Addr[<span class="number">10</span>] == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                &#123;Pc_b0, Pc_b1, Pc_b2, Pc_b3&#125; = <span class="number">4'b1111</span>;</span><br><span class="line">                &#123;Act_b0, Act_b1, Act_b2, Act_b3&#125; = <span class="number">4'b0000</span>;</span><br><span class="line">                RP_chk0 = <span class="built_in">$time</span>;</span><br><span class="line">                RP_chk1 = <span class="built_in">$time</span>;</span><br><span class="line">                RP_chk2 = <span class="built_in">$time</span>;</span><br><span class="line">                RP_chk3 = <span class="built_in">$time</span>;</span><br><span class="line">                <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t PRE  : Bank = ALL"</span>,<span class="built_in">$time</span>);</span><br><span class="line">                <span class="comment">// Activate to Precharge all banks</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">$time</span> - RAS_chk0 &lt; tRAS) || (<span class="built_in">$time</span> - RAS_chk1 &lt; tRAS) ||</span><br><span class="line">                    (<span class="built_in">$time</span> - RAS_chk2 &lt; tRAS) || (<span class="built_in">$time</span> - RAS_chk3 &lt; tRAS)) <span class="keyword">begin</span></span><br><span class="line">                    <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRAS violation during Precharge all bank"</span>, <span class="built_in">$time</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="comment">// tWR violation check for write</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">$time</span> - WR_chk[<span class="number">0</span>] &lt; tWRp) || (<span class="built_in">$time</span> - WR_chk[<span class="number">1</span>] &lt; tWRp) ||</span><br><span class="line">                    (<span class="built_in">$time</span> - WR_chk[<span class="number">2</span>] &lt; tWRp) || (<span class="built_in">$time</span> - WR_chk[<span class="number">3</span>] &lt; tWRp)) <span class="keyword">begin</span></span><br><span class="line">                    <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tWR violation during Precharge all bank"</span>, <span class="built_in">$time</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Addr[<span class="number">10</span>] == <span class="number">1'b0</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (Ba == <span class="number">2'b00</span>) <span class="keyword">begin</span></span><br><span class="line">                    &#123;Pc_b0, Act_b0&#125; = <span class="number">2'b10</span>;</span><br><span class="line">                    RP_chk0 = <span class="built_in">$time</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t PRE  : Bank = 0"</span>,<span class="built_in">$time</span>);</span><br><span class="line">                    <span class="comment">// Activate to Precharge Bank 0</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">$time</span> - RAS_chk0 &lt; tRAS) <span class="keyword">begin</span></span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRAS violation during Precharge bank 0"</span>, <span class="built_in">$time</span>);</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Ba == <span class="number">2'b01</span>) <span class="keyword">begin</span></span><br><span class="line">                    &#123;Pc_b1, Act_b1&#125; = <span class="number">2'b10</span>;</span><br><span class="line">                    RP_chk1 = <span class="built_in">$time</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t PRE  : Bank = 1"</span>,<span class="built_in">$time</span>);</span><br><span class="line">                    <span class="comment">// Activate to Precharge Bank 1</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">$time</span> - RAS_chk1 &lt; tRAS) <span class="keyword">begin</span></span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRAS violation during Precharge bank 1"</span>, <span class="built_in">$time</span>);</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Ba == <span class="number">2'b10</span>) <span class="keyword">begin</span></span><br><span class="line">                    &#123;Pc_b2, Act_b2&#125; = <span class="number">2'b10</span>;</span><br><span class="line">                    RP_chk2 = <span class="built_in">$time</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t PRE  : Bank = 2"</span>,<span class="built_in">$time</span>);</span><br><span class="line">                    <span class="comment">// Activate to Precharge Bank 2</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">$time</span> - RAS_chk2 &lt; tRAS) <span class="keyword">begin</span></span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRAS violation during Precharge bank 2"</span>, <span class="built_in">$time</span>);</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Ba == <span class="number">2'b11</span>) <span class="keyword">begin</span></span><br><span class="line">                    &#123;Pc_b3, Act_b3&#125; = <span class="number">2'b10</span>;</span><br><span class="line">                    RP_chk3 = <span class="built_in">$time</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t PRE  : Bank = 3"</span>,<span class="built_in">$time</span>);</span><br><span class="line">                    <span class="comment">// Activate to Precharge Bank 3</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">$time</span> - RAS_chk3 &lt; tRAS) <span class="keyword">begin</span></span><br><span class="line">                        <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tRAS violation during Precharge bank 3"</span>, <span class="built_in">$time</span>);</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="comment">// tWR violation check for write</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">$time</span> - WR_chk[Ba] &lt; tWRp) <span class="keyword">begin</span></span><br><span class="line">                    <span class="built_in">$display</span> (<span class="string">"at time %t ERROR: tWR violation during Precharge bank %d"</span>, <span class="built_in">$time</span>, Ba);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Terminate a Write Immediately (if same bank or all banks)</span></span><br><span class="line">            <span class="keyword">if</span> (Data_in_enable == <span class="number">1'b1</span> &amp;&amp; (Bank == Ba || Addr[<span class="number">10</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">                Data_in_enable = <span class="number">1'b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Precharge Command Pipeline for Read</span></span><br><span class="line">            <span class="keyword">if</span> (Cas_latency_3 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                Command[<span class="number">2</span>] = <span class="meta">`PRECH;</span></span><br><span class="line">                Bank_precharge[<span class="number">2</span>] = Ba;</span><br><span class="line">                A10_precharge[<span class="number">2</span>] = Addr[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Cas_latency_2 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                Command[<span class="number">1</span>] = <span class="meta">`PRECH;</span></span><br><span class="line">                Bank_precharge[<span class="number">1</span>] = Ba;</span><br><span class="line">                A10_precharge[<span class="number">1</span>] = Addr[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Burst terminate</span></span><br><span class="line">        <span class="keyword">if</span> (Burst_term == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// Terminate a Write Immediately</span></span><br><span class="line">            <span class="keyword">if</span> (Data_in_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                Data_in_enable = <span class="number">1'b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Terminate a Read Depend on CAS Latency</span></span><br><span class="line">            <span class="keyword">if</span> (Cas_latency_3 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                Command[<span class="number">2</span>] = <span class="meta">`BST;</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Cas_latency_2 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                Command[<span class="number">1</span>] = <span class="meta">`BST;</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t BST  : Burst Terminate"</span>,<span class="built_in">$time</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Read, Write, Column Latch</span></span><br><span class="line">        <span class="keyword">if</span> (Read_enable == <span class="number">1'b1</span> || Write_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// Check to see if bank is open (ACT)</span></span><br><span class="line">            <span class="keyword">if</span> ((Ba == <span class="number">2'b00</span> &amp;&amp; Pc_b0 == <span class="number">1'b1</span>) || (Ba == <span class="number">2'b01</span> &amp;&amp; Pc_b1 == <span class="number">1'b1</span>) ||</span><br><span class="line">                (Ba == <span class="number">2'b10</span> &amp;&amp; Pc_b2 == <span class="number">1'b1</span>) || (Ba == <span class="number">2'b11</span> &amp;&amp; Pc_b3 == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"at time %t ERROR: Cannot Read or Write - Bank %d is not Activated"</span>, <span class="built_in">$time</span>, Ba);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Activate to Read or Write</span></span><br><span class="line">            <span class="keyword">if</span> ((Ba == <span class="number">2'b00</span>) &amp;&amp; (<span class="built_in">$time</span> - RCD_chk0 &lt; tRCD))</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"at time %t ERROR: tRCD violation during Read or Write to Bank 0"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">if</span> ((Ba == <span class="number">2'b01</span>) &amp;&amp; (<span class="built_in">$time</span> - RCD_chk1 &lt; tRCD))</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"at time %t ERROR: tRCD violation during Read or Write to Bank 1"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">if</span> ((Ba == <span class="number">2'b10</span>) &amp;&amp; (<span class="built_in">$time</span> - RCD_chk2 &lt; tRCD))</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"at time %t ERROR: tRCD violation during Read or Write to Bank 2"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">if</span> ((Ba == <span class="number">2'b11</span>) &amp;&amp; (<span class="built_in">$time</span> - RCD_chk3 &lt; tRCD))</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"at time %t ERROR: tRCD violation during Read or Write to Bank 3"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="comment">// Read Command</span></span><br><span class="line">            <span class="keyword">if</span> (Read_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// CAS Latency pipeline</span></span><br><span class="line">                <span class="keyword">if</span> (Cas_latency_3 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (Addr[<span class="number">10</span>] == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                        Command[<span class="number">2</span>] = <span class="meta">`READ_A;</span></span><br><span class="line">                    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                        Command[<span class="number">2</span>] = <span class="meta">`READ;</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    Col_addr[<span class="number">2</span>] = Addr;</span><br><span class="line">                    Bank_addr[<span class="number">2</span>] = Ba;</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Cas_latency_2 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (Addr[<span class="number">10</span>] == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                        Command[<span class="number">1</span>] = <span class="meta">`READ_A;</span></span><br><span class="line">                    <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                        Command[<span class="number">1</span>] = <span class="meta">`READ;</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    Col_addr[<span class="number">1</span>] = Addr;</span><br><span class="line">                    Bank_addr[<span class="number">1</span>] = Ba;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Read interrupt Write (terminate Write immediately)</span></span><br><span class="line">                <span class="keyword">if</span> (Data_in_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    Data_in_enable = <span class="number">1'b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Write Command</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Write_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (Addr[<span class="number">10</span>] == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    Command[<span class="number">0</span>] = <span class="meta">`WRITE_A;</span></span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    Command[<span class="number">0</span>] = <span class="meta">`WRITE;</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                Col_addr[<span class="number">0</span>] = Addr;</span><br><span class="line">                Bank_addr[<span class="number">0</span>] = Ba;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Write interrupt Write (terminate Write immediately)</span></span><br><span class="line">                <span class="keyword">if</span> (Data_in_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    Data_in_enable = <span class="number">1'b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Write interrupt Read (terminate Read immediately)</span></span><br><span class="line">                <span class="keyword">if</span> (Data_out_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    Data_out_enable = <span class="number">1'b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Interrupting a Write with Autoprecharge</span></span><br><span class="line">            <span class="keyword">if</span> (Auto_precharge[Bank] == <span class="number">1'b1</span> &amp;&amp; Write_precharge[Bank] == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                RW_interrupt_write[Bank] = <span class="number">1'b1</span>;</span><br><span class="line">                <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t NOTE : Read/Write Bank %d interrupt Write Bank %d with Autoprecharge"</span>, <span class="built_in">$time</span>, Ba, Bank);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Interrupting a Read with Autoprecharge</span></span><br><span class="line">            <span class="keyword">if</span> (Auto_precharge[Bank] == <span class="number">1'b1</span> &amp;&amp; Read_precharge[Bank] == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                RW_interrupt_read[Bank] = <span class="number">1'b1</span>;</span><br><span class="line">                <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t NOTE : Read/Write Bank %d interrupt Read Bank %d with Autoprecharge"</span>, <span class="built_in">$time</span>, Ba, Bank);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Read or Write with Auto Precharge</span></span><br><span class="line">            <span class="keyword">if</span> (Addr[<span class="number">10</span>] == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                Auto_precharge[Ba] = <span class="number">1'b1</span>;</span><br><span class="line">                Count_precharge[Ba] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (Read_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    Read_precharge[Ba] = <span class="number">1'b1</span>;</span><br><span class="line">                <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Write_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    Write_precharge[Ba] = <span class="number">1'b1</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  Read with Auto Precharge Calculation</span></span><br><span class="line">        <span class="comment">//      The device start internal precharge:</span></span><br><span class="line">        <span class="comment">//          1.  CAS Latency - 1 cycles before last burst</span></span><br><span class="line">        <span class="comment">//      and 2.  Meet minimum tRAS requirement</span></span><br><span class="line">        <span class="comment">//       or 3.  Interrupt by a Read or Write (with or without AutoPrecharge)</span></span><br><span class="line">        <span class="keyword">if</span> ((Auto_precharge[<span class="number">0</span>] == <span class="number">1'b1</span>) &amp;&amp; (Read_precharge[<span class="number">0</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (((<span class="built_in">$time</span> - RAS_chk0 &gt;= tRAS) &amp;&amp;                                                      <span class="comment">// Case 2</span></span><br><span class="line">                ((Burst_length_1 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">0</span>] &gt;= <span class="number">1</span>) ||                             <span class="comment">// Case 1</span></span><br><span class="line">                 (Burst_length_2 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">0</span>] &gt;= <span class="number">2</span>) ||</span><br><span class="line">                 (Burst_length_4 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">0</span>] &gt;= <span class="number">4</span>) ||</span><br><span class="line">                 (Burst_length_8 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">0</span>] &gt;= <span class="number">8</span>))) ||</span><br><span class="line">                 (RW_interrupt_read[<span class="number">0</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span>                                              <span class="comment">// Case 3</span></span><br><span class="line">                    Pc_b0 = <span class="number">1'b1</span>;</span><br><span class="line">                    Act_b0 = <span class="number">1'b0</span>;</span><br><span class="line">                    RP_chk0 = <span class="built_in">$time</span>;</span><br><span class="line">                    Auto_precharge[<span class="number">0</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    Read_precharge[<span class="number">0</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    RW_interrupt_read[<span class="number">0</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t NOTE : Start Internal Auto Precharge for Bank 0"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> ((Auto_precharge[<span class="number">1</span>] == <span class="number">1'b1</span>) &amp;&amp; (Read_precharge[<span class="number">1</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (((<span class="built_in">$time</span> - RAS_chk1 &gt;= tRAS) &amp;&amp;</span><br><span class="line">                ((Burst_length_1 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">1</span>] &gt;= <span class="number">1</span>) || </span><br><span class="line">                 (Burst_length_2 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">1</span>] &gt;= <span class="number">2</span>) ||</span><br><span class="line">                 (Burst_length_4 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">1</span>] &gt;= <span class="number">4</span>) ||</span><br><span class="line">                 (Burst_length_8 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">1</span>] &gt;= <span class="number">8</span>))) ||</span><br><span class="line">                 (RW_interrupt_read[<span class="number">1</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">                    Pc_b1 = <span class="number">1'b1</span>;</span><br><span class="line">                    Act_b1 = <span class="number">1'b0</span>;</span><br><span class="line">                    RP_chk1 = <span class="built_in">$time</span>;</span><br><span class="line">                    Auto_precharge[<span class="number">1</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    Read_precharge[<span class="number">1</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    RW_interrupt_read[<span class="number">1</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t NOTE : Start Internal Auto Precharge for Bank 1"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> ((Auto_precharge[<span class="number">2</span>] == <span class="number">1'b1</span>) &amp;&amp; (Read_precharge[<span class="number">2</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (((<span class="built_in">$time</span> - RAS_chk2 &gt;= tRAS) &amp;&amp;</span><br><span class="line">                ((Burst_length_1 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">2</span>] &gt;= <span class="number">1</span>) || </span><br><span class="line">                 (Burst_length_2 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">2</span>] &gt;= <span class="number">2</span>) ||</span><br><span class="line">                 (Burst_length_4 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">2</span>] &gt;= <span class="number">4</span>) ||</span><br><span class="line">                 (Burst_length_8 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">2</span>] &gt;= <span class="number">8</span>))) ||</span><br><span class="line">                 (RW_interrupt_read[<span class="number">2</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">                    Pc_b2 = <span class="number">1'b1</span>;</span><br><span class="line">                    Act_b2 = <span class="number">1'b0</span>;</span><br><span class="line">                    RP_chk2 = <span class="built_in">$time</span>;</span><br><span class="line">                    Auto_precharge[<span class="number">2</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    Read_precharge[<span class="number">2</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    RW_interrupt_read[<span class="number">2</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t NOTE : Start Internal Auto Precharge for Bank 2"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> ((Auto_precharge[<span class="number">3</span>] == <span class="number">1'b1</span>) &amp;&amp; (Read_precharge[<span class="number">3</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (((<span class="built_in">$time</span> - RAS_chk3 &gt;= tRAS) &amp;&amp;</span><br><span class="line">                ((Burst_length_1 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">3</span>] &gt;= <span class="number">1</span>) || </span><br><span class="line">                 (Burst_length_2 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">3</span>] &gt;= <span class="number">2</span>) ||</span><br><span class="line">                 (Burst_length_4 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">3</span>] &gt;= <span class="number">4</span>) ||</span><br><span class="line">                 (Burst_length_8 == <span class="number">1'b1</span> &amp;&amp; Count_precharge[<span class="number">3</span>] &gt;= <span class="number">8</span>))) ||</span><br><span class="line">                 (RW_interrupt_read[<span class="number">3</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">                    Pc_b3 = <span class="number">1'b1</span>;</span><br><span class="line">                    Act_b3 = <span class="number">1'b0</span>;</span><br><span class="line">                    RP_chk3 = <span class="built_in">$time</span>;</span><br><span class="line">                    Auto_precharge[<span class="number">3</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    Read_precharge[<span class="number">3</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    RW_interrupt_read[<span class="number">3</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t NOTE : Start Internal Auto Precharge for Bank 3"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Internal Precharge or Bst</span></span><br><span class="line">        <span class="keyword">if</span> (Command[<span class="number">0</span>] == <span class="meta">`PRECH) begin                         // Precharge terminate a read with same bank or all banks</span></span><br><span class="line">            <span class="keyword">if</span> (Bank_precharge[<span class="number">0</span>] == Bank || A10_precharge[<span class="number">0</span>] == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (Data_out_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                    Data_out_enable = <span class="number">1'b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Command[<span class="number">0</span>] == <span class="meta">`BST) begin                  // BST terminate a read to current bank</span></span><br><span class="line">            <span class="keyword">if</span> (Data_out_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                Data_out_enable = <span class="number">1'b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Data_out_enable == <span class="number">1'b0</span>) <span class="keyword">begin</span></span><br><span class="line">            Dq_reg &lt;= #tOH &#123;data_bits&#123;<span class="number">1'bz</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Detect Read or Write command</span></span><br><span class="line">        <span class="keyword">if</span> (Command[<span class="number">0</span>] == <span class="meta">`READ || Command[0] == `READ_A) begin</span></span><br><span class="line">            Bank = Bank_addr[<span class="number">0</span>];</span><br><span class="line">            Col = Col_addr[<span class="number">0</span>];</span><br><span class="line">            Col_brst = Col_addr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (Bank_addr[<span class="number">0</span>] == <span class="number">2'b00</span>) <span class="keyword">begin</span></span><br><span class="line">                Row = B0_row_addr;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Bank_addr[<span class="number">0</span>] == <span class="number">2'b01</span>) <span class="keyword">begin</span></span><br><span class="line">                Row = B1_row_addr;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Bank_addr[<span class="number">0</span>] == <span class="number">2'b10</span>) <span class="keyword">begin</span></span><br><span class="line">                Row = B2_row_addr;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Bank_addr[<span class="number">0</span>] == <span class="number">2'b11</span>) <span class="keyword">begin</span></span><br><span class="line">                Row = B3_row_addr;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            Burst_counter = <span class="number">0</span>;</span><br><span class="line">            Data_in_enable = <span class="number">1'b0</span>;</span><br><span class="line">            Data_out_enable = <span class="number">1'b1</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Command[<span class="number">0</span>] == <span class="meta">`WRITE || Command[0] == `WRITE_A) begin</span></span><br><span class="line">            Bank = Bank_addr[<span class="number">0</span>];</span><br><span class="line">            Col = Col_addr[<span class="number">0</span>];</span><br><span class="line">            Col_brst = Col_addr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (Bank_addr[<span class="number">0</span>] == <span class="number">2'b00</span>) <span class="keyword">begin</span></span><br><span class="line">                Row = B0_row_addr;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Bank_addr[<span class="number">0</span>] == <span class="number">2'b01</span>) <span class="keyword">begin</span></span><br><span class="line">                Row = B1_row_addr;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Bank_addr[<span class="number">0</span>] == <span class="number">2'b10</span>) <span class="keyword">begin</span></span><br><span class="line">                Row = B2_row_addr;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Bank_addr[<span class="number">0</span>] == <span class="number">2'b11</span>) <span class="keyword">begin</span></span><br><span class="line">                Row = B3_row_addr;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            Burst_counter = <span class="number">0</span>;</span><br><span class="line">            Data_in_enable = <span class="number">1'b1</span>;</span><br><span class="line">            Data_out_enable = <span class="number">1'b0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// DQ buffer (Driver/Receiver)</span></span><br><span class="line">        <span class="keyword">if</span> (Data_in_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span>                                   <span class="comment">// Writing Data to Memory</span></span><br><span class="line">            <span class="comment">// Array buffer</span></span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b00</span>) Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>] = Bank0 [&#123;Row, Col&#125;];</span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b01</span>) Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>] = Bank1 [&#123;Row, Col&#125;];</span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b10</span>) Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>] = Bank2 [&#123;Row, Col&#125;];</span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b11</span>) Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>] = Bank3 [&#123;Row, Col&#125;];</span><br><span class="line">            <span class="comment">// Dqm operation</span></span><br><span class="line">            <span class="keyword">if</span> (Dqm[<span class="number">0</span>] == <span class="number">1'b0</span>) Dq_dqm [ <span class="number">7</span> : <span class="number">0</span>] = Dq [ <span class="number">7</span> : <span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (Dqm[<span class="number">1</span>] == <span class="number">1'b0</span>) Dq_dqm [<span class="number">15</span> : <span class="number">8</span>] = Dq [<span class="number">15</span> : <span class="number">8</span>];</span><br><span class="line">            <span class="comment">//if (Dqm[2] == 1'b0) Dq_dqm [23 : 16] = Dq [23 : 16];</span></span><br><span class="line">           <span class="comment">// if (Dqm[3] == 1'b0) Dq_dqm [31 : 24] = Dq [31 : 24];</span></span><br><span class="line">            <span class="comment">// Write to memory</span></span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b00</span>) Bank0 [&#123;Row, Col&#125;] = Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b01</span>) Bank1 [&#123;Row, Col&#125;] = Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b10</span>) Bank2 [&#123;Row, Col&#125;] = Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b11</span>) Bank3 [&#123;Row, Col&#125;] = Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b11</span> &amp;&amp; Row==<span class="number">10'h3</span> &amp;&amp; Col[<span class="number">7</span>:<span class="number">4</span>]==<span class="number">4'h4</span>)</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">"at time %t WRITE: Bank = %d Row = %d, Col = %d, Data = Hi-Z due to DQM"</span>, <span class="built_in">$time</span>, Bank, Row, Col);</span><br><span class="line">            <span class="comment">//$fdisplay(test_file,"bank:%h    row:%h    col:%h    write:%h",Bank,Row,Col,Dq_dqm);</span></span><br><span class="line">            <span class="comment">// Output result</span></span><br><span class="line">            <span class="keyword">if</span> (Dqm == <span class="number">4'b1111</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (Debug) <span class="built_in">$display</span>(<span class="string">"at time %t WRITE: Bank = %d Row = %d, Col = %d, Data = Hi-Z due to DQM"</span>, <span class="built_in">$time</span>, Bank, Row, Col);</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (Debug) <span class="built_in">$display</span>(<span class="string">"at time %t WRITE: Bank = %d Row = %d, Col = %d, Data = %d, Dqm = %b"</span>, <span class="built_in">$time</span>, Bank, Row, Col, Dq_dqm, Dqm);</span><br><span class="line">                <span class="comment">// Record tWR time and reset counter</span></span><br><span class="line">                WR_chk [Bank] = <span class="built_in">$time</span>;</span><br><span class="line">                WR_counter [Bank] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Advance burst counter subroutine</span></span><br><span class="line">            #tHZ Burst;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Data_out_enable == <span class="number">1'b1</span>) <span class="keyword">begin</span>                         <span class="comment">// Reading Data from Memory</span></span><br><span class="line">            <span class="comment">//$display("%h    ,    %h,    %h",Bank0,Row,Col);</span></span><br><span class="line">            <span class="comment">// Array buffer</span></span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b00</span>) Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>] = Bank0 [&#123;Row, Col&#125;];</span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b01</span>) Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>] = Bank1 [&#123;Row, Col&#125;];</span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b10</span>) Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>] = Bank2 [&#123;Row, Col&#125;];</span><br><span class="line">            <span class="keyword">if</span> (Bank == <span class="number">2'b11</span>) Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>] = Bank3 [&#123;Row, Col&#125;];</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// Dqm operation</span></span><br><span class="line">            <span class="keyword">if</span> (Dqm_reg0[<span class="number">0</span>] == <span class="number">1'b1</span>) Dq_dqm [ <span class="number">7</span> : <span class="number">0</span>] = <span class="number">8'bz</span>;</span><br><span class="line">            <span class="keyword">if</span> (Dqm_reg0[<span class="number">1</span>] == <span class="number">1'b1</span>) Dq_dqm [<span class="number">15</span> : <span class="number">8</span>] = <span class="number">8'bz</span>;</span><br><span class="line">            <span class="keyword">if</span> (Dqm_reg0[<span class="number">2</span>] == <span class="number">1'b1</span>) Dq_dqm [<span class="number">23</span> : <span class="number">16</span>] = <span class="number">8'bz</span>;</span><br><span class="line">            <span class="keyword">if</span> (Dqm_reg0[<span class="number">3</span>] == <span class="number">1'b1</span>) Dq_dqm [<span class="number">31</span> : <span class="number">24</span>] = <span class="number">8'bz</span>;</span><br><span class="line">            <span class="comment">// Display result</span></span><br><span class="line">            Dq_reg [data_bits - <span class="number">1</span>  : <span class="number">0</span>] = #tAC Dq_dqm [data_bits - <span class="number">1</span>  : <span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (Dqm_reg0 == <span class="number">4'b1111</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (Debug) <span class="built_in">$display</span>(<span class="string">"at time %t READ : Bank = %d Row = %d, Col = %d, Data = Hi-Z due to DQM"</span>, <span class="built_in">$time</span>, Bank, Row, Col);</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (Debug) <span class="built_in">$display</span>(<span class="string">"at time %t READ : Bank = %d Row = %d, Col = %d, Data = %d, Dqm = %b"</span>, <span class="built_in">$time</span>, Bank, Row, Col, Dq_reg, Dqm_reg0);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">// Advance burst counter subroutine</span></span><br><span class="line">            Burst;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Write with Auto Precharge Calculation</span></span><br><span class="line">    <span class="comment">//      The device start internal precharge:</span></span><br><span class="line">    <span class="comment">//          1.  tWR Clock after last burst</span></span><br><span class="line">    <span class="comment">//      and 2.  Meet minimum tRAS requirement</span></span><br><span class="line">    <span class="comment">//       or 3.  Interrupt by a Read or Write (with or without AutoPrecharge)</span></span><br><span class="line">    <span class="keyword">always</span> @ (WR_counter[<span class="number">0</span>]) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> ((Auto_precharge[<span class="number">0</span>] == <span class="number">1'b1</span>) &amp;&amp; (Write_precharge[<span class="number">0</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (((<span class="built_in">$time</span> - RAS_chk0 &gt;= tRAS) &amp;&amp;                                                          <span class="comment">// Case 2</span></span><br><span class="line">               (((Burst_length_1 == <span class="number">1'b1</span> || Write_burst_mode == <span class="number">1'b1</span>) &amp;&amp; Count_precharge [<span class="number">0</span>] &gt;= <span class="number">1</span>) ||   <span class="comment">// Case 1</span></span><br><span class="line">                 (Burst_length_2 == <span class="number">1'b1</span> &amp;&amp; Count_precharge [<span class="number">0</span>] &gt;= <span class="number">2</span>) ||</span><br><span class="line">                 (Burst_length_4 == <span class="number">1'b1</span> &amp;&amp; Count_precharge [<span class="number">0</span>] &gt;= <span class="number">4</span>) ||</span><br><span class="line">                 (Burst_length_8 == <span class="number">1'b1</span> &amp;&amp; Count_precharge [<span class="number">0</span>] &gt;= <span class="number">8</span>))) ||</span><br><span class="line">                 (RW_interrupt_write[<span class="number">0</span>] == <span class="number">1'b1</span> &amp;&amp; WR_counter[<span class="number">0</span>] &gt;= <span class="number">2</span>)) <span class="keyword">begin</span>                           <span class="comment">// Case 3 (stop count when interrupt)</span></span><br><span class="line">                    Auto_precharge[<span class="number">0</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    Write_precharge[<span class="number">0</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    RW_interrupt_write[<span class="number">0</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    #tWRa;                          <span class="comment">// Wait for tWR</span></span><br><span class="line">                    Pc_b0 = <span class="number">1'b1</span>;</span><br><span class="line">                    Act_b0 = <span class="number">1'b0</span>;</span><br><span class="line">                    RP_chk0 = <span class="built_in">$time</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t NOTE : Start Internal Auto Precharge for Bank 0"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @ (WR_counter[<span class="number">1</span>]) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> ((Auto_precharge[<span class="number">1</span>] == <span class="number">1'b1</span>) &amp;&amp; (Write_precharge[<span class="number">1</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (((<span class="built_in">$time</span> - RAS_chk1 &gt;= tRAS) &amp;&amp;</span><br><span class="line">               (((Burst_length_1 == <span class="number">1'b1</span> || Write_burst_mode == <span class="number">1'b1</span>) &amp;&amp; Count_precharge [<span class="number">1</span>] &gt;= <span class="number">1</span>) || </span><br><span class="line">                 (Burst_length_2 == <span class="number">1'b1</span> &amp;&amp; Count_precharge [<span class="number">1</span>] &gt;= <span class="number">2</span>) ||</span><br><span class="line">                 (Burst_length_4 == <span class="number">1'b1</span> &amp;&amp; Count_precharge [<span class="number">1</span>] &gt;= <span class="number">4</span>) ||</span><br><span class="line">                 (Burst_length_8 == <span class="number">1'b1</span> &amp;&amp; Count_precharge [<span class="number">1</span>] &gt;= <span class="number">8</span>))) ||</span><br><span class="line">                 (RW_interrupt_write[<span class="number">1</span>] == <span class="number">1'b1</span> &amp;&amp; WR_counter[<span class="number">1</span>] &gt;= <span class="number">2</span>)) <span class="keyword">begin</span></span><br><span class="line">                    Auto_precharge[<span class="number">1</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    Write_precharge[<span class="number">1</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    RW_interrupt_write[<span class="number">1</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    #tWRa;                          <span class="comment">// Wait for tWR</span></span><br><span class="line">                    Pc_b1 = <span class="number">1'b1</span>;</span><br><span class="line">                    Act_b1 = <span class="number">1'b0</span>;</span><br><span class="line">                    RP_chk1 = <span class="built_in">$time</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t NOTE : Start Internal Auto Precharge for Bank 1"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @ (WR_counter[<span class="number">2</span>]) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> ((Auto_precharge[<span class="number">2</span>] == <span class="number">1'b1</span>) &amp;&amp; (Write_precharge[<span class="number">2</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (((<span class="built_in">$time</span> - RAS_chk2 &gt;= tRAS) &amp;&amp;</span><br><span class="line">               (((Burst_length_1 == <span class="number">1'b1</span> || Write_burst_mode == <span class="number">1'b1</span>) &amp;&amp; Count_precharge [<span class="number">2</span>] &gt;= <span class="number">1</span>) || </span><br><span class="line">                 (Burst_length_2 == <span class="number">1'b1</span> &amp;&amp; Count_precharge [<span class="number">2</span>] &gt;= <span class="number">2</span>) ||</span><br><span class="line">                 (Burst_length_4 == <span class="number">1'b1</span> &amp;&amp; Count_precharge [<span class="number">2</span>] &gt;= <span class="number">4</span>) ||</span><br><span class="line">                 (Burst_length_8 == <span class="number">1'b1</span> &amp;&amp; Count_precharge [<span class="number">2</span>] &gt;= <span class="number">8</span>))) ||</span><br><span class="line">                 (RW_interrupt_write[<span class="number">2</span>] == <span class="number">1'b1</span> &amp;&amp; WR_counter[<span class="number">2</span>] &gt;= <span class="number">2</span>)) <span class="keyword">begin</span></span><br><span class="line">                    Auto_precharge[<span class="number">2</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    Write_precharge[<span class="number">2</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    RW_interrupt_write[<span class="number">2</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    #tWRa;                          <span class="comment">// Wait for tWR</span></span><br><span class="line">                    Pc_b2 = <span class="number">1'b1</span>;</span><br><span class="line">                    Act_b2 = <span class="number">1'b0</span>;</span><br><span class="line">                    RP_chk2 = <span class="built_in">$time</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t NOTE : Start Internal Auto Precharge for Bank 2"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @ (WR_counter[<span class="number">3</span>]) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> ((Auto_precharge[<span class="number">3</span>] == <span class="number">1'b1</span>) &amp;&amp; (Write_precharge[<span class="number">3</span>] == <span class="number">1'b1</span>)) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (((<span class="built_in">$time</span> - RAS_chk3 &gt;= tRAS) &amp;&amp;</span><br><span class="line">               (((Burst_length_1 == <span class="number">1'b1</span> || Write_burst_mode == <span class="number">1'b1</span>) &amp;&amp; Count_precharge [<span class="number">3</span>] &gt;= <span class="number">1</span>) || </span><br><span class="line">                 (Burst_length_2 == <span class="number">1'b1</span> &amp;&amp; Count_precharge [<span class="number">3</span>] &gt;= <span class="number">2</span>) ||</span><br><span class="line">                 (Burst_length_4 == <span class="number">1'b1</span> &amp;&amp; Count_precharge [<span class="number">3</span>] &gt;= <span class="number">4</span>) ||</span><br><span class="line">                 (Burst_length_8 == <span class="number">1'b1</span> &amp;&amp; Count_precharge [<span class="number">3</span>] &gt;= <span class="number">8</span>))) ||</span><br><span class="line">                 (RW_interrupt_write[<span class="number">3</span>] == <span class="number">1'b1</span> &amp;&amp; WR_counter[<span class="number">3</span>] &gt;= <span class="number">2</span>)) <span class="keyword">begin</span></span><br><span class="line">                    Auto_precharge[<span class="number">3</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    Write_precharge[<span class="number">3</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    RW_interrupt_write[<span class="number">3</span>] = <span class="number">1'b0</span>;</span><br><span class="line">                    #tWRa;                          <span class="comment">// Wait for tWR</span></span><br><span class="line">                    Pc_b3 = <span class="number">1'b1</span>;</span><br><span class="line">                    Act_b3 = <span class="number">1'b0</span>;</span><br><span class="line">                    RP_chk3 = <span class="built_in">$time</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Debug) <span class="built_in">$display</span> (<span class="string">"at time %t NOTE : Start Internal Auto Precharge for Bank 3"</span>, <span class="built_in">$time</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> Burst;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// Advance Burst Counter</span></span><br><span class="line">            Burst_counter = Burst_counter + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Burst Type</span></span><br><span class="line">            <span class="keyword">if</span> (Mode_reg[<span class="number">3</span>] == <span class="number">1'b0</span>) <span class="keyword">begin</span>                                  <span class="comment">// Sequential Burst</span></span><br><span class="line">                Col_temp = Col + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Mode_reg[<span class="number">3</span>] == <span class="number">1'b1</span>) <span class="keyword">begin</span>                         <span class="comment">// Interleaved Burst</span></span><br><span class="line">                Col_temp[<span class="number">2</span>] =  Burst_counter[<span class="number">2</span>] ^  Col_brst[<span class="number">2</span>];</span><br><span class="line">                Col_temp[<span class="number">1</span>] =  Burst_counter[<span class="number">1</span>] ^  Col_brst[<span class="number">1</span>];</span><br><span class="line">                Col_temp[<span class="number">0</span>] =  Burst_counter[<span class="number">0</span>] ^  Col_brst[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Burst Length</span></span><br><span class="line">            <span class="keyword">if</span> (Burst_length_2) <span class="keyword">begin</span>                                       <span class="comment">// Burst Length = 2</span></span><br><span class="line">                Col [<span class="number">0</span>] = Col_temp [<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Burst_length_4) <span class="keyword">begin</span>                              <span class="comment">// Burst Length = 4</span></span><br><span class="line">                Col [<span class="number">1</span> : <span class="number">0</span>] = Col_temp [<span class="number">1</span> : <span class="number">0</span>];</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Burst_length_8) <span class="keyword">begin</span>                              <span class="comment">// Burst Length = 8</span></span><br><span class="line">                Col [<span class="number">2</span> : <span class="number">0</span>] = Col_temp [<span class="number">2</span> : <span class="number">0</span>];</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span>                                                  <span class="comment">// Burst Length = FULL</span></span><br><span class="line">                Col = Col_temp;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Burst Read Single Write            </span></span><br><span class="line">            <span class="keyword">if</span> (Write_burst_mode == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                Data_in_enable = <span class="number">1'b0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Data Counter</span></span><br><span class="line">            <span class="keyword">if</span> (Burst_length_1 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (Burst_counter &gt;= <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                    Data_in_enable = <span class="number">1'b0</span>;</span><br><span class="line">                    Data_out_enable = <span class="number">1'b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Burst_length_2 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (Burst_counter &gt;= <span class="number">2</span>) <span class="keyword">begin</span></span><br><span class="line">                    Data_in_enable = <span class="number">1'b0</span>;</span><br><span class="line">                    Data_out_enable = <span class="number">1'b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Burst_length_4 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (Burst_counter &gt;= <span class="number">4</span>) <span class="keyword">begin</span></span><br><span class="line">                    Data_in_enable = <span class="number">1'b0</span>;</span><br><span class="line">                    Data_out_enable = <span class="number">1'b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">if</span> (Burst_length_8 == <span class="number">1'b1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (Burst_counter &gt;= <span class="number">8</span>) <span class="keyword">begin</span></span><br><span class="line">                    Data_in_enable = <span class="number">1'b0</span>;</span><br><span class="line">                    Data_out_enable = <span class="number">1'b0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//**********************将SDRAM内的数据直接输出到外部文件*******************************//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*    </span></span><br><span class="line"><span class="comment">   integer    sdram_data,ind;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    always@(sdram_r)</span></span><br><span class="line"><span class="comment">    begin</span></span><br><span class="line"><span class="comment">           sdram_data=$fopen("sdram_data.txt");</span></span><br><span class="line"><span class="comment">           $display("Sdram dampout begin ",sdram_data);</span></span><br><span class="line"><span class="comment">//           $fdisplay(sdram_data,"Bank0：");</span></span><br><span class="line"><span class="comment">           for(ind=0;ind&lt;=mem_sizes;ind=ind+1)</span></span><br><span class="line"><span class="comment">                    $fdisplay(sdram_data,"%h    %b",ind,Bank0[ind]);</span></span><br><span class="line"><span class="comment">//           $fdisplay(sdram_data,"Bank1：");</span></span><br><span class="line"><span class="comment">           for(ind=0;ind&lt;=mem_sizes;ind=ind+1)</span></span><br><span class="line"><span class="comment">                    $fdisplay(sdram_data,"%h    %b",ind,Bank1[ind]);</span></span><br><span class="line"><span class="comment">//           $fdisplay(sdram_data,"Bank2：");</span></span><br><span class="line"><span class="comment">           for(ind=0;ind&lt;=mem_sizes;ind=ind+1)</span></span><br><span class="line"><span class="comment">                    $fdisplay(sdram_data,"%h    %b",ind,Bank2[ind]);</span></span><br><span class="line"><span class="comment">//               $fdisplay(sdram_data,"Bank3：");</span></span><br><span class="line"><span class="comment">           for(ind=0;ind&lt;=mem_sizes;ind=ind+1)</span></span><br><span class="line"><span class="comment">                    $fdisplay(sdram_data,"%h    %b",ind,Bank3[ind]);</span></span><br><span class="line"><span class="comment">                                      </span></span><br><span class="line"><span class="comment">          $fclose("sdram_data.txt");        </span></span><br><span class="line"><span class="comment">      //-&gt;compare;</span></span><br><span class="line"><span class="comment">      end        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">integer</span>    sdram_data,sdram_mem;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">24</span>:<span class="number">0</span>]    aa,cc;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">24</span>:<span class="number">0</span>]    bb,ee;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(sdram_r)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">           <span class="built_in">$display</span>(<span class="string">"Sdram dampout begin "</span>,<span class="built_in">$realtime</span>);</span><br><span class="line">           sdram_data=<span class="built_in">$fopen</span>(<span class="string">"sdram_data.txt"</span>);</span><br><span class="line">           <span class="keyword">for</span>(aa=<span class="number">0</span>;aa&lt;<span class="number">4</span>*(mem_sizes+<span class="number">1</span>);aa=aa+<span class="number">1</span>)</span><br><span class="line">               <span class="keyword">begin</span></span><br><span class="line">               bb=aa[<span class="number">18</span>:<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(aa&lt;=mem_sizes)</span><br><span class="line">                <span class="built_in">$fdisplay</span>(sdram_data,<span class="string">"%0d    %0h"</span>,aa,Bank0[bb]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aa&lt;=<span class="number">2</span>*mem_sizes+<span class="number">1</span>)</span><br><span class="line">                        <span class="built_in">$fdisplay</span>(sdram_data,<span class="string">"%0d    %0h"</span>,aa,Bank1[bb]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aa&lt;=<span class="number">3</span>*mem_sizes+<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">$fdisplay</span>(sdram_data,<span class="string">"%0d    %0h"</span>,aa,Bank2[bb]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">$fdisplay</span>(sdram_data,<span class="string">"%0d    %0h"</span>,aa,Bank3[bb]);</span><br><span class="line">              <span class="keyword">end</span>                        </span><br><span class="line">          <span class="built_in">$fclose</span>(<span class="string">"sdram_data.txt"</span>); </span><br><span class="line">          </span><br><span class="line">          sdram_mem=<span class="built_in">$fopen</span>(<span class="string">"sdram_mem.txt"</span>);</span><br><span class="line">          <span class="keyword">for</span>(cc=<span class="number">0</span>;cc&lt;<span class="number">4</span>*(mem_sizes+<span class="number">1</span>);cc=cc+<span class="number">1</span>)</span><br><span class="line">              <span class="keyword">begin</span></span><br><span class="line">               ee=cc[<span class="number">18</span>:<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(cc&lt;=mem_sizes)</span><br><span class="line">                <span class="built_in">$fdisplay</span>(sdram_mem,<span class="string">"%0h"</span>,Bank0[ee]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cc&lt;=<span class="number">2</span>*mem_sizes+<span class="number">1</span>)</span><br><span class="line">                        <span class="built_in">$fdisplay</span>(sdram_mem,<span class="string">"%0h"</span>,Bank1[ee]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cc&lt;=<span class="number">3</span>*mem_sizes+<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">$fdisplay</span>(sdram_mem,<span class="string">"%0h"</span>,Bank2[ee]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">$fdisplay</span>(sdram_mem,<span class="string">"%0h"</span>,Bank3[ee]);</span><br><span class="line">              <span class="keyword">end</span>                        </span><br><span class="line">          <span class="built_in">$fclose</span>(<span class="string">"sdram_mem.txt"</span>);        </span><br><span class="line">     </span><br><span class="line">      <span class="keyword">end</span>        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    // Timing Parameters for -75 (PC133) and CAS Latency = 2</span></span><br><span class="line"><span class="comment">//    specify</span></span><br><span class="line"><span class="comment">//        specparam</span></span><br><span class="line"><span class="comment">////                    tAH  =  0.8,                                        // Addr, Ba Hold Time</span></span><br><span class="line"><span class="comment">////                    tAS  =  1.5,                                        // Addr, Ba Setup Time</span></span><br><span class="line"><span class="comment">////                    tCH  =  2.5,                                        // Clock High-Level Width</span></span><br><span class="line"><span class="comment">////                    tCL  =  2.5,                                        // Clock Low-Level Width</span></span><br><span class="line"><span class="comment">//////                    tCK  = 10.0,                                       // Clock Cycle Time  100mhz</span></span><br><span class="line"><span class="comment">//////                    tCK  = 7.5,                        // Clock Cycle Time  133mhz</span></span><br><span class="line"><span class="comment">////                    tCK  =  7,                                // Clock Cycle Time  143mhz</span></span><br><span class="line"><span class="comment">////                    tDH  =  0.8,                                        // Data-in Hold Time</span></span><br><span class="line"><span class="comment">////                    tDS  =  1.5,                                        // Data-in Setup Time</span></span><br><span class="line"><span class="comment">////                    tCKH =  0.8,                                        // CKE Hold  Time</span></span><br><span class="line"><span class="comment">////                    tCKS =  1.5,                                        // CKE Setup Time</span></span><br><span class="line"><span class="comment">////                    tCMH =  0.8,                                        // CS#, RAS#, CAS#, WE#, DQM# Hold  Time</span></span><br><span class="line"><span class="comment">////                    tCMS =  1.5;                                        // CS#, RAS#, CAS#, WE#, DQM# Setup Time</span></span><br><span class="line"><span class="comment">//                    tAH  =  1,                                        // Addr, Ba Hold Time</span></span><br><span class="line"><span class="comment">//                    tAS  =  1.5,                                        // Addr, Ba Setup Time</span></span><br><span class="line"><span class="comment">//                    tCH  =  1,                                        // Clock High-Level Width</span></span><br><span class="line"><span class="comment">//                    tCL  =  3,                                        // Clock Low-Level Width</span></span><br><span class="line"><span class="comment">////                    tCK  = 10.0,                                       // Clock Cycle Time  100mhz</span></span><br><span class="line"><span class="comment">////                    tCK  = 7.5,                        // Clock Cycle Time  133mhz</span></span><br><span class="line"><span class="comment">//                    tCK  =  7,                                // Clock Cycle Time  143mhz</span></span><br><span class="line"><span class="comment">//                    tDH  =  1,                                        // Data-in Hold Time</span></span><br><span class="line"><span class="comment">//                    tDS  =  2,                                        // Data-in Setup Time</span></span><br><span class="line"><span class="comment">//                    tCKH =  1,                                        // CKE Hold  Time</span></span><br><span class="line"><span class="comment">//                    tCKS =  2,                                        // CKE Setup Time</span></span><br><span class="line"><span class="comment">//                    tCMH =  0.8,                                        // CS#, RAS#, CAS#, WE#, DQM# Hold  Time</span></span><br><span class="line"><span class="comment">//                    tCMS =  1.5;                                        // CS#, RAS#, CAS#, WE#, DQM# Setup Time</span></span><br><span class="line"><span class="comment">//        $width    (posedge Clk,           tCH);</span></span><br><span class="line"><span class="comment">//        $width    (negedge Clk,           tCL);</span></span><br><span class="line"><span class="comment">//        $period   (negedge Clk,           tCK);</span></span><br><span class="line"><span class="comment">//        $period   (posedge Clk,           tCK);</span></span><br><span class="line"><span class="comment">//        $setuphold(posedge Clk,    Cke,   tCKS, tCKH);</span></span><br><span class="line"><span class="comment">//        $setuphold(posedge Clk,    Cs_n,  tCMS, tCMH);</span></span><br><span class="line"><span class="comment">//        $setuphold(posedge Clk,    Cas_n, tCMS, tCMH);</span></span><br><span class="line"><span class="comment">//        $setuphold(posedge Clk,    Ras_n, tCMS, tCMH);</span></span><br><span class="line"><span class="comment">//        $setuphold(posedge Clk,    We_n,  tCMS, tCMH);</span></span><br><span class="line"><span class="comment">//        $setuphold(posedge Clk,    Addr,  tAS,  tAH);</span></span><br><span class="line"><span class="comment">//        $setuphold(posedge Clk,    Ba,    tAS,  tAH);</span></span><br><span class="line"><span class="comment">//        $setuphold(posedge Clk,    Dqm,   tCMS, tCMH);</span></span><br><span class="line"><span class="comment">//        $setuphold(posedge Dq_chk, Dq,    tDS,  tDH);</span></span><br><span class="line"><span class="comment">//    endspecify</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</div></div><br></font></p>
<h3 id="仿真结果"><a href="#仿真结果" class="headerlink" title="仿真结果"></a>仿真结果</h3><p>我们可以看到基于 sdram_model.v 运行了 201us 个周期后，modelsim 上打印信息显示我们初始化的操作是正确的。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/sdram%E4%BB%BF%E7%9C%9F%E6%95%B0%E6%8D%AE.jpg" alt=""></p>
<p>仿真波形如图所示：<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sdram/sdram%E4%BB%BF%E7%9C%9F%E6%B3%A2%E5%BD%A2.jpg" alt=""></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>我们依芯片手册成功实现了 sdram 的上电初始化，接下来我们将继续进行后续的操作，我们将尽快更新~</p>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p>SDRAM 仿真模型文件：<a href="https://pan.baidu.com/s/1hIPdYfLONydeHYugL0hKig" target="_blank" rel="noopener">点击下载，提取码:yihx</a></p>
<p><strong>By Ricky</strong></p>
]]></content>
      <categories>
        <category>IC Design</category>
        <category>SDRAM</category>
      </categories>
      <tags>
        <tag>IC Design</tag>
        <tag>SDRAM</tag>
      </tags>
  </entry>
  <entry>
    <title>RISC-V 指令集特权架构</title>
    <url>//posts/RISC-V-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%89%B9%E6%9D%83%E6%9E%B6%E6%9E%84.html</url>
    <content><![CDATA[<h1 id="RISC-V-指令集手册"><a href="#RISC-V-指令集手册" class="headerlink" title="RISC-V 指令集手册"></a>RISC-V 指令集手册</h1><h3 id="第二卷：特权架构"><a href="#第二卷：特权架构" class="headerlink" title="第二卷：特权架构"></a>第二卷：特权架构</h3><p><strong>文档版本 20190608</strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文档介绍了 RISC-V 特权架构。此版本为 20190608-Priv-MSU-Ratified，表示已批准的 machine 和 supervisor 模块的指令集。</p>
<p>本文档包含以下版本的RISC-V ISA模块：</p>
<table>
<thead>
<tr>
<th align="center">Module</th>
<th align="center">Version</th>
<th align="center">Status</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Machine ISA</td>
<td align="center">1.11</td>
<td align="center">Ratified</td>
</tr>
<tr>
<td align="center">Supervisor ISA</td>
<td align="center">1.11</td>
<td align="center">Ratified</td>
</tr>
</tbody></table>
<a id="more"></a>

<p>本版本文档的变更包括：</p>
<ul>
<li>将 Machine 和 Supervisor 规范更改到 <strong>Ratified</strong> 状态。</li>
<li>改进说明和注释。</li>
<li>增加了有关虚拟机监控程序扩展的草案。</li>
<li>规定哪些中断源保留供标准使用。</li>
<li>分配了一些同步异常源供自定义使用。</li>
<li>规定了同步异常的优先级顺序。</li>
<li>添加了规范，即如果支持 A 扩展，则 xRET 指令可以清除 LR 保留，但不是必须的。</li>
<li>无论 SUM 如何设置，虚拟内存系统不再允许超级用户（Supervisor）模式执行用户页面中的指令。</li>
<li>强烈建议软件在全局范围内分配 ASID（地址空间 ID），以便将来的扩展可以全局化ASID，以提高性能和硬件灵活性。</li>
<li>SFENCE.VMA 语义已阐明。</li>
<li>将 mstatus.MPP 字段设置为 <strong>WARL</strong>，而不是 <strong>WLRL</strong>。</li>
<li>将未使用的 xip 字段设置为 <strong>WPRI</strong>，而不是 <strong>WIRI</strong>。</li>
<li>将未使用的 misa 字段设置为 <strong>WLRL</strong>，而不是 <strong>WIRI</strong>。</li>
<li>将未使用的 pmpaddr 和 pmpcfg 字段设置为 <strong>WARL</strong>，而不是 <strong>WIRI</strong>。</li>
<li>要求系统中的所有 harts 都采用相同的 PTE-update 格式。</li>
<li>纠正了编辑错误，该错误错误描述了在发生异常时写入 mstatus.xIE 的机制。</li>
<li>描述了用于仿真未对齐 AMOs 的格式。</li>
<li>在可变 IALIGN 的系统中规定了 misa 和 xepc 寄存器的行为。</li>
<li>规定了向 misa 寄存器中写入自相矛盾的值的行为。</li>
<li>定义了 mcountinhibit CSR 寄存器，该寄存器可停止性能计数器的递增以减少功耗。</li>
<li>规定 PMP 区域的语义大于四个字节。</li>
<li>规定跨 XLEN 修改 CSRs 的内容。</li>
<li>将 PLIC 章节移至其自己的文档中。</li>
</ul>
<To do>

<p><strong>译者注：</strong></p>
<blockquote>
<p>这里不是完整版指令集的翻译，只是我个人在学习 RISC-V 实现过程中目前了解到的部分内容。主要关注机器模式（M-mode）的实现部分内容。不完整的地方可查阅 RISC-V 基金会官方文档。</p>
<p>在试译过程中为了便于理解将 RISC-V 架构中有关于<strong>异常</strong> (exception)、<strong>陷阱</strong> (trap) 和<strong>中断</strong> (interrupt)的描述做了一些简化。在 RISC-V 架构中，<strong>异常</strong>指在运行时发生的不寻常情况(包括地址异常、非法指令异常等)，且同步处理；<strong>陷阱</strong>指正常运行的 hart 由另一个hart 条件引起的异常(包括系统 timer、ecall 和 ebreak 等)，且同步的提升到特权模式；<strong>中断</strong>指由外部事件引发的异常(包括但不限于 TIM、GPIO 等外设引起的异常)，且异步地提升到特权模式。但相较于 cpu 在正常运行时的状态来说，这三类情况从广义上来说都属于异常。所以本文中一般情况下所指的异常是比较广义上的异常，必要的地方会有区分。</p>
</blockquote>
<h1 id="第一章-介绍"><a href="#第一章-介绍" class="headerlink" title="第一章 介绍"></a>第一章 介绍</h1><p>本文档介绍了 RISC-V 特权体系结构，它涵盖了非特权 ISA 以外的 RISCV 系统的所有方面，包括特权指令以及运行操作系统和连接外部设备所需的其他功能。</p>
<h2 id="1-1-RISC-V-特权软件堆栈术语"><a href="#1-1-RISC-V-特权软件堆栈术语" class="headerlink" title="1.1 RISC-V 特权软件堆栈术语"></a>1.1 RISC-V 特权软件堆栈术语</h2><p>本节描述了我们用来描述 RISC-V 的各种可能的特权软件栈组件的术语。</p>
<p>下图显示了 RISC-V 架构可以支持的一些可能的软件栈。左侧显示了一个简单的系统，该系统仅支持在应用程序执行环境（AEE）上运行的单个应用程序。该应用程序以一个特定的应用程序二进制接口（ABI）来编码来运行。ABI 包括受支持的用户级 ISA+ 和一组与 AEE 进行交互的 ABI 调用。ABI 在应用程序中隐藏了 AEE 的详细信息，以便在实现 AEE 时具有更大的灵活性。相同的 ABI 可以在多个不同的主机 OS 上原生实现，也可以支持在具有不同本机 ISA 的机器上通过用户模式（U-mode）模拟环境来运行。</p>
<img src="https://s3.ax1x.com/2021/01/03/spxovQ.png" alt="图片1.1" style="zoom:50%;" />

<p><em>图1.1 支持各种特权执行形式的不同实现栈</em></p>
<p>中间配置显示了可以支持多个应用程序的多程序执行的常规操作系统（OS）。每个应用程序通过 ABI 与提供 AEE 的 OS 进行通信。就像应用程序接口通过 ABI 与 AEE 进行通信一样，RISC-V 操作系统也通过管理员二进制接口（SBI）与管理员执行环境（SEE）进行通信。一个 SBI 包括用户级和管理员级 ISA 以及一组 SBI 函数调用。在所有 SEE 实现中使用单个 SBI 可使单个 OS 二进制镜像在任何 SEE 上运行。SEE 可以是低端硬件平台中的简单引导加载程序和 BIOS 风格的 IO 系统，也可以是高端服务器中由管理程序提供的虚拟机，或者在体系结构模拟中可以是主机操作系统上的单薄转换层环境。</p>
<hr>
<p><strong>注</strong>: <em>大多数管理员级别的 ISA 定义并未将 SBI 与执行环境和 / 或硬件平台分开，从而使虚拟化变得复杂，并带来了新的硬件平台。</em></p>
<p>最右边的配置显示了一个虚拟机监视器配置，其中单个虚拟机管理程序支持多个多任务 OS。每个 OS 都通过 SBI 与提供 SEE 的虚拟机管理程序进行通信。虚拟机管理程序使用虚拟层二进制接口（HBI）与虚拟层执行环境（HEE）通信，以将虚拟机管理程序与硬件平台的详细信息隔离开。</p>
<hr>
<p><strong>注</strong>: <em>ABI，SBI 和 HBI 仍在开发中，但是我们现在优先考虑对 Type-2 虚拟机管理程序的支持，其中 SBI 由 S 模式 OS 递归地提供。</em></p>
<p>RISC-V ISA 的硬件实现通常还需要特权 ISA 以外的其他特性来支持各种执行环境（AEE，SEE或HEE）。</p>
<h2 id="1-2-特权等级"><a href="#1-2-特权等级" class="headerlink" title="1.2 特权等级"></a>1.2 特权等级</h2><p>任何时候，RISC-V 硬件线程（hart）都以某种特权级别运行，该特权级别被编码为一个或多个 CSR（控制和状态寄存器）中的一种模式。 当前定义了三个 RISC-V 特权级别，如表1.1所示。</p>
<table>
<thead>
<tr>
<th align="center">Level</th>
<th align="center">Encoding</th>
<th align="center">Name</th>
<th align="center">Abbreviation</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">00</td>
<td align="center">User/Application</td>
<td align="center">U</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">01</td>
<td align="center">Supervisor</td>
<td align="center">S</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">10</td>
<td align="center"><em>Reserved(Hypervisor)</em></td>
<td align="center">(H)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">11</td>
<td align="center">Machine</td>
<td align="center">M</td>
</tr>
</tbody></table>
<p><em>表1.1 RISC-V 特权级别</em></p>
<p>特权级别用于在软件堆栈的不同组件之间提供保护，并且尝试执行当前特权模式不允许的操作将导致引发异常。 这些异常通常会导致进入底层执行环境的陷阱。</p>
<hr>
<p><strong>注</strong>: <em>在描述中，我们尝试将编写代码的特权级别与运行代码的特权模式区分开，尽管两者通常是捆绑在一起的。例如，管理员级别的操作系统可以在具有三种特权模式的系统上以管理员模式运行，但是也可以在具有两种或多种特权模式的系统上的经典虚拟机监视器下以运行用户模式。在这两种情况下，都可以使用相同的管理员级别的操作系统二进制代码，将其编码为管理员级别的 SBI，因此期望能够使用管理员级别的特权指令和 CSR。在用户模式下运行访客 OS 时，所有具有管理员权限的操作都将被以较高特权级别运行的 SEE 捕获并模拟。</em></p>
<p>机器级别具有最高特权，并且是 RISC-V 硬件平台的唯一强制特权级别。在机器模式（M-mode）下运行的代码通常天生就受信任，因为它具有对机器实现的低级访问权限。M-mode 可以用来管理 RISC-V 上的安全执行环境。用户模式（U-mode）和超级用户模式（S-mode）分别用于常规应用程序和操作系统。</p>
<p>每个特权级别都有一组核心的特权 ISA 扩展，以及可选的扩展和变体。 例如，机器模式支持用于内存保护的可选标准扩展。</p>
<p>实现可以提供 1 到 3 种特权模式，以权衡减少隔离度以降低实现成本，如表1.2所示。</p>
<table>
<thead>
<tr>
<th align="center">Number of levels</th>
<th align="left">Supported Modes</th>
<th align="left">Intended Usage</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">M</td>
<td align="left">Simple embedded systems</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">M，U</td>
<td align="left">Secure embedded systems</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">M，S，U</td>
<td align="left">Systems running Unix-like operating systems</td>
</tr>
</tbody></table>
<p><em>表1.2 支持的特权模式组合。</em></p>
<p>所有硬件实现都必须提供 M-mode，因为这是唯一可以不受限制地访问整个计算机的模式。 最简单的 RISC-V 实现可能仅提供 M-mode，尽管这将无法防止错误或恶意的应用程序代码。</p>
<p><strong>注</strong>: <em>可选的 PMP功能的锁定特性，即使只实现 M-mode，可以提供一些有限的保护。</em></p>
<p>许多 RISC-V 实现也将至少支持用户模式（U-mode），以保护系统的其余部分免受应用程序代码的侵害。 可以添加管理员模式（S-mode），以在管理员级别的操作系统和 SEE 之间提供隔离。</p>
<p>Hart 通常以 U-mode 运行应用程序代码，直到某些异常（例如，管理员调用或计时器中断）强制将开关切换到异常处理程序，该异常处理程序通常以更高的特权模式运行。然后，hart 将执行异常处理程序，应用程序最终将在 U-mode 中原异常指令处或之后恢复执行。提高特权级别的 Traps 称为 <strong><em>vertical traps</em></strong>，而保持相同特权级别的 Traps 称为 <strong><em>horizontal traps</em></strong>。RISC-V 特权体系结构可将异常灵活路由到不同的特权层。</p>
<hr>
<p><strong>注</strong>: <em>horizontal traps 可以实现为 vertical traps，在较低特权模式下将控制权返回给 horizontal traps 处理程序。</em></p>
<h2 id="1-3-调试模式"><a href="#1-3-调试模式" class="headerlink" title="1.3 调试模式"></a>1.3 调试模式</h2><p>一个实现还可以包括一个调试模式，以支持片外调试和/或生产测试。调试模式（D-mode）可以被认为是一种额外的特权模式，其访问权限比 M-mode 更大。单独的调试规范建议描述了RISC-V hart 在调试模式下的操作。调试模式保留一些只能在 D-mode 下访问的 CSR 地址，并且还可能保留平台上物理地址空间的某些部分。</p>
<h1 id="第二章-控制和状态寄存器（CSRs"><a href="#第二章-控制和状态寄存器（CSRs" class="headerlink" title="第二章 控制和状态寄存器（CSRs)"></a>第二章 控制和状态寄存器（CSRs)</h1><p>SYSTEM 主操作码用于编码 RISC-V ISA 中的所有特权指令。这些可分为两大类：控制和状态寄存器（CSRs）的原子操作（read-modify-write），以及所有其他特权指令。除了本手册第一卷中描述的用户级别状态外，一个实现还可以包含其他 CSRs，这些特权可以通过使用用户级别手册中描述的 CSR 指令的某些特权级别子集来访问。在本章中，我们规划出 CSR 地址空间。以下各章节根据特权级别描述了每个 CSRs 的功能，以及通常与特定特权级别紧密相关的其他特权指令。请注意，尽管 CSRs 和指令与一个特权级别相关联，但是它们也可以在所有更高的特权级别下访问。</p>
<h2 id="2-1-CSR-地址映射规则"><a href="#2-1-CSR-地址映射规则" class="headerlink" title="2.1 CSR 地址映射规则"></a>2.1 CSR 地址映射规则</h2><p>标准的 RISC-V ISA 留出 12 位编码空间（csr [11:0]），最多可存储 4096 个 CSRs。</p>
<p>按照惯例，CSR 地址的高 4 位（csr [11:8]）用于根据权限级别对 CSRs 的读写可访问性进行编码，如表 2.1 所示。前两位（csr [11:10]）指示寄存器是读/写（00、01 or 10）还是只读（11）。接下来的两位（csr [9:8]）编码可以访问 CSR 的最低特权级别。</p>
<hr>
<p><strong>注</strong>: <em>CSR 地址约定使用 CSR 地址的高位来编码默认访问权限。这简化了硬件中的错误检查，并提供了更大的 CSR 空间，但确实限制了 CSR 到地址空间的映射。实现可能允许更高级别的特权捕获较低级别特权允许的 CSR 访问，以允许拦截这些访问。这个变化应该对特权较少的软件是明晰的。</em></p>
<p>尝试访问不存在的 CSR 会引发一个非法指令异常。尝试在没有适当特权级别的情况下访问 CSR 或写入只读寄存器也会引发非法指令异常。读/写寄存器可能还包含一些只读位，在这种情况下，对只读位的写操作将被忽略。</p>
<p>表 2.1 还列出了在标准用途和自定义用途之间分配CSR地址的约定。保留用于自定义用途的 CSR 地址不会在以后的标准扩展中重新定义。</p>
<p>机器模式标准读写 CSRs 0x7A0–0x7BF 保留供调试系统使用。在这些 CSRs 中，机器模式可访问 0x7A0-0x7AF，而调试模式仅可见 0x7B0-0x7BF。实现应在机器模式访问后一组寄存器时引发非法指令异常。</p>
<hr>
<p><strong>注</strong>: <em>有效的虚拟化要求在虚拟化环境中尽可能多地在本机上运行指令，而任何特权访问都会 trap到虚拟机监视器[1]。如果将具有较低特权级别的只读 CSR 设为具有较高特权级别的读写，则它们将被映射到单独的 CSR 地址中。这样可以避免在允许低特权访问的同时引发 trap，同时仍然导致对非法访问的 trap。 当前，计数器是仅有的影子 CSRs。</em></p>
<h2 id="2-2-CSR-寄存器清单"><a href="#2-2-CSR-寄存器清单" class="headerlink" title="2.2 CSR 寄存器清单"></a>2.2 CSR 寄存器清单</h2><p>表 2.2–2.5 列出的 CSRs 寄存器是当前已分配了 CSR 地址的。timers，counters 和浮点 CSRs 是标准的用户级 CSRs，以及由 N 扩展添加的其他用户 trap 寄存器。其他寄存器由特权代码使用，如以下各章节所述。 请注意，并非所有实现都需要所有寄存器。</p>
<table border=0 cellpadding=0 cellspacing=0 width=704 style='border-collapse:
 collapse;table-layout:fixed;width:477pt'>
 <col width=72 span=3 style='width:62pt'>
 <col width=180 style='mso-width-source:userset;mso-width-alt:3584;width:96pt'>
 <col width=236 style='mso-width-source:userset;mso-width-alt:7552;width:208pt'>
 <col width=72 style='width:54pt'>
 <tr height=19 style='height:14.25pt'>
  <td colspan=3 height=19 width=216 align="center" style='border-right:none;
  height:14.25pt;width:162pt'>CSR Address</td>
  <td rowspan=2  width=180 align="center" style='border-bottom:none;
  width:90pt'>Hex</td>
  <td rowspan=2  width=236 style='border-bottom:none;
  width:177pt'>Use and Accessibility</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19  align="center" style='height:14.25pt;border-top:none'>[11:10]</td>
  <td  align="center" style='border-top:none;border-left:none'>[9:8]</td>
  <td  align="center" style='border-top:none;border-left:none'>[7:4]</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td colspan=5 height=19  align="center" style='border-right:none;
  height:14.25pt'>User CSRs</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>00</td>
  <td align="center" style='border-top:none;border-left:none'>00</td>
  <td align="center" style='border-top:none;border-left:none'>XXXX</td>
  <td align="center" style='border-top:none;border-left:none'>0x000-0x0FF</td>
  <td  style='border-top:none;border-left:none'>Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>01</td>
  <td align="center" style='border-left:none'>00</td>
  <td align="center" style='border-left:none'>XXXX</td>
  <td align="center" style='border-left:none'>0x400-0x4FF</td>
  <td  style='border-left:none'>Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>10</td>
  <td align="center" style='border-left:none'>00</td>
  <td align="center" style='border-left:none'>XXXX</td>
  <td align="center" style='border-left:none'>0x800-0x8FF</td>
  <td  style='border-left:none'>Custom read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>11</td>
  <td align="center" style='border-left:none'>00</td>
  <td align="center" style='border-left:none'>0XXX</td>
  <td align="center" style='border-left:none'>0xC00-0xC7F</td>
  <td  style='border-left:none'>Standard read-only</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>11</td>
  <td align="center" style='border-left:none'>00</td>
  <td align="center" style='border-left:none'>10XX</td>
  <td align="center" style='border-left:none'>0xC80-0xCBF</td>
  <td  style='border-left:none'>Standard read-only</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>11</td>
  <td align="center" style='border-left:none'>00</td>
  <td align="center" style='border-left:none'>11XX</td>
  <td align="center" style='border-left:none'>0xCC0-0xCFF</td>
  <td  style='border-left:none'>Custom read-only</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td colspan=5 height=19  align="center" style='border-right:none;
  height:14.25pt'>Supervisor CSRs</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>00</td>
  <td align="center" style='border-left:none'>01</td>
  <td align="center">XXXX</td>
  <td align="center" style='border-left:none'>0x100-0x1FF</td>
  <td >Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>01</td>
  <td align="center" style='border-left:none'>01</td>
  <td align="center">0XXX</td>
  <td align="center" style='border-left:none'>0x500-0x57F</td>
  <td >Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>01</td>
  <td align="center" style='border-left:none'>01</td>
  <td align="center">10XX</td>
  <td align="center">0x580-0x5BF</td>
  <td >Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>01</td>
  <td align="center" style='border-left:none'>01</td>
  <td align="center">11XX</td>
  <td align="center">0x5C0-0x5FF</td>
  <td >Custom read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>10</td>
  <td align="center" style='border-left:none'>01</td>
  <td align="center">0XXX</td>
  <td align="center">0x900-0x97F</td>
  <td >Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>10</td>
  <td align="center" style='border-left:none'>01</td>
  <td align="center">10XX</td>
  <td align="center">0x980-0x9BF</td>
  <td >Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>10</td>
  <td align="center" style='border-left:none'>01</td>
  <td align="center">11XX</td>
  <td align="center">0x9C0-0x9FF</td>
  <td >Custom read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>11</td>
  <td align="center" style='border-left:none'>01</td>
  <td align="center">0XXX</td>
  <td align="center">0xD00-0xD7F</td>
  <td >Standard read-only</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>11</td>
  <td align="center" style='border-left:none'>01</td>
  <td align="center">10XX</td>
  <td align="center">0xD80-0xDBF</td>
  <td >Standard read-only</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>11</td>
  <td align="center" style='border-left:none'>01</td>
  <td align="center">11XX</td>
  <td align="center">0xDC0-0xDFF</td>
  <td >Custom read-only</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td colspan=5 height=19  align="center" style='border-right:none;
  height:14.25pt'>Hypervisor CSRs</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt;border-top:none'>00</td>
  <td align="center" style='border-top:none;border-left:none'>10</td>
  <td align="center" style='border-top:none;border-left:none'>XXXX</td>
  <td align="center">0x200-0x2FF</td>
  <td  style='border-top:none'>Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>01</td>
  <td align="center" style='border-left:none'>10</td>
  <td align="center" style='border-left:none'>0XXX</td>
  <td align="center">0x600-0x67F</td>
  <td >Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>01</td>
  <td align="center" style='border-left:none'>10</td>
  <td align="center" style='border-left:none'>10XX</td>
  <td align="center">0x680-0x6BF</td>
  <td >Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>01</td>
  <td align="center" style='border-left:none'>10</td>
  <td align="center" style='border-left:none'>11XX</td>
  <td align="center">0x6C0-0x6FF</td>
  <td >Custom read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>10</td>
  <td align="center" style='border-left:none'>10</td>
  <td align="center" style='border-left:none'>0XXX</td>
  <td align="center">0xA00-0xA7F</td>
  <td >Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>10</td>
  <td align="center" style='border-left:none'>10</td>
  <td align="center" style='border-left:none'>10XX</td>
  <td align="center">0xA80-0xABF</td>
  <td >Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>10</td>
  <td align="center" style='border-left:none'>10</td>
  <td align="center" style='border-left:none'>11XX</td>
  <td align="center">0xAC0-0xAFF</td>
  <td >Custom read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>11</td>
  <td align="center" style='border-left:none'>10</td>
  <td align="center" style='border-left:none'>0XXX</td>
  <td align="center">0xE00-0xE7F</td>
  <td >Standard read-only</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>11</td>
  <td align="center" style='border-left:none'>10</td>
  <td align="center" style='border-left:none'>10XX</td>
  <td align="center">0xE80-0xEBF</td>
  <td >Standard read-only</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>11</td>
  <td align="center" style='border-left:none'>10</td>
  <td align="center" style='border-left:none'>11XX</td>
  <td align="center">0xEC0-0xEFF</td>
  <td >Custom read-only</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td colspan=5 height=19  align="center" style='border-right:none;
  height:14.25pt'>Machine CSRs</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt;border-top:none'>00</td>
  <td align="center" style='border-top:none;border-left:none'>11</td>
  <td align="center" style='border-top:none;border-left:none'>XXXX</td>
  <td align="center" style='border-top:none;border-left:none'>0x300-0x3FF</td>
  <td  style='border-top:none;border-left:none'>Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>01</td>
  <td align="center" style='border-left:none'>11</td>
  <td align="center" style='border-left:none'>0XXX</td>
  <td align="center" style='border-left:none'>0x700-0x77F</td>
  <td  style='border-left:none'>Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>01</td>
  <td align="center" style='border-left:none'>11</td>
  <td align="center" style='border-left:none'>100X</td>
  <td align="center" style='border-left:none'>0x780-0x79F</td>
  <td  style='border-left:none'>Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>01</td>
  <td align="center" style='border-left:none'>11</td>
  <td align="center" style='border-left:none'>1010</td>
  <td align="center" style='border-left:none'>0x7A0-0x7AF</td>
  <td  style='border-left:none'>Standard read/write debug CSRs</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>01</td>
  <td align="center" style='border-left:none'>11</td>
  <td align="center" style='border-left:none'>1011</td>
  <td align="center" style='border-left:none'>0x7B0-0x7BF</td>
  <td  style='border-left:none'>Debug-mode-only CSRs</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>01</td>
  <td align="center" style='border-left:none'>11</td>
  <td align="center" style='border-left:none'>11XX</td>
  <td align="center" style='border-left:none'>0x7C0-0x7FF</td>
  <td  style='border-left:none'>Custom read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>10</td>
  <td align="center" style='border-left:none'>11</td>
  <td align="center" style='border-left:none'>0XXX</td>
  <td align="center" style='border-left:none'>0xB00-0xB7F</td>
  <td  style='border-left:none'>Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19  style='height:14.25pt'>10</td>
  <td align="center"style='border-left:none'>11</td>
  <td align="center"style='border-left:none'>10XX</td>
  <td align="center"style='border-left:none'>0xB80-0xBBF</td>
  <td style='border-left:none'>Standard read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19 style='height:14.25pt'>10</td>
  <td align="center"style='border-left:none'>11</td>
  <td align="center"style='border-left:none'>11XX</td>
  <td align="center"style='border-left:none'>0xBC0-0xBFF</td>
  <td style='border-left:none'>Custom read/write</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19 style='height:14.25pt'>11</td>
  <td align="center"style='border-left:none'>11</td>
  <td align="center"style='border-left:none'>0XXX</td>
  <td align="center"style='border-left:none'>0xF00-0xF7F</td>
  <td style='border-left:none'>Standard read-only</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19 style='height:14.25pt'>11</td>
  <td align="center"style='border-left:none'>11</td>
  <td align="center"style='border-left:none'>10XX</td>
  <td align="center"style='border-left:none'>0xF80-0xFBF</td>
  <td style='border-left:none'>Standard read-only</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td align="center"height=19 style='height:14.25pt'>11</td>
  <td align="center"style='border-left:none'>11</td>
  <td align="center"style='border-left:none'>11XX</td>
  <td align="center"style='border-left:none'>0xFC0-0xFFF</td>
  <td style='border-left:none'>Custom read-only</td>
 </tr>
</table>

<p><em>表 2.1 RISC-V CSR地址范围的分配</em></p>
<p><a href="https://imgchr.com/i/sM7OiD" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/09/sM7OiD.png" alt="sM7OiD.png"></a></p>
<p><em>表 2.2 目前分配的 RISC-V 用户级 CSR 地址</em></p>
<p><a href="https://imgchr.com/i/sMHtyR" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/09/sMHtyR.png" alt="sMHtyR.png"></a></p>
<p><em>表 2.3 目前分配的 RISC-V 管理员级 CSR 地址</em></p>
<p><a href="https://imgchr.com/i/sMH7lj" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/09/sMH7lj.png" alt="sMH7lj.png"></a></p>
<p><em>表 2.4 目前分配的 RISC-V 机器级 CSR 地址。</em></p>
<p><a href="https://imgchr.com/i/sMbyNT" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/09/sMbyNT.png" alt="sMbyNT.png"></a></p>
<p><em>表 2.5 目前分配的 RISC-V 机器级 CSR 地址。</em></p>
<h2 id="2-3-CSR-字段规范"><a href="#2-3-CSR-字段规范" class="headerlink" title="2.3 CSR 字段规范"></a>2.3 CSR 字段规范</h2><p>以下定义和缩写用于指定 CSR 中字段的行为。</p>
<h4 id="Reserved-Writes-Preserve-Values-Reads-Ignore-Values-WPRI-（写保留原值，读忽略值）"><a href="#Reserved-Writes-Preserve-Values-Reads-Ignore-Values-WPRI-（写保留原值，读忽略值）" class="headerlink" title="Reserved Writes Preserve Values, Reads Ignore Values (WPRI)（写保留原值，读忽略值）"></a>Reserved Writes Preserve Values, Reads Ignore Values (WPRI)（写保留原值，读忽略值）</h4><p>一些完整的读/写字段保留供将来使用。 当将值写入同一寄存器的其他字段时，软件应忽略从这些字段读取的值，并应保留这些字段中保存的值。 为了向前兼容，不提供这些字段的实现时必须将其硬接线为零。 这些字段在寄存器描述中标记为 WPRI。</p>
<h4 id="Write-Read-Only-Legal-Values-WLRL-（只写或者只写合法值）"><a href="#Write-Read-Only-Legal-Values-WLRL-（只写或者只写合法值）" class="headerlink" title="Write/Read Only Legal Values (WLRL)（只写或者只写合法值）"></a>Write/Read Only Legal Values (WLRL)（只写或者只写合法值）</h4><p>一些读/写 CSR 字段仅为可能的位编码的子集指定行为，而保留其他位编码。软件不应该向这样的字段写入任何合法值以外的内容，并且不应该假定读取将返回合法值，除非最后一次写入是合法值，或者由于另一次操作将寄存器设置为合法值，寄存器还没有被写入。这些字段在寄存器描述中标记为 WLRL。</p>
<p>如果指令试图将不支持的值写入 WLRL 字段，则允许实现，但不要求引发非法指令异常。 当最后一次写入具有非法值时，实现可以在读取WLRL字段时返回任意位模式，但是返回的值应确定性地取决于非法写入值和写入前的字段值。</p>
<h4 id="Write-Any-Values-Reads-Legal-Values-WARL-（写任意值，读合法值）"><a href="#Write-Any-Values-Reads-Legal-Values-WARL-（写任意值，读合法值）" class="headerlink" title="Write Any Values, Reads Legal Values (WARL)（写任意值，读合法值）"></a>Write Any Values, Reads Legal Values (WARL)（写任意值，读合法值）</h4><p>一些读/写 CSR 字段仅针对位编码的子集定义，但允许写入任何值，同时保证每次读取时均返回合法值。 假设编写 CSR 没有其他副作用，则可以通过尝试写入所需的设置然后读取以查看是否保留该值来确定支持值的范围。 这些字段在寄存器说明中标记为 WARL。</p>
<p>在将不支持的值写入 WARL 字段时，实现不会引发异常。 当最后一次写入具有非法值时，实现可以在读取 WARL 字段时返回任何合法值，但是返回的合法值应确定性地取决于非法写入值和写入之前的字段值。</p>
<h2 id="2-4-CSR-宽度调整"><a href="#2-4-CSR-宽度调整" class="headerlink" title="2.4 CSR 宽度调整"></a>2.4 CSR 宽度调整</h2><p>如果更改了 CSR 的宽度（例如，如第 3.1.6.2 节中所述，通过更改 MXLEN 或 UXLEN），则除非另有说明，否则新宽度CSR的可写字段和位是由先前宽度 CSR 确定的，就像通过以下算法确定一样：</p>
<ol>
<li><p>将先前宽度的 CSR 的值复制到相同宽度的临时寄存器中。</p>
</li>
<li><p>对于先前宽度的CSR的只读位，临时寄存器中相同位置的位设置为零。</p>
</li>
<li><p>临时寄存器的宽度更改为新的宽度。 如果新宽度 W 窄于先前宽度，则保留临时寄存器的最低有效 W 位，并丢弃较高有效位。 如果新宽度比以前的宽度宽，则将临时寄存器零扩展到较宽的宽度。</p>
</li>
<li><p>新宽度 CSR 的每个可写字段都采用临时寄存器中相同位置的位值。</p>
</li>
</ol>
<p>更改 CSR 的宽度不是对 CSR 的读取或写入，因此不会触发任何副作用。</p>
<h1 id="第三章-机器级-ISA（Machine-Level-ISA），-版本-1-1"><a href="#第三章-机器级-ISA（Machine-Level-ISA），-版本-1-1" class="headerlink" title="第三章 机器级 ISA（Machine-Level ISA）， 版本 1.1"></a>第三章 机器级 ISA（Machine-Level ISA）， 版本 1.1</h1><p>本章介绍了机器模式（M-mode）下提供的机器级操作，该模式是 RISC-V 系统中的最高特权模式。M-mode 用于对硬件平台的低级别访问，并且是复位时进入的第一个模式。M-mode 也可以用来完成那些在硬件上直接实现太困难或太昂贵的功能。RISC-V 机器级 ISA 包含一个公共核心，该核心可以根据所支持的其他特权级别以及硬件实现的其他详细信息进行扩展。</p>
<h2 id="3-1-Machine-Level-CSRs-机器级-CSRs"><a href="#3-1-Machine-Level-CSRs-机器级-CSRs" class="headerlink" title="3.1 Machine-Level CSRs (机器级 CSRs)"></a>3.1 Machine-Level CSRs (机器级 CSRs)</h2><p>除了本节中描述的机器级 CSRs 外，M-mode 代码还可以访问较低特权级别的所有 CSRs。</p>
<h3 id="3-1-1-机器指令集-ISA-寄存器-misa"><a href="#3-1-1-机器指令集-ISA-寄存器-misa" class="headerlink" title="3.1.1 机器指令集(ISA)寄存器: misa"></a>3.1.1 机器指令集(ISA)寄存器: misa</h3><p>misa CSR 是 WARL 读写寄存器，报告硬件(hart)支持的 ISA。该寄存器在任何实现中都必须是可读的，但是可以返回零值以指示未实现 misa 寄存器，这就需要通过一个单独的非标准机制确定 CPU 功能。</p>
<p><a href="https://imgchr.com/i/sMOvr9" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/09/sMOvr9.png" alt="sMOvr9.png"></a></p>
<p><em>图 3.1 机器 ISA 寄存器（misa）</em></p>
<p>MXL（机器 XLEN）字段编码本机基本整数 ISA 宽度，如表 3.1 所示。MXL 字段在支持多个基本 ISA 宽度的实现中可能是可写的。M-mode 下的有效 XLEN, MXLEN，由 MXL 的设置给出，如果 misa 为零，则有一个固定的值。重置时，MXL 字段始终设置为最广泛支持的 ISA 变种。</p>
<table>
<thead>
<tr>
<th align="center">MXL</th>
<th align="center">XLEN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">128</td>
</tr>
</tbody></table>
<p>misa CSR 为 MXLEN 位宽。如果从 misa 读取的值不为零，该值的 MXL 字段总是表示当前的 MXLEN。如果对 misa 的写操作导致 MXLEN 发生更改，则 MXL 的位置将以新的宽度移动到 misa 的最高有效两位。</p>
<hr>
<p><strong>注</strong>: <em>可以使用返回的 misa 值的符号上的分支，以及可能在符号上左移一个分支和第二个分支，来快速确定基本宽度。这些检查可以用汇编代码编写，而无需知道机器的寄存器宽度（XLEN）。 基本宽度由 XLEN = 2^(MXL + 4) 给出。         如果 misa 为零，则可以通过将立即数 4 放置在一个寄存器中，然后一次将寄存器左移 31位来找到基本宽度。如果在一次移位后为零，则该机器为 RV32。 如果两次移位后为零，则机器为 RV64，否则为 RV128。</em></p>
<p>Extensions 字段对标准扩展的存在进行编码，每个字母都有一个比特（bit 0 编码扩展名“ A” 存在，bit 1 编码扩展名“ B” 存在，直到 bit 25 编码“ Z”）。RV32I，RV64I，RV128I 基本 ISA 的“ I”位置 1，而 RV32E 的“ E”位置 1。Extensions 字段是 WARL 字段，可以包含可写位，其中实现允许修改支持的 ISA。重置时，“Extensions ”字段应包含支持的扩展名的最大集合，并且如果两者均可用，则 “I” 应该被选择而不是 E 。</p>
<p>RV128I 基本 ISA 尚未冻结，尽管本规范的其余大部分有望应用于 RV128，但这个版本的文档仅关注 RV32 和 RV64。</p>
<p>“ G” 位用作转义符，以允许扩展到更大的标准扩展名空间。</p>
<hr>
<p><strong>注</strong>: <em>G 用于指示 IMAFD 组合，因此在 misa CSR 中是多余的，因此我们保留该位以指示存在其他标准扩展。</em></p>
<p>如果分别支持用户和管理员模式，则将设置“ U”和“ S”位。</p>
<p>如果存在任何非标准扩展名，则将设置“ X”位。</p>
<hr>
<p><strong>注</strong>: <em>misa CSR 将 CPU 功能的基本目录暴露给机器模式代码。可以在机器模式中通过探测其他机器寄存器，并检查系统中的其他 ROM 存储器，作为引导过程的一部分来获得更多的信息。                   我们要求较低特权级别执行环境调用，而不是读取 CPU 寄存器来确定每个特权级别可用的功能。这使虚拟化层可以更改在任何级别观察到的 ISA，并支持更丰富的命令界面，而不会增加硬件设计的负担。</em></p>
<p>“ E”位是只读的。 除非将 misa 硬连线为零，否则“ E”位始终读取为“ I”位的补码（<em>补集？</em>）。同时支持 RV32E 和 RV32I 的实现可以通过清除“ I”位来选择 RV32E。</p>
<p><a href="https://imgchr.com/i/sQmQJO" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/09/sQmQJO.png" alt="sQmQJO.png"></a></p>
<p><em>表 3.2 misa 中 Extensions 字段的编码。 保留供将来使用的所有位在读取时必须返回零。</em></p>
<p>如果 ISA 功能 x 取决于 ISA 功能 y，则尝试启用功能 x 但禁用功能 y 会导致两个功能都被禁用。 例如，设置 “ F” = 0 和 “ D” = 1 会导致同时清除“ F”和“ D”。</p>
<p>一个实现可能会对两个或多个 misa 字段的集合设置施加其他约束，在这种情况下，它们将共同充当单个 WARL 字段。 尝试写入不受支持的组合会导致将这些位设置为某些受支持的组合。</p>
<p>写 misa 可能会增加 IALIGN，例如，通过禁用 C 扩展。如果要写入 misa 的指令增加了 IALIGN，而后一条指令的地址未按 IALIGN 位对齐，则将抑制对 misa 的写入，从而使 misa 保持不变。</p>
<h3 id="3-1-2-机器厂商-ID-寄存器-mvendorid"><a href="#3-1-2-机器厂商-ID-寄存器-mvendorid" class="headerlink" title="3.1.2  机器厂商 ID 寄存器: mvendorid"></a>3.1.2  机器厂商 ID 寄存器: mvendorid</h3><p>mvendorid CSR 是一个 32 位只读寄存器，提供核心提供者的 JEDEC 制造商 ID。该寄存器在任何实现中都必须是可读的，但是可以返回 0 值指示该字段未实现或这是非商业实现。</p>
<p><a href="https://imgchr.com/i/sQn1A0" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/09/sQn1A0.png" alt="sQn1A0.png"></a></p>
<p><em>图3.2 Vendor ID 寄存器（mvendorid）</em></p>
<p>JEDEC 制造商 ID 通常编码为单字节连续的 0x7f 代码的序列，以不等于 0x7f 的单字节 ID 终止，并且在每个字节的最高有效位中带有奇校验位。mvendorid 在 Bank 字段中编码单字节的连续代码，并在 Offset 字段中编码最后一个字节，丢弃奇偶校验位。例如，JEDEC 制造商ID 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x8a（十二个连续代码，后跟 0x8a）将在 mvendorid 字段中编码为 0x60a。</p>
<hr>
<p><strong>注</strong>: <em>以前，供应商 ID 是 RISC-V 基金会分配的编号，但这与 JEDEC 在维护制造商 ID 标准方面的工作重复。 在撰写本文时，向 JEDEC 注册制造商 ID 的一次性费用为 500 美元。</em></p>
<h3 id="3-1-3-机器架构-ID-寄存器-marchid"><a href="#3-1-3-机器架构-ID-寄存器-marchid" class="headerlink" title="3.1.3 机器架构 ID 寄存器: marchid"></a>3.1.3 机器架构 ID 寄存器: marchid</h3><p>marchid CSR 是 MXLEN 位的只读寄存器，用于编码 hart 的基本微体系结构。该寄存器在任何实现中都必须是可读的，但是可以返回 0 值以指示未实现该字段。 mvendorid 和 marchid 的组合应该唯一地标识所实现的 hart 微体系结构的类型。</p>
<p><a href="https://imgchr.com/i/sQMCnJ" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/09/sQMCnJ.png" alt="sQMCnJ.png"></a></p>
<p><em>图 3.3 机器架构 ID 寄存器（marchid）</em></p>
<p>开源项目体系结构 IDs 由 RISC-V 基金会全局分配，并且具有非零体系结构 IDs，其中最高有效位（MSB）为零。商业体系结构 IDs 由每个商业供应商独立分配，但是必须设置 MSB，并且在其余 MXLEN-1 位中不能包含零。</p>
<hr>
<p><strong>注</strong>: *</p>
<h3 id="3-1-4-机器实现-ID-寄存器-mimpid"><a href="#3-1-4-机器实现-ID-寄存器-mimpid" class="headerlink" title="3.1.4 机器实现 ID 寄存器: mimpid"></a>3.1.4 机器实现 ID 寄存器: mimpid</h3><To do>

<h3 id="3-1-5-Hart-ID-寄存器-mhartid"><a href="#3-1-5-Hart-ID-寄存器-mhartid" class="headerlink" title="3.1.5 Hart ID 寄存器: mhartid"></a>3.1.5 Hart ID 寄存器: mhartid</h3><To do>

<h3 id="3-1-6-机器状态寄存器：mstatus"><a href="#3-1-6-机器状态寄存器：mstatus" class="headerlink" title="3.1.6 机器状态寄存器：mstatus"></a>3.1.6 机器状态寄存器：mstatus</h3><p>mstatus 寄存器是一个 MXLEN 位读/写寄存器，其格式在 RV32 上的如图 3.6 和在 RV64 如图 3.7 所示。mstatus 寄存器跟踪并控制 hart 的当前操作状态。 mstatus 寄存器的受限视图分别在 S 级和 U 级 ISA 中显示为 sstatus 和 ustatus 寄存器。</p>
<p><a href="https://imgchr.com/i/sQINkD" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/10/sQINkD.png" alt="sQINkD.png"></a></p>
<p><em>图 3.6 RV32下机器模式状态寄存器 (mstatus)</em></p>
<p><a href="https://imgchr.com/i/sQIUte" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/10/sQIUte.png" alt="sQIUte.png"></a></p>
<p><em>图 3.7 RV64 下机器模式状态寄存器 (mstatus)</em></p>
<h4 id="3-1-6-1-mstatus-寄存器中的特权和全局中断使能栈"><a href="#3-1-6-1-mstatus-寄存器中的特权和全局中断使能栈" class="headerlink" title="3.1.6.1 mstatus 寄存器中的特权和全局中断使能栈"></a>3.1.6.1 mstatus 寄存器中的特权和全局中断使能栈</h4><p>为每种特权模式提供了全局中断使能位 MIE，SIE 和 UIE。这些位主要用于保证当前特权模式下中断处理程序的原子性。</p>
<hr>
<p><strong>注</strong>: <em>全局 xIE 位位于 mstatus 的低位，因此可以通过一条 CSR 指令自动设置或清除它们。</em></p>
<p>当 hart 在 x 特权模式中执行时，当 xIE = 1 时中断被全局启用，当 xIE = 0 时中断被全局禁用。无论低特权模式的全局 wIE 位如何设置，w &lt; x，较低特权模式的中断总是会全局禁用。无论高特权模式的全局 yIE 位如何设置，y &gt; x，始终会全局启用高特权模式的中断。特权级别较高的代码可以使用单独的每个中断启用位来禁用选定的较高级别的特权模式中断，然后再将控制权移交给较低级别的特权模式。</p>
<hr>
<p><strong>注</strong>: <em>较高特权模式 y 可以在将控制权移交给较低特权模式之前禁用其所有中断，但这将是不寻常的，因为它将仅留下同步异常 (trap)，不可屏蔽的中断或重置以重新获得对 hart 的控制。</em></p>
<p>为了支持异常 (traps) 嵌套，每个 x 特权模式都有一个两级的堆栈，其中包括中断使能位和特权模式。xPIE 保留异常之前活动的中断使能位的值，而 xPP 保留先前的特权模式。xPP 字段最多只能保留 x 的特权模式，因此 MPP 为 2 位宽，SPP 为 1 位宽，UPP 隐式为 0。当异常从特权模式 y 进入特权模式 x 时，xPIE 设置为 xIE 的值； xIE 设置为 0；并且 xPP 设置为 y。</p>
<hr>
<p><strong>注</strong>: <em>对于低特权模式，任何异常（同步或者异步）通常都以更高的特权模式进行，进入时禁用中断。更高级别的 trap 处理程序要么为 trap 提供服务，然后使用堆栈的信息返回，要么（如果没有立即返回到被中断的上下文）在重新启用中断之前保存特权堆栈，因此每个堆栈只需要一个入口。</em></p>
<p>MRET，SRET 或 URET 指令分别用于从 M-mode，S-mode 或 U-mode 的异常返回。当执行 xRET 指令时，假设 xPP 保持值 y，则 xIE 设置为 xPIE； 特权模式更改为 y； xPIE 设置为 1； 并且 xPP 设置为 U（如果不支持用户模式，则为 M）。</p>
<p>xPP 字段是 WARL 字段，只能包含 x 特权模式 和任何低于 x 的已实现特权模式。 如果未实现 x 特权模式，则必须将 xPP 硬接线为 0。</p>
<hr>
<p><strong>注</strong>: <em>M-mode 软件可以通过将特权模式写入 MPP 然后将其读回来确定是否实现了特权模式。      如果机器仅提供 U 和 M 模式，则仅需要单个硬件存储位即可表示 MPP 中的 00 或 11。</em></p>
<p>用户级中断是可选的扩展，并已分配 ISA 扩展字母 N。 如果省略了用户级中断，则 UIE 和 UPIE 位被硬接线为零。对于所有其他受支持的 x 特权模式，不得对 xIE 和 xPIE 进行硬接线。</p>
<hr>
<p><strong>注</strong>: <em>用户级中断的主要目的是支持仅包含 M-mode 和 U-mode 的安全嵌入式系统，但也可以在运行类 Unix 操作系统的系统中支持的用户级中断，以支持用户级异常处理。</em></p>
<h4 id="3-1-6-2-mstatus-寄存器中基本-ISA-控制"><a href="#3-1-6-2-mstatus-寄存器中基本-ISA-控制" class="headerlink" title="3.1.6.2 mstatus 寄存器中基本 ISA 控制"></a>3.1.6.2 mstatus 寄存器中基本 ISA 控制</h4><p>对于 RV64 系统，SXL 和 UXL 字段是 WARL 字段，分别控制 S-mode 和 U-mode  的 XLEN 值。这些字段的编码与 misa 的 MXL 字段相同，如表 3.1 所示。 S-mode 和 U-mode  下的有效 XLEN 分别称为 SXLEN 和 UXLEN。</p>
<p>对于 RV32 系统，SXL 和 UXL 字段不存在，并且 SXLEN = 32 和 UXLEN = 32。</p>
<p>对于 RV64 系统，如果不支持 S-mode，则 SXL 硬接线为零。 否则，它是一个 WARL 字段，对 SXLEN 的当前值进行编码。 特别地，该实现可以硬连线 SXL，使得 SXLEN = MXLEN。</p>
<p>对于 RV64 系统，如果不支持 U-mode，则 UXL 硬接线为零。 否则，它是一个 WARL 字段，对 UXLEN 的当前值进行编码。 特别地，该实现可以硬编码 UXL，使得 UXLEN = MXLEN 或 UXLEN = SXLEN。</p>
<p>只要在任何模式下将 XLEN 的值设置为小于支持的最大 XLEN 的值，所有操作都必须忽略配置的 XLEN 上方的源操作数寄存器位，并且必须对结果进行符号扩展以填充目标寄存器中整个支持的最大 XLEN。</p>
<p>如果 MXLEN 从 32 更改为更宽的宽度，则 mstatus 字段 SXL 和 UXL 中的每个（如果未硬接线为强制值）将获得与最大支持宽度对应的值，该宽度不比新 MXLEN 宽。</p>
<h4 id="3-1-6-3-mstatus-寄存器中内存特权"><a href="#3-1-6-3-mstatus-寄存器中内存特权" class="headerlink" title="3.1.6.3 mstatus 寄存器中内存特权"></a>3.1.6.3 mstatus 寄存器中内存特权</h4><To do>

<h4 id="3-1-6-4-mstatus-寄存器中虚拟化支持"><a href="#3-1-6-4-mstatus-寄存器中虚拟化支持" class="headerlink" title="3.1.6.4 mstatus 寄存器中虚拟化支持"></a>3.1.6.4 mstatus 寄存器中虚拟化支持</h4><To do>

<h4 id="3-1-6-5-mstatus-寄存器中扩展上下文状态-Extension-Context-Status"><a href="#3-1-6-5-mstatus-寄存器中扩展上下文状态-Extension-Context-Status" class="headerlink" title="3.1.6.5 mstatus 寄存器中扩展上下文状态(Extension Context Status)"></a>3.1.6.5 mstatus 寄存器中扩展上下文状态(Extension Context Status)</h4><p>支持大量扩展是 RISC-V 的主要目标之一，因此，我们定义了一个标准接口，以允许不变的特权模式代码（尤其是管理员级别的 OS）支持任意的用户模式状态扩展。</p>
<To do>

<p>FS [1：0] WARL字段和XS [1：0]只读字段分别用于通过设置和跟踪浮点单元和任何其他用户模式扩展的当前状态来减少上下文保存和还原的成本。</p>
<To do>

<h3 id="3-1-7-机器异常向量-Trap-Vector-基地址寄存器-mtvec"><a href="#3-1-7-机器异常向量-Trap-Vector-基地址寄存器-mtvec" class="headerlink" title="3.1.7 机器异常向量(Trap-Vector)基地址寄存器: mtvec"></a>3.1.7 机器异常向量(Trap-Vector)基地址寄存器: mtvec</h3><p>mtvec 寄存器是 MXLEN 位的读/写寄存器，用于保存异常向量配置， 由向量基址（BASE）和向量模式（MODE）组成。</p>
<p><img src="C:%5CUsers%5CBH6BAO%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210111141718084.png" alt="image-20210111141718084"></p>
<p><em>图 3.8 机器异常向量基地址寄存器 (mtvec)</em></p>
<p>mtvec 寄存器必须始终实现，但可以包含硬连线的只读值。 如果 mtvec 是可写的，则寄存器可能保存的一组值可能因实现而异。 BASE 字段中的值必须始终在 4 字节边界上对齐，并且 MODE 设置可能会对 BASE 字段中的值施加其他对齐约束。</p>
<hr>
<p><strong>注</strong>: <em>我们在实现 trap 向量基址时具有相当大的灵活性。 一方面，我们不希望负担大量状态位给底层实现带来负担，但另一方面，我们希望为更大的系统提供灵活性。</em></p>
<p><a href="https://imgchr.com/i/s37vLj" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/11/s37vLj.png" alt="s37vLj.png"></a></p>
<p><em>表 3.5 mtvec MODE 字段编码</em></p>
<p>表 3.5 中显示了 MODE 字段的编码。 当 MODE = Direct 时，所有进入机器模式的 trap 都会导致将 pc 设置为 BASE 字段中的地址。当 MODE = Vectored 时，进入机器模式的所有同步异常都将 pc 设置为 BASE 字段中的地址，而中断将 pc 设置为 BASE 字段中的地址加上四倍的中断 cause 编号。例如，机器模式计时器中断导致将 PC 设置为 BASE + 0x1c（请参阅表 3.6）。</p>
<hr>
<p><strong>注</strong>: <em>启用向量中断后，与用户模式软件中断相对应的中断 cause 0 被向量到与同步异常相同的位置。 由于用户模式软件中断被禁用或委托给特权较少的模式，因此在实践中不会出现这种歧义。</em></p>
<p>对于不同的模式，实现可能具有不同的对齐约束。 特别的是，MODE = Vectored 可能比 MODE = Direct 更严格的对齐约束。</p>
<h3 id="3-1-8-机器异常-Trap-委托寄存器-medeleg-and-mideleg"><a href="#3-1-8-机器异常-Trap-委托寄存器-medeleg-and-mideleg" class="headerlink" title="3.1.8 机器异常(Trap)委托寄存器:(medeleg and mideleg)"></a>3.1.8 机器异常(Trap)委托寄存器:(medeleg and mideleg)</h3><h3 id="3-1-9-机器中断寄存器-mip-和-mie"><a href="#3-1-9-机器中断寄存器-mip-和-mie" class="headerlink" title="3.1.9 机器中断寄存器:(mip 和 mie)"></a>3.1.9 机器中断寄存器:(mip 和 mie)</h3><p>mip 寄存器是 MXLEN 位读/写寄存器，包含有关挂起的中断的信息，而 mie 是对应的 MXLEN 位读/写寄存器，包含中断使能位。通过该 CSR 地址只能写入 mip 中的低特权软件中断（USIP，SSIP），定时器中断（UTIP，STIP）和外部中断（UEIP，SEIP）所对应的位； 其余位是只读的。</p>
<hr>
<p><strong>注</strong>: <em>机器级中断寄存器处理一些根中断源，为简单起见，这些中断源被分配了固定的服务优先级，而单独的外部中断控制器可以对更大的一组中断实施更复杂的优先级排序方案，然后将这些中断混和到机器级 中断源。</em></p>
<p>mip 和 mie 寄存器的受限视图分别以 sip / sie 和 uip / uie 寄存器的形式出现在 S-mode 和 U-mode 下。 如果通过在 mideleg 寄存器中设置一个位将中断委托给 x 特权模式，则该中断在 x ip 寄存器中可见，并且可以使用 x ie 寄存器屏蔽。否则，x ip 和 x ie 中的相应位呈现硬连接为零。</p>
<p><a href="https://imgchr.com/i/sGp4Dx" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/11/sGp4Dx.png" alt="sGp4Dx.png"></a></p>
<p><em>图 3.11 机器中断挂起寄存器</em></p>
<p>MTIP，STIP，UTIP 位对应于机器级，管理员级和用户级的定时器中断。MTIP 位是只读的，可通过写入内存映射的机器模式定时器比较寄存器来清除。UTIP 和 STIP 位可以由 M-mode 软件写入，以将计时器中断传递到较低的特权级别。 用户和管理员层软件可以分别通过调用 AEE 和 SEE 来清除 UTIP 和 STIP 位。</p>
<p><a href="https://imgchr.com/i/sG9jW4" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/11/sG9jW4.png" alt="sG9jW4.png"></a></p>
<p><em>图 3.12 机器中断使能寄存器</em></p>
<p>有一个单独的定时器中断使能位，分别称为 MTIE，STIE 和 UTIE，分别用于 M 模式，S 模式和 U 模式定时器中断使能。</p>
<p>每个较低的权限级别都有一个单独的软件挂起中断位( SSIP、USIP )， CSR 访问本地 hart 上运行的代码可以在相关的权限级别或任何更高的权限级别上读写该位。机器级别的 MSIP 位是通过访问内存映射的控制寄存器来写入的，远程 harts 使用这些寄存器来提供机器模式的处理器间中断。较低特权级别的处理器间中断是通过特定于实现的机制来实现的，例如，通过对 AEE 或 SEE 的调用，这可能最终导致对接收方 hart 的机器模式写操作是 MSIP 位。 hart 可以使用相同的内存映射控制寄存器写入自己的 MSIP 位。</p>
<p>mie CSR 中的 MSIE，SSIE 和 USIE 字段分别启用M模式软件中断，S 模式软件中断和 U 模式软件中断。</p>
<hr>
<p><strong>注</strong>: <em>当以适当的模式运行时，我们仅允许 hart 直接写入自己的 SSIP 或 USIP 位，因为其他 hart 可能会被虚拟化，并可能被更高的特权级别调度。因此，我们依靠对 AEE 和 SEE 的调用来提供处理器间中断。机器模式的 hart 不是虚拟化的，可以通过设置它们的 MSIP 位直接中断其他 hart，通常根据平台规范使用未缓存的 I/O 写入内存映射控制寄存器。</em></p>
<p>mip 中的 MEIP 字段是一个只读位，指示机器模式外部中断正在处理中。 MEIP 由特定于平台的中断控制器设置和清除。 设置时，mie 中的 MEIE 字段启用机器外部中断。 </p>
<p>mip 中的 SEIP 字段包含单个读写位。 SEIP 可由 M 模式软件编写，以指示 S 模式外部中断正在处理。 此外，平台级别的中断控制器可能会生成主管级别的外部中断。 软件可写位的逻辑或与来自外部中断控制器的信号用于生成对管理程序的外部中断。 当使用 CSRRW，CSRRS 或 CSRRC 指令读取 SEIP 位时，在第一个目标寄存器中返回的值包含软件可写位的逻辑或，以及来自中断控制器的中断信号。 但是，在 CSRRS 或 CSRRC 指令的读-修改-写序列中使用的值只是软件可写 SEIP 位，而忽略了来自外部中断控制器的中断值。 </p>
<h3 id="3-1-10-机器时间寄存器-mtime-和-mtimecmp"><a href="#3-1-10-机器时间寄存器-mtime-和-mtimecmp" class="headerlink" title="3.1.10 机器时间寄存器:(mtime 和 mtimecmp)"></a>3.1.10 机器时间寄存器:(mtime 和 mtimecmp)</h3><h3 id="3-1-11-硬件性能监控器"><a href="#3-1-11-硬件性能监控器" class="headerlink" title="3.1.11 硬件性能监控器"></a>3.1.11 硬件性能监控器</h3><h3 id="3-1-12-计数器使能寄存器-m-s-counteren"><a href="#3-1-12-计数器使能寄存器-m-s-counteren" class="headerlink" title="3.1.12 计数器使能寄存器:([m|s]counteren)"></a>3.1.12 计数器使能寄存器:([m|s]counteren)</h3><h3 id="3-1-13-机器计数器禁止-CSR-寄存器-mcountinhibit"><a href="#3-1-13-机器计数器禁止-CSR-寄存器-mcountinhibit" class="headerlink" title="3.1.13 机器计数器禁止 CSR 寄存器:(mcountinhibit)"></a>3.1.13 机器计数器禁止 CSR 寄存器:(mcountinhibit)</h3><h3 id="3-1-14-机器暂存寄存器-mscratch"><a href="#3-1-14-机器暂存寄存器-mscratch" class="headerlink" title="3.1.14 机器暂存寄存器:(mscratch)"></a>3.1.14 机器暂存寄存器:(mscratch)</h3><h3 id="3-1-15-机器异常程序计数器-mepc-——指向发生异常PC地址"><a href="#3-1-15-机器异常程序计数器-mepc-——指向发生异常PC地址" class="headerlink" title="3.1.15 机器异常程序计数器:(mepc) ——指向发生异常PC地址"></a>3.1.15 机器异常程序计数器:(mepc) ——指向发生异常PC地址</h3><h3 id="3-1-16-机器异常源寄存器-mcause-——-异常源-or-中断号-or-异常种类？"><a href="#3-1-16-机器异常源寄存器-mcause-——-异常源-or-中断号-or-异常种类？" class="headerlink" title="3.1.16 机器异常源寄存器:(mcause)——(异常源 or 中断号 or 异常种类？)"></a>3.1.16 机器异常源寄存器:(mcause)——(异常源 or 中断号 or 异常种类？)</h3><h3 id="3-1-17-机器异常值寄存器-mtval"><a href="#3-1-17-机器异常值寄存器-mtval" class="headerlink" title="3.1.17 机器异常值寄存器:(mtval)"></a>3.1.17 机器异常值寄存器:(mtval)</h3><h2 id="3-2-机器模式-M-mode-特权指令"><a href="#3-2-机器模式-M-mode-特权指令" class="headerlink" title="3.2 机器模式(M-mode)特权指令"></a>3.2 机器模式(M-mode)特权指令</h2><h3 id="3-2-1-环境调用和断点-ECALL-和-EBREAK"><a href="#3-2-1-环境调用和断点-ECALL-和-EBREAK" class="headerlink" title="3.2.1 环境调用和断点:(ECALL 和 EBREAK)"></a>3.2.1 环境调用和断点:(ECALL 和 EBREAK)</h3><h3 id="3-2-2-异常返回指令-Trap-return"><a href="#3-2-2-异常返回指令-Trap-return" class="headerlink" title="3.2.2  异常返回指令(Trap-return)"></a>3.2.2  异常返回指令(Trap-return)</h3><h3 id="3-2-3-等待中断指令-WFI"><a href="#3-2-3-等待中断指令-WFI" class="headerlink" title="3.2.3  等待中断指令:(WFI)"></a>3.2.3  等待中断指令:(WFI)</h3><h2 id="3-3-复位-Reset"><a href="#3-3-复位-Reset" class="headerlink" title="3.3 复位(Reset)"></a>3.3 复位(Reset)</h2><h2 id="3-4-不可屏蔽中断-NMI"><a href="#3-4-不可屏蔽中断-NMI" class="headerlink" title="3.4 不可屏蔽中断(NMI)"></a>3.4 不可屏蔽中断(NMI)</h2><h2 id="3-5-物理内存特性-PMA"><a href="#3-5-物理内存特性-PMA" class="headerlink" title="3.5 物理内存特性(PMA)"></a>3.5 物理内存特性(PMA)</h2><h3 id="3-5-1-主内存对-I-O-设备和空白区域"><a href="#3-5-1-主内存对-I-O-设备和空白区域" class="headerlink" title="3.5.1 主内存对 I/O 设备和空白区域"></a>3.5.1 主内存对 I/O 设备和空白区域</h3><h3 id="3-5-2-PMAs-支持的访问类型"><a href="#3-5-2-PMAs-支持的访问类型" class="headerlink" title="3.5.2 PMAs 支持的访问类型"></a>3.5.2 PMAs 支持的访问类型</h3><h3 id="3-5-3-PMAs-的原子操作"><a href="#3-5-3-PMAs-的原子操作" class="headerlink" title="3.5.3 PMAs 的原子操作"></a>3.5.3 PMAs 的原子操作</h3><h3 id="3-5-4-PMAs-内存排序操作"><a href="#3-5-4-PMAs-内存排序操作" class="headerlink" title="3.5.4 PMAs 内存排序操作"></a>3.5.4 PMAs 内存排序操作</h3><h3 id="3-5-5-PMAs-的一致性和可缓存性"><a href="#3-5-5-PMAs-的一致性和可缓存性" class="headerlink" title="3.5.5 PMAs 的一致性和可缓存性"></a>3.5.5 PMAs 的一致性和可缓存性</h3><h3 id="3-5-6-PMAs-幂等性"><a href="#3-5-6-PMAs-幂等性" class="headerlink" title="3.5.6 PMAs 幂等性"></a>3.5.6 PMAs 幂等性</h3><h2 id="3-6-物理内存保护-PMP"><a href="#3-6-物理内存保护-PMP" class="headerlink" title="3.6 物理内存保护(PMP)"></a>3.6 物理内存保护(PMP)</h2><h3 id="3-6-1-CSRs-的物理内存保护寄存器-PMP-CSR"><a href="#3-6-1-CSRs-的物理内存保护寄存器-PMP-CSR" class="headerlink" title="3.6.1 CSRs 的物理内存保护寄存器(PMP CSR)"></a>3.6.1 CSRs 的物理内存保护寄存器(PMP CSR)</h3><h3 id="3-6-2-物理内存保护和分页"><a href="#3-6-2-物理内存保护和分页" class="headerlink" title="3.6.2 物理内存保护和分页"></a>3.6.2 物理内存保护和分页</h3>]]></content>
      <categories>
        <category>RISC-V</category>
      </categories>
      <tags>
        <tag>RISC-V</tag>
        <tag>指令集</tag>
        <tag>特权架构</tag>
      </tags>
  </entry>
  <entry>
    <title>简单了解一下小米 vela</title>
    <url>//posts/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E5%B0%8F%E7%B1%B3-vela.html</url>
    <content><![CDATA[<h2 id="0x00-小米-vela"><a href="#0x00-小米-vela" class="headerlink" title="0x00 小米 vela"></a>0x00 小米 vela</h2><p>前段时间小米推出了 vela 物联网平台，vela 就是基于 NuttX 打造的物联网开发平台。</p>
<a id="more"></a>

<p>小米对 NuttX 的评价：</p>
<blockquote>
<ol>
<li>NuttX 对 POSIX 标准有原生兼容：NuttX 是可商用化 RTOS 中唯一一个对 POSIX API 有原生支持的实时操作系统，所以很多 Linux 社区的开源软件可以很方便的移植到 NuttX 上，这样可以极大的简化开源软件移植，方便代码复用，降低学习曲线，其它 RTOS 需要适配层把 POSIX API 转成内部 API，而且通常只兼容一小部分的 POSIX 接口。</li>
<li>完成度高：NuttX 集成了文件系统、网络协议栈、图形库和驱动框架，减少开发成本。</li>
<li>模块化设计：所有组件甚至组件内部特性，都可以通过配置 Kconfig 来调整或关闭，可按需对系统进行裁剪，适用于不同产品形态。</li>
<li>代码精简：所有组件都是从头编码，专门对代码和数据做了优化设计。</li>
<li>轻量级：虽然 NuttX 实现了传统操作系统的所有功能，但是最终生成的代码尺寸还是可以很小（最小配置不到 32KB，最大配置不超过 256KB）。</li>
<li>和 Linux 系统的兼容性：因为 NuttX 整体设计、代码组织，编译过程和 Linux 非常接近，将会极大地降低 Android/Linux 开发者的迁移成本。</li>
<li>活跃开放的社区：很多厂商（比如小米、Sony，乐鑫、NXP 等）和开源爱好者都在积极回馈社区。</li>
</ol>
</blockquote>
<p>不难看出小米对 NuttX 的评价很不错。所以我也来赶紧学习一波，做了一个简单的了解，作为自己的技术储备。</p>
<h2 id="0x01-安装配置"><a href="#0x01-安装配置" class="headerlink" title="0x01 安装配置"></a>0x01 安装配置</h2><p>环境： Ubuntu20.04 系统、ARM GUN 2019q4 版本 gcc、openocd 0.10 版本</p>
<p>安装  ARM gcc 工具链，如果开发板是用其他的架构 cpu 请去安装其他架构下相应的版本工具链，我这里是 ARM 的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir /opt/gcc</span><br><span class="line">sudo chgrp -R users /opt/gcc</span><br><span class="line"><span class="built_in">cd</span> /opt/gcc</span><br><span class="line">wget https://developer.arm.com/-/media/Files/downloads/gnu-rm/9-2019q4/gcc-arm-none-eabi-9-2019-q4-major-x86_64-linux.tar.bz2</span><br><span class="line">tar xf gcc-arm-none-eabi-9-2019-q4-major-x86_64-linux.tar.bz2</span><br></pre></td></tr></table></figure>

<p>配置工具链到系统环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=/opt/gcc/gcc-arm-none-eabi-9-2019-q4-major/bin:<span class="variable">$PATH</span>"</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>下载 nuttx 、apps、tools 三个 nuttx 系统源码及构建工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir nuttxWS</span><br><span class="line"><span class="built_in">cd</span> nuttxWS</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/apache/incubator-nuttx.git nuttx</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/apache/incubator-nuttx-apps apps</span><br><span class="line">git <span class="built_in">clone</span> https://bitbucket.org/nuttx/tools.git tools</span><br></pre></td></tr></table></figure>

<p>安装 kconfig ，构建工具。注意：低于 ubuntu20 版本的安装要少许麻烦一些</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt install kconfig-frontends</span><br></pre></td></tr></table></figure>

<p>查看 nuttx 支持的板卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> nuttxWS</span><br><span class="line">$ ./tools/configure.sh -L | less</span><br></pre></td></tr></table></figure>

<p>选择相应的板卡及其支持的应用程序进行配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> nuttxWS</span><br><span class="line">$ ./tools/configure.sh -l &lt;board-name&gt;:&lt;config-dir&gt;</span><br><span class="line"><span class="comment"># for instance:</span></span><br><span class="line">$ ./tools/configure.sh -l stm32f103-minimum:nsh</span><br></pre></td></tr></table></figure>

<p>运行 menuconfig 进行自定义配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make menuconfig</span><br></pre></td></tr></table></figure>

<h2 id="0x02-编译运行"><a href="#0x02-编译运行" class="headerlink" title="0x02 编译运行"></a>0x02 编译运行</h2><p>配置完成后编译 NuttX 系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make -j$(nproc)</span><br></pre></td></tr></table></figure>

<p>编译完成后会在 nuttx 目录下生成一个 nuttx.bin 文件，接下来把他下载到板子是运行<br>首先安装 openocd </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install openocd</span><br></pre></td></tr></table></figure>

<p>如果使用 apt 安装的 openocd 版本过低，就自己从源码安装一下 openocd 即可</p>
<p>Openocd 安装好之后，正确连接板卡和电脑，下载程序。<br>烧写程序之前可以先打开串口，当系统正常运行起来之后可以在串口中观察到 <code>nsh&gt;</code> 命令行。注意，我这边是 stlink 的虚拟串口所以是 ACM0，你的如果不是虚拟串口，可能是 USB0 之类的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  picocom -b 115200 /dev/ttyACM0</span><br></pre></td></tr></table></figure>

<p>下载程序需要注意正确选择你使用的下载器和板卡对应的 .cfg 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> nuttxWS</span><br><span class="line">$ openocd -f interface/stlink-v2-1.cfg -f target/stm32f1x.cfg -c <span class="string">'init'</span>  -c <span class="string">'program nuttx.bin 0x08000000 verify reset'</span> -c <span class="string">'shutdown'</span></span><br></pre></td></tr></table></figure>

<p>如果程序正常运行了就可以在中观察到信息，输入 help 命令就可以查看支持的命令列表。如果没有看到信息，reset 一下板子。</p>
<p>修改配置编译一个 blinking 控制 led 的程序</p>
<p>回到 nuttx 目录下清除原来的配置，重新生成，在 menuconfig 中检查 led 相关配置是否设置成功。在 NSH library 中使能 printf 功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> nuttxWS/nuttx</span><br><span class="line">$ make distclean</span><br><span class="line">$ ./tools/configure.sh -l stm32f103-minimum:userled</span><br><span class="line">$ make menuconfig</span><br><span class="line">$ make -j$(nproc)</span><br></pre></td></tr></table></figure>

<p>编译完成后下载到板卡上，打开串口，按一下 reset 连接上板子就可以在串口看到输出的信息了。直接执行 leds ，可以看到板卡上的 led 已经正常运行起来了。</p>
<p>今天就先点个灯了解一下，其他的内容，等我翻翻 NuttX 源码在学习一下。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>NuttX</category>
      </categories>
      <tags>
        <tag>vela</tag>
        <tag>NuttX</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 RISC-V 软件开发生态之 IDE</title>
    <url>//posts/%E6%B5%85%E8%B0%88-RISC-V-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%94%9F%E6%80%81%E4%B9%8B-IDE.html</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>今天简单谈一些关于 RISC-V 开发的软件生态相关，主要是关于 RISC-V 的开发 IDE，就是集成开发环境。集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的软件开发服务套（组）。</p>
<p>目前来看，RISC-V 的硬件生态已经在蓬勃发展，而 RISC-V 相关的软件生态还在日趋完善的过程中，这里就来浅谈一点我的个人认识，如有不对，请批评指正。</p>
<p>目前，RISC-V 的软件开发 IDE ，主要是有以下几种解决方案。</p>
<a id="more"></a>

<h2 id="0x01-eclipse-——-著名开源-IDE"><a href="#0x01-eclipse-——-著名开源-IDE" class="headerlink" title="0x01 eclipse —— 著名开源 IDE"></a>0x01 eclipse —— 著名开源 IDE</h2><p>全开源，需要自行集成 RISC-V Toolchains + eclipse + OpenOCD 来搭建开发环境。</p>
<p>优点：</p>
<blockquote>
<ol>
<li>全开源，自由，免费 的 IDE</li>
<li>有众多公司厂商，组织，支持维护</li>
<li>可扩展的插件功能</li>
</ol>
</blockquote>
<p>缺点：</p>
<blockquote>
<ol>
<li>庞大臃肿，而且需要 java 运行环境。现在的版本在安装过程中会自动安装一个 jre 的运行环境。但是目前国内用户如果自行安装会下载很慢，使用代理相对快很多。如果不使用安装版本，也可以使用 zip 包解压的版本</li>
<li>集成众多插件，插件数量多了之后会拖慢系统</li>
<li>需要自行集成编译器及仿真器，打包发布给用户使用</li>
</ol>
</blockquote>
<h2 id="0x02-IAR-for-RISC-V——-老牌商业-IDE"><a href="#0x02-IAR-for-RISC-V——-老牌商业-IDE" class="headerlink" title="0x02 IAR for RISC-V—— 老牌商业 IDE"></a>0x02 IAR for RISC-V—— 老牌商业 IDE</h2><p>IAR for RISC-V 版本目前已经正在和部分芯片厂商进行合作适配、授权支持。主要包括：SiFive、Andes Technology、Nuclei（芯来科技）、CloudBEAR、Syntacore、C-SKY（平头哥）、GigaDevice（兆易创新）、MicroChip。</p>
<p>优点：</p>
<blockquote>
<ol>
<li>IAR 有非常优秀的编译器，针对代码的大小和速度有很好的优化；从 coremark 跑分排行榜上的 ARM 芯片来看，相对来说 IAR 的代码性能更高一些，当然各版本之间也会存在差异。但目前 IAR for RISC-V 的版本还未开放下载，暂时还没有相关测评。</li>
<li>有很优秀的 Trace 工具进行调试</li>
</ol>
</blockquote>
<p><a href="https://imgchr.com/i/yNVlh6" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/02/07/yNVlh6.png" alt="coremark"></a></p>
<p><a href="https://imgchr.com/i/yNEwSU" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/02/07/yNEwSU.png" alt="IAR for RISC-V"></a></p>
<p>缺点：</p>
<blockquote>
<ol>
<li>纯商业 IDE，使用需要授权，相对来说用户不易获得授权使用，尤其是新版本更新了 License 授权方案</li>
<li>RISC-V 芯片需要通过其 i-jet 来调试</li>
</ol>
</blockquote>
<h2 id="0x03-Embedded-Studio-for-RISC-V-——-SEGGER-老牌嵌入式开发工具供应商"><a href="#0x03-Embedded-Studio-for-RISC-V-——-SEGGER-老牌嵌入式开发工具供应商" class="headerlink" title="0x03 Embedded Studio for RISC-V —— SEGGER 老牌嵌入式开发工具供应商"></a>0x03 Embedded Studio for RISC-V —— SEGGER 老牌嵌入式开发工具供应商</h2><p>Embedded Studio 目前正在适配支持 Andes Technology、Nuclei（芯来科技）、GigaDevice（兆易创新） 、SiFive、Syntacore、Western Digital 的 RISC-V 芯片开发。</p>
<p>优点：</p>
<blockquote>
<ol>
<li>个人用户免费，支持全功能， 跨平台支持含 Windows, macOS 和 Linux 版本。</li>
<li>优于 IAR 的编辑器</li>
<li>启动速度快，大工程启动速度相对较快</li>
<li>调试工具丰富，因为是传统嵌入式工具链厂商，有 J-link 系列工具支持</li>
<li>支持 RISC-V 内核</li>
</ol>
</blockquote>
<p>缺点：</p>
<blockquote>
<ol>
<li>目前只支持 J-link 进行 debug</li>
<li>设置选项较为烦锁</li>
</ol>
</blockquote>
<h2 id="0x04-VS-code-——-开发新秀"><a href="#0x04-VS-code-——-开发新秀" class="headerlink" title="0x04 VS code —— 开发新秀"></a>0x04 VS code —— 开发新秀</h2><p>VS code 在我看来就是一款优秀的开源跨平台代码编辑器，但由于其内置了标准 Debugger Adaptor Protocol，经过各路大神，一些组织，部分企业公司结合各自的需求，开发了各具特色的 Debug 插件。于是乎 VS Code 俨然变成了一款极具竞争力的 IDE，成功跨界抢各类 IDE 的市场，因为其灵活小巧，迅速成为了各路开发者的新宠。但也由于其开发调试功能不是本身内置，也给不同的开发需求带来了一定的门槛，需要开发者自行进行一些开发环境配置，对于新手小白不是特别友好。但还是有很多愿意折腾的大佬。</p>
<p>优点：</p>
<blockquote>
<ol>
<li>软件全开源免费，体积小，启动快，界面新颖，更新快，新兴的优秀编辑器代表</li>
<li>开源众多的插件</li>
<li>可跨平台使用</li>
</ol>
</blockquote>
<p>缺点：</p>
<blockquote>
<ol>
<li>其本身就是一个，优秀的开源编辑器，如果要进行 MCU 开发，需要开发插件，或者使用相应的工具链来自行配置，对用户不是很友好</li>
<li>目前没有支持 RISC-V 的通用插件</li>
<li>通过体验 cortex debug 、esp-idf、platformIO 等开发插件，体验也并不是很友好；但也是跟插件开发者的能力、需求和习惯相关</li>
<li>Cortex Debug 插件，代码在 bootrom 里运行时，反汇编窗口无法显示当前的 bootrom 代码，除非手动反汇编。它执行显示当前 elf 范围内的文件，regs 窗口没法设置显示格式；这些可能是 Cortex Debug 插件的局限。</li>
</ol>
</blockquote>
<h2 id="0x05-KendryteIDE-——-基于-VS-code-包装的-IDE-方案"><a href="#0x05-KendryteIDE-——-基于-VS-code-包装的-IDE-方案" class="headerlink" title="0x05 KendryteIDE —— 基于 VS code 包装的 IDE 方案"></a>0x05 KendryteIDE —— 基于 VS code 包装的 IDE 方案</h2><p>KendryteIDE 是嘉楠勘智，基于开源的 VS code 编辑器，自己定制的 RISC-V 芯片 IDE 解决方案，整体风格继承 VS code。</p>
<p>优点：</p>
<blockquote>
<ol>
<li>基于开源 VS code，二次开发，完全自主可控，轻量级</li>
<li>继承了 VS code 的优秀编辑器，及其优点</li>
</ol>
</blockquote>
<p>缺点：</p>
<blockquote>
<ol>
<li>目前不可以直接使用其 IDE，来进行其他的 RISC-V 芯片调试</li>
<li>需要重新适配自己的 MCU 来做开发，开发工作量和时间周期是不确定的</li>
<li>定制程度取决于开发人员的能力</li>
</ol>
</blockquote>
<h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h1><p>可能正是由于 RISC-V  硬件的自由更改的属性，各家厂商都可以有自己独特的 RISC-V 架构，所以这也导致了 RISC-V 的编译工具链会有各厂商自己定制，不能像 ARM 那样各个厂商都使用 MDK，只需要做一个 SDK or Pack 包集成到 MDK 中即可。于是乎，我们就看到了市面上的各大 RISC-V 芯片或 IP 公司，都在做自己的 IDE 用自己的工具链。<br>那么为什么各家都在做各自的工具链呢，<strong>我认为还是没有形成类似于 ARM 的 CMSIS 这样的嵌入式软件接口标准，来统一管理底层软件接口，于是乎就变成了各自玩各自的，没有统一</strong>。这也是导致 RISC-V 软件生态薄弱，碎片化的一个重要因素。</p>
<p>但我相信，<strong>未来应该也会出现类似于 CMSIS 的标准，来完成一统大业的工作</strong>。</p>
<p>于是乎现在就是八仙过海，各显神通的局面。但大部分的 RISC-V 厂商的开发 IDE，还是基于开源的 <strong>eclipse + gcc toolchains + openocd</strong> 的方案来开发和调试芯片产品，相对来说这可能是比较快和相对成熟的方案。</p>
<p>当然，我个人猜测，像 IAR、SEGGER 这种纯商业的第三方 IDE 、嵌入式工具供应商，也希望能够适配市面上的各型号 MCU 开发，稳固自己的工具链生态，所以 SEGGER 率先推出了支持 RISC-V 开发的 IDE，但可能也正是由于 RISC-V 的灵活性，致使全面支持 RISC-V 架构的 IAR 版本还迟迟没有正式推出。</p>
<p>个人认为，如果一个 RISC-V 芯片厂商需要尽快推出自己的 IDE ，那么可能使用 eclipse + gcc toolchains + openocd 的方案会比较快；如果时间不急的话，在目前商业 IDE 还不成熟的情况下，可能自行研发是比较好的选择，对其自己的芯片开发的适配程度也会更高；那么自行研发也有两个方向，一个就是基于 VS code 编辑器做二次开发，参考嘉楠勘智方案；另一个就是从头开发一款自己的 IDE，但由于自己定制调试器也是一个时间周期比较长的过程，所以大概率底层还是 gcc + openocd。当然了，这里也还有未列出的阿里平头哥发布的 <code>剑池 CDK</code> 开发环境，他们有中天微时期的基础，所以他们就是自己完全定制的 IDE，并且有自己的调试器 ck-link，是解决方案比较成熟的厂商了。</p>
<table>
<thead>
<tr>
<th></th>
<th>eclipse</th>
<th>VS code</th>
<th>IAR</th>
<th>Embedded Studio</th>
</tr>
</thead>
<tbody><tr>
<td>版权</td>
<td>开源，免费</td>
<td>开源，免费</td>
<td>商业授权</td>
<td>个人用户免费，合作厂商用户免费</td>
</tr>
<tr>
<td>是否支持 RISC-V</td>
<td>编辑器本身不支持，可定制</td>
<td>编辑器本身不支持，可定制</td>
<td>支持，但需要厂商和 IAR 合作开发</td>
<td>支持，需要厂商合作开发</td>
</tr>
<tr>
<td>是否插件拓展</td>
<td>有插件</td>
<td>有插件，没有 RISC-V 通用插件，需要厂商 or 第三方 or 开源社区自定义</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>是否可调试</td>
<td>使用开源 openocd 调试</td>
<td>使用开源 openocd 调试</td>
<td>支持 RISC-V 的版本需要使用 IAR 官方 I-jet 仿真器</td>
<td>支持 RISC-V，但仅支持 SEGGER 的 J-link 仿真器</td>
</tr>
<tr>
<td>快捷键调试</td>
<td>支持</td>
<td>各种调试插件使用方式不一致</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>汇编 Debug</td>
<td>支持</td>
<td>需要自定义插件支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Mem 访问、读写</td>
<td>支持</td>
<td>需要自定义插件支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>寄存器访问、读写</td>
<td>支持</td>
<td>需要自定义插件支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>窗口中变量、数据的格式是否可更改</td>
<td>支持</td>
<td>不确定，可能需要自定义插件支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>用户界面</td>
<td>新版本有所改进，有颜色主题更改</td>
<td>新潮，有较多颜色主题，代码配色友好</td>
<td>新版本有有限主题更改</td>
<td>有限更改</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>RISC-V</category>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>RISC-V</tag>
        <tag>IDE</tag>
        <tag>软件生态</tag>
      </tags>
  </entry>
</search>
