<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SDRAM 两次踏进同一条河]]></title>
    <url>%2F%2Fposts%2FSDRAM-%E4%B8%A4%E6%AC%A1%E8%B8%8F%E8%BF%9B%E5%90%8C%E4%B8%80%E6%9D%A1%E6%B2%B3.html</url>
    <content type="text"><![CDATA[人不能两次踏进同一条河，但 SDRAM 可以——SDRAM的刷新 前言上周去了趟深圳，所以摸鱼拖更了，在那边发现真的是机遇越大的地方努力的脚步就越匆忙，某企业的 boss 是位国家科学技术奖的获得者，公司已经上市了，却依然吃 13 元的小店套餐，而且饭几乎是倒进嘴里的，5 分钟左右吃完马上就又去和合作对象谈判去了！……所以我们更要加油了，不然只会被大佬们越拉越远 …… 加油吧！ 在初窥 sdram 中我们留了一个坑——首先我们在第一页就可以看到它的刷新周期是 64ms（这个重要参数将在后面进行具体介绍） 今天我们就来填这个坑…… 「人不能两次踏进同一条河流」是古希腊哲学家赫拉克利特说的。阐述「变」的哲学在米利都学派和毕达戈拉斯学派之后，爱菲斯的赫拉克利特创立了一种变的哲学。他的哲学充满了辩证法思想，对后来辩证法的发展产生过重大影响。 他形象地表达了他关于变的思想，说：「太阳每天都是新的。」他把存在的东西比作一条河，声称人不能两次踏进同一条河。因为当人第二次进入这条河时，是新的水流而不是原来的水流在流淌。SDRAM 不断地刷新，但却能保证刷新后的数据与刷新前一致，人踏进河是为什么我不知道，但是 SDRAM 正是为了保证内部电容的电量最终实现数据的不丢失才会不断地刷新。我们人做不到的事，就用 RTL 让 SDRAM 帮我们做了吧。 参数分析首先我们来看 SDRAM 参数：8K Refresh Cycles/64 ms，意味着： 刷新速率 = 64ms / 8192 行 =&gt; 7us； 刷新时钟周期 = 7us * CPU 运行频率； 例：CPU 运行频率 50MHz 时钟周期 = 7.81us * 50MHz = 390.5；64ms 为刷新周期最大值，为保证可靠运行，实际刷新实间要稍小于 64ms；例：时钟周期 = 390.5 ≈ 380 这就意味着每 380 个时钟周期，我们便需要对我们的 SDRAM 进行一次刷新，那么进行刷新的时候需要进行哪些操作呢？我们还是回到我们的数据手册中。 如图示，我们可以看到首先是要进行一次预充电操作(precharge)（同时选中所有的 bank），在经过 tRP 延时后进行一次自刷新操作(auto refresh)，再经过一次 tRC 后又进行一次自刷新操作(auto refresh)【注：实际使用中可以只进行一次自刷新操作】，最后进入到我们下一步 …… 那么根据第一篇《初窥 SDRAM》后我们知道以上的几个操作对应的指令码分别为： CMD CS RAS CAS WE Precharge 0 0 1 0 Auto-Refresh 0 0 0 1 Nop 0 1 1 1 延时 tRP，tRC 则分别对应 15ns（至少 1 个周期，实际操作中取 1 个周期），60ns （至少 3 个周期，实际操作中取 4 个周期）。 那么我们的设计即可为：一个 8us 的定时器，控制刷新的周期，作为刷新的开始信号；一个命令计数器，用于记录对应的延时节点（tRP，tRC）；最后即为达到对应节点输出对应指令即可。 由此踏进的河流变和 8us 前的河流是同一条河流的 …… 实现代码具体实现代码如下:上代码！ sdram_autoref.v 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/*File name: sdram_autorefFunction: Auto refresh for IS42S16320D-7TL SDRAMModule name: sdram_autorefAuthor: RickyTime: 20181130*/module sdram_autoref( //system signals input sys_clk , input sys_rst_n , //others input init_flag , input ref_en , output reg ref_req , output wire ref_flag , output reg [3:0] cmd_reg , output wire [12:0] sdram_addr );/*============================================================================== **********************Define Parameter and inside Signals***********************Note: sys_clk=50MHz tRP|min=15ns &gt;&gt;&gt; 20ns &gt;&gt;&gt; 1sys_clk &gt;&gt;&gt; [4:0] cnt_cmd tRC|min=60ns &gt;&gt;&gt; 80ns &gt;&gt;&gt; 4sys_clk &gt;&gt;&gt; [4:0] cnt_cmd 8K refresh cycles every 64ms &gt;&gt;&gt; 8us &gt;&gt;&gt; 380sys_clk===============================================================================*/reg [4:0] cnt_cmd ;reg [8:0] cnt_ref ;reg flag_ref ;localparam delay_8us = 380 ;//define sdram autorefresh cmdlocalparam precharge = 4'b0010;localparam auto_refresh = 4'b0001;localparam nop = 4'b0111;/*============================================================================== **********************************Main Logic************************************==============================================================================*///auto_refresh counteralways @(posedge sys_clk or negedge sys_rst_n) begin if(~sys_rst_n) cnt_ref &lt;= 9'b0; else if(cnt_ref &gt;= delay_8us) cnt_ref &lt;= 9'b0; else if(init_flag == 1'b1) cnt_ref &lt;= cnt_ref + 1'b1;end//ref flag signalalways @(posedge sys_clk or negedge sys_rst_n) begin if(sys_rst_n == 1'b0) flag_ref &lt;= 1'b0; else if(ref_flag == 1'b1) flag_ref &lt;= 1'b0; else if(ref_en == 1'b1) flag_ref &lt;= 1'b1;end//cmd counteralways @(posedge sys_clk or negedge sys_rst_n) begin if(~sys_rst_n) cnt_cmd &lt;= 4'd0; else if (flag_ref == 1'b1) cnt_cmd &lt;= cnt_cmd + 1'b1; else cnt_cmd &lt;= 4'b0;end//cmdalways @(posedge sys_clk or negedge sys_rst_n) begin if(~sys_rst_n) cmd_reg &lt;= nop; else case(cnt_cmd) 1: cmd_reg &lt;= precharge; 2: cmd_reg &lt;= auto_refresh; 6: cmd_reg &lt;= auto_refresh; default cmd_reg &lt;= nop; endcaseend//request signal(8K refresh cycles every 64ms &gt;&gt;&gt; 8us &gt;&gt;&gt; 380sys_clk)always @(posedge sys_clk or negedge sys_rst_n)begin if(~sys_rst_n) ref_req &lt;= 1'b0; else if(ref_en) ref_req &lt;= 1'b0; else if(cnt_ref &gt;= delay_8us) ref_req &lt;= 1'b1;endassign sdram_addr = 13'b0010000000000;assign ref_flag = (cnt_cmd &gt;= 9)? 1'b1 : 1'b0;endmodule 实现后我们可以看到毎 8us 完成一次所有 bank 的刷新 仿真波形 By Ricky]]></content>
      <categories>
        <category>IC Design</category>
        <category>SDRAM</category>
      </categories>
      <tags>
        <tag>SDRAM</tag>
        <tag>IC Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初窥 SDRAM]]></title>
    <url>%2F%2Fposts%2F%E5%88%9D%E7%AA%A5-SDRAM.html</url>
    <content type="text"><![CDATA[前言上次挖的坑现在来填，在我们把 SDRAM 控制器接进 AHB 总线之前，我们先来设计一个 SDRAM 控制器。 引用知乎上看见的一段话： 在做这个 SDRAM 控制器之前，博主有一个疑问，对于学生来说，是否有必要学习用纯 Verilog 写一个 SDRAM 控制器？因为目前广告厂（X）和牙膏厂（A）都有了 DDR IP Core，而 SDRAM 的控制 IP 更是漫天飞舞，对于要实现一个应用可以直接调用 IP Core，只需要对其接口操作即可。对于开发者来说，与其费时费力用 Verilog 去写一个性能差而且老的 SDRAM 控制器，还不如直接调用官方经过打磨的更为先进 IP Core。所以博主特地来号称平均学历 211，平均月薪 7、8 万的知（bi）乎提出了这个问题，得到的解答博主总结大致如下。 对于学生这个身份来说，应该是要以学习为主要目的，虽然说目前企业为了加快项目进度会直接使用 IP Core，但是我们以学为本的初衷不应该为了避过难点而直接不去尝试，就比如我们刚开始学 Verilog 的时候肯定都会写过分频器，那么为什么不直接去学更简单精度更高 PLL IP Core 呢？从一个新手逐渐成长成一个老手都是由简单到复杂，由基础到提升，这是一个必经的过程。这也就是很多高校还是会开设汇编语言编写单片机的课程，学 FPGA 全用 IP Core 和学单片机全用库函数是一个道理。这是其一。 第二，写一个 SDRAM 控制器还是可以锻炼一些典型的技能。 看官方文档 根据时序图设计 SDRAM 逻辑，使用状态机 配合仿真模型写测试仿真 调试，提高频率，让你的 SDRAM 跑的更快 研究时序约束 这一套做下来，你就可以提高一个层次了，经历过和没经历过是有质的区别。其实博主在提问的时候心中早已有了答案，只是还没有足够的信念去完成这个事情，当时看到很多业界前辈都支持去写的时候，博主心里也是比较开心的。之前博主已经学一些 SDRAM 的基础知识，只是当时水平还不够，没有坚持下去，心里一直不甘。趁着最近两个月之内没有什么事情要忙，所以决定要再次死磕 SDRAM。 正文SDRAM 基本介绍关于 SDRAM 的基本概念，在这再引用《终极内存指南》这篇文章中的一段话: SDRAM（Synchronous Dynamic Random Access Memory），同步动态随机存储器。同步是指 Memory 工作需要同步时钟，内部的命令的发送与数据的传输都以它为基准；动态是指存储阵列需要不断刷新来保证存储的数据不丢失，因为 SDRAM 中存储数据是通过电容来工作的，大家知道电容在自然放置状态是会有放电的，如果电放完了，也就意味着 SDRAM 中的数据丢失了，所以 SDRAM 需要在电容的电量放完之前进行刷新；随机是指数据不是线性依次存储，而是自由指定地址进行数据的读写。 下面再简单看一下 SDRAM 的内部结构。对于 SDRAM 的内容结构，就如同 Excel 的表格（如下图所示），即一个单元格就是一个存储地址。要确定具体的存储位置，只需要知道行地址（row-address ）和列地址（column address ）即可。 一个常见的 SDRAM 中的一个 BANK 就有如上图所示的 13 行 9 列，通常一个 SDRAM 中有 4 个 BANK，那么 SDRAM（DDR 类似）的计算公式就是： SDRAM(DDR容量) = 2^(row-address) × 2^(column-address) × 2^(bank-address) × datawidth= 2^(row-address) × 2^(column-address) × bank数 × datawidth 以 DE10-LITE 开发板板载的 SDRAM-IS42S16320D-7TL 为例，标称为 64MB。根据芯片手册（如下图所示）我们可以看见其行地址宽度为 13，列地址宽度为 9（此时数据位宽为 32），则根据公式我们可以算出其容量确实为 64MB 2^13 × 2^9 × 4 × 32 = 536870912 b⇒ 536870912 b ÷ 1024 = 524288 kb⇒ 524288 kb ÷ 1024 = 512 Mb⇒ 512 Mb ÷ 8 = 64 MB SDRAM 芯片介绍既然都打开了芯片手册（IS42S16320D-7TL），那就不要关上了，那我们再来看看芯片手册中的那些重要参数。首先我们在第一页就可以看到它的刷新周期是 64ms（这个重要参数将在后面进行具体介绍） 在上文中我们已经提到了该芯片的行地址和列地址，我们需要注意的是其行列地址是复用的，其他相关引脚的功能描述都有介绍。 SDRAM 的初始化及寄存器的配置SDRAM 初始化时序图如图所示，首先上电后，电源 Vcc 及 CLK 稳定时间至少 100us，然后对所有 BANK 进行预充电（precharge），经过 tRP 后给 auto refresh 命令，再经过 tRC 后再次 auto refresh 命令，再进过 tRC 后进行模式寄存器的配置。 那么以上命令是如何实现的呢，当时就是给与相应管脚的高低电平控制，由此实现，那么这就回到了我们数电的功能真值表（在之前我们就有提到过，数字 IC 终归是数字电路，不要把它搞成了编程项目），我们将下图的真值表以使用顺序总结为表格形式，方便接下来的 RTL 表述。 CMD CS RAS CAS WE Precharge 0 0 1 0 Auto-Refresh 0 0 0 1 Nop 0 1 1 1 Mode 0 0 0 0 在了解到命令描述后我们还需要注意时间的间隔，在时序图中只告知了我们 T = 100us，而其余的 tRP，tRC，tMRD 均未告诉我们，这是因为通常一个芯片手册中有多种型号的芯片，因此我们需要去查看 AC characteristic 表格，根据芯片型号去确定时间。我们的板载芯片型号为 IS42S16320D-7TL，因此我们选择 -7 对应的时间，则 tRP = 15ns，tRC = 60ns，tMRD = 14ns 接下来我们就要进入到模式配置，模式配置的配置说明如下图所示： A0-A2 为突发长度控制，即表示单次读或者写的时候的数据『长度』，本次突发长度参数我们设为 010。A3 突发模式通常设为 0。A4-A6 为潜伏期控制，专门针对读命令时，当给出读命令后，若有设置 CAS latency 则会延迟相应的周期数后给出数据，本次潜伏期参数我们设为 011，A9 突发模式通常设为 0。则最终我们初始化设置参数为 13’b0_0000_0011_0010 至此，我们便可以开始着手设计我们的初始化模块了，首先时序图上 T = 100us Min，则我们取 200us = 200,000ns 在不经过 PLL 的前提下，DE10LITE 开发板默认提供的时钟频率为 50MHz，则一个周期为 20ns，因此 T 延时可以取 10,000clk。延时后我们执行 precharge 命令。之后执行 tRP = 15ns Min，我们的 tRP 延迟就可以取 1clk（至少满足 15ns 的最低要求），然后执行 auto refresh 命令，tRC = 60ns Min 则延迟可取为 4clk，然后再次执行 auto refresh 命令，在这期间一共 9 个 clk。具体的设计可以首先设计一个 200us 的不自清零的计数器；设计一个对应的 200us 计数器标志位；针对 tRP 和 tRC 设计一个计数器，分别实现监测计数到对应的周期发出对应的命令；命令寄存器用来存放对应的命令；最后完成初始化操作后给一个初始化完成的标志位信号。 下面是具体实现的描述语言： sdram_init.v 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*File name: sdram_initFunction: Power on initialization for IS42S16320D-7TL SDRAMModule name: sdram_initAuthor: RickyTime: 20181119*/module sdram_init( //system signals input sys_clk , input sys_rst_n , //others output reg [3:0] cmd_reg , output wire [12:0] sdram_addr , output wire init_flag );/*============================================================================== **********************Define Parameter and inside Signals***********************Note: syssys_clk=50MHz T|min=100us &gt;&gt;&gt; 200us=200,000ns &gt;&gt;&gt; 10,000sys_clk &gt;&gt;&gt; [13:0] cnt_200us tRP|min=15ns &gt;&gt;&gt; 20ns &gt;&gt;&gt; 1sys_clk &gt;&gt;&gt; [4:0] cnt_cmd tRC|min=60ns &gt;&gt;&gt; 80ns &gt;&gt;&gt; 4sys_clk &gt;&gt;&gt; [4:0] cnt_cmd===============================================================================*/reg [13:0] cnt_200us ;wire cnt_200us_flag ;reg [4:0] cnt_cmd ;//define sdram initial cmdlocalparam precharge = 4'b0010;localparam auto_refresh = 4'b0001;localparam nop = 4'b0111;localparam modeset = 4'b0000;/*============================================================================== **********************************Main Logic************************************==============================================================================*///T=200us counteralways @(posedge sys_clk or negedge sys_rst_n) begin if(~sys_rst_n) cnt_200us &lt;= 13'd0; else if(cnt_200us_flag == 1'b0) cnt_200us &lt;= cnt_200us + 1'b1; else cnt_200us &lt;= cnt_200us;end//cmd counteralways @(posedge sys_clk or negedge sys_rst_n) begin if(~sys_rst_n) cnt_cmd &lt;= 4'd0; else if (cnt_200us_flag == 1'b1 &amp;&amp; init_flag == 1'b0) cnt_cmd &lt;= cnt_cmd + 1'b1;end//cmdalways @(posedge sys_clk or negedge sys_rst_n) begin if(~sys_rst_n) cmd_reg &lt;= nop; else if(cnt_200us_flag == 1'b1) case(cnt_cmd) 0: cmd_reg &lt;= precharge ; 1: cmd_reg &lt;= auto_refresh ; 5: cmd_reg &lt;= auto_refresh ; 9: cmd_reg &lt;= modeset ; default: cmd_reg &lt;= nop ; endcaseendassign cnt_200us_flag = (cnt_200us &gt;= 10000) ? 1'b1:1'b0;assign init_flag = (cnt_cmd &gt;= 9) ? 1'b1:1'b0;assign sdram_addr = (cmd_reg == modeset) ? 13'b0000000110010 : 13'b0010000000000;endmodule sdram_top.v 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 /*File name: sdram_topAuthor: RickyTime: 20181121*/module sdram( //system signals input sys_clk , input sys_rst_n , //sdram pin output wire sdram_clk , output wire [12:0] sdram_addr , output wire [1:0] sdram_bank , output wire sdram_cas_n , output wire sdram_cke , output wire sdram_cs_n , output wire [1:0] sdram_dqm , output wire sdram_ras_n , output wire sdram_we_n , inout [15:0] sdram_dq);/*============================================================================== **********************Define Parameter and inside Signals***********************===============================================================================*/wire init_flag ;wire [3:0] init_cmd_reg ;wire [12:0] init_addr ;/*============================================================================== **********************************Main Logic************************************==============================================================================*/assign sdram_addr = init_addr;assign &#123;sdram_cs_n, sdram_ras_n, sdram_cas_n, sdram_we_n&#125; = init_cmd_reg;assign sdram_clk = ~sys_clk;assign sdram_dqm = 2'b00;assign sdram_cke = 1'b1;//instantiating sdram_init modulesdram_init sdram_init( //system signals . sys_clk (sys_clk) , . sys_rst_n (sys_rst_n) , //others . cmd_reg (init_cmd_reg) , . sdram_addr (init_addr) , . init_flag (init_flag) );endmodule sdram_tb.v 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*File name: sdram_tbFunction: Testbench for power on initialization for IS42S16320D-7TL SDRAMAuthor: RickyTime: 20181123*/`timescale 1ns/1nsmodule sdram_tb;reg sys_clk;reg sys_rst_n;wire sdram_clk ;wire [12:0] sdram_addr ;wire [1:0] sdram_bank ;wire sdram_cas_n ;wire sdram_cke ;wire sdram_cs_n ; wire [1:0] sdram_dqm ;wire sdram_ras_n ;wire sdram_we_n ;wire [15:0] sdram_dq ;initial begin sys_clk = 1; sys_rst_n &lt;= 0; #100 sys_rst_n &lt;= 1;end// 20ns/clockalways #10 sys_clk = ~sys_clk;/* defparam sdram_model_plus.addr_bits = 13 ;defparam sdram_model_plus.data_bits = 16 ; defparam sdram_model_plus.col_bits = 9 ;defparam sdram_model_plus.mem_sizes = 2*1024*1024 ; *///instantiating sdram_init modulesdram sdraminit( //system signals .sys_clk (sys_clk ) , .sys_rst_n (sys_rst_n) , //sdram pin .sdram_clk (sdram_clk) , .sdram_addr (sdram_addr) , .sdram_bank (sdram_bank) , .sdram_cas_n (sdram_cas_n) , .sdram_cke (sdram_cke) , .sdram_cs_n (sdram_cs_n) , .sdram_dqm (sdram_dqm) , .sdram_ras_n (sdram_ras_n) , .sdram_we_n (sdram_we_n) , .sdram_dq (sdram_dq));//instantiating sdram_model modulesdram_model_plus sdram( .Dq (sdram_dq) , .Addr (sdram_addr) , .Ba (sdram_bank) , .Clk (sdram_clk) , .Cke (sdram_cke) , .Cs_n (sdram_cs_n) , .Ras_n (sdram_ras_n) , .Cas_n (sdram_cas_n) , .We_n (sdram_we_n) , .Dqm (sdram_dqm) , .Debug (1'b1));endmodule 仿真模型（见附件）一共有两个分别是镁光官方仿真模型以及国内大神基于镁光模型进行修改后便于调试的版本，使用任意一版均可。这里我采用的是 sdram_model.v sdram_model.v 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130/***************************************************************************************作者： 李晟2003-08-27 V0.1 李晟 添加内存模块倒空功能，在外部需要创建事件：sdram_r ,本SDRAM的内容将会按Bank 顺序damp out 至文件 sdram_data.txt 中×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××*///2004-03-04 陈乃奎 修改原程序中将BANK的数据转存入TXT文件的格式//2004-03-16 陈乃奎 修改SDRAM 的初始化数据//2004/04/06 陈乃奎 将SDRAM的操作命令以字符形式表示，以便用MODELSIM监视//2004/04/19 陈乃奎 修改参数 parameter tAC = 8;//2010/09/17 罗瑶 修改sdram的大小，数据位宽，dqm宽度;/****************************************************************************************** File Name: sdram_model.V * Version: 0.0f* Date: July 8th, 1999* Model: BUS Functional* Simulator: Model Technology (PC version 5.2e PE)** Dependencies: None** Author: Son P. Huynh* Email: sphuynh@micron.com* Phone: (208) 368-3825* Company: Micron Technology, Inc.* Model: sdram_model (1Meg x 16 x 4 Banks)** Description: 64Mb SDRAM Verilog model** Limitation: - Doesn't check for 4096 cycle refresh** Note: - Set simulator resolution to "ps" accuracy* - Set Debug = 0 to disable $display messages** Disclaimer: THESE DESIGNS ARE PROVIDED "AS IS" WITH NO WARRANTY * WHATSOEVER AND MICRON SPECIFICALLY DISCLAIMS ANY * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR* A PARTICULAR PURPOSE, OR AGAINST INFRINGEMENT.** Copyright ?1998 Micron Semiconductor Products, Inc.* All rights researved** Rev Author Phone Date Changes* ---- ---------------------------- ---------- ---------------------------------------* 0.0f Son Huynh 208-368-3825 07/08/1999 - Fix tWR = 1 Clk + 7.5 ns (Auto)* Micron Technology Inc. - Fix tWR = 15 ns (Manual)* - Fix tRP (Autoprecharge to AutoRefresh)** 0.0a Son Huynh 208-368-3825 05/13/1998 - First Release (from 64Mb rev 0.0e)* Micron Technology Inc.****************************************************************************************/`timescale 1ns / 100psmodule sdram_model_plus (Dq, Addr, Ba, Clk, Cke, Cs_n, Ras_n, Cas_n, We_n, Dqm,Debug); parameter addr_bits = 13; parameter data_bits = 16; parameter col_bits = 9; parameter mem_sizes = 4*1024*1024 -1;//1 Meg inout [data_bits - 1 : 0] Dq; input [addr_bits - 1 : 0] Addr; input [1 : 0] Ba; input Clk; input Cke; input Cs_n; input Ras_n; input Cas_n; input We_n; input [1 : 0] Dqm; //高低各8bit //added by xzli input Debug; reg [data_bits - 1 : 0] Bank0 [0 : mem_sizes];//存储器类型数据 reg [data_bits - 1 : 0] Bank1 [0 : mem_sizes]; reg [data_bits - 1 : 0] Bank2 [0 : mem_sizes]; reg [data_bits - 1 : 0] Bank3 [0 : mem_sizes]; reg [1 : 0] Bank_addr [0 : 3]; // Bank Address Pipeline reg [col_bits - 1 : 0] Col_addr [0 : 3]; // Column Address Pipeline reg [3 : 0] Command [0 : 3]; // Command Operation Pipeline reg [3 : 0] Dqm_reg0, Dqm_reg1; // DQM Operation Pipeline reg [addr_bits - 1 : 0] B0_row_addr, B1_row_addr, B2_row_addr, B3_row_addr; reg [addr_bits - 1 : 0] Mode_reg; reg [data_bits - 1 : 0] Dq_reg, Dq_dqm; reg [col_bits - 1 : 0] Col_temp, Burst_counter; reg Act_b0, Act_b1, Act_b2, Act_b3; // Bank Activate reg Pc_b0, Pc_b1, Pc_b2, Pc_b3; // Bank Precharge reg [1 : 0] Bank_precharge [0 : 3]; // Precharge Command reg A10_precharge [0 : 3]; // Addr[10] = 1 (All banks) reg Auto_precharge [0 : 3]; // RW AutoPrecharge (Bank) reg Read_precharge [0 : 3]; // R AutoPrecharge reg Write_precharge [0 : 3]; // W AutoPrecharge integer Count_precharge [0 : 3]; // RW AutoPrecharge (Counter) reg RW_interrupt_read [0 : 3]; // RW Interrupt Read with Auto Precharge reg RW_interrupt_write [0 : 3]; // RW Interrupt Write with Auto Precharge reg Data_in_enable; reg Data_out_enable; reg [1 : 0] Bank, Previous_bank; reg [addr_bits - 1 : 0] Row; reg [col_bits - 1 : 0] Col, Col_brst; // Internal system clock reg CkeZ, Sys_clk; reg [24:0] dd; // Commands Decode wire Active_enable = ~Cs_n &amp; ~Ras_n &amp; Cas_n &amp; We_n; wire Aref_enable = ~Cs_n &amp; ~Ras_n &amp; ~Cas_n &amp; We_n; wire Burst_term = ~Cs_n &amp; Ras_n &amp; Cas_n &amp; ~We_n; wire Mode_reg_enable = ~Cs_n &amp; ~Ras_n &amp; ~Cas_n &amp; ~We_n; wire Prech_enable = ~Cs_n &amp; ~Ras_n &amp; Cas_n &amp; ~We_n; wire Read_enable = ~Cs_n &amp; Ras_n &amp; ~Cas_n &amp; We_n; wire Write_enable = ~Cs_n &amp; Ras_n &amp; ~Cas_n &amp; ~We_n; // Burst Length Decode wire Burst_length_1 = ~Mode_reg[2] &amp; ~Mode_reg[1] &amp; ~Mode_reg[0]; wire Burst_length_2 = ~Mode_reg[2] &amp; ~Mode_reg[1] &amp; Mode_reg[0]; wire Burst_length_4 = ~Mode_reg[2] &amp; Mode_reg[1] &amp; ~Mode_reg[0]; wire Burst_length_8 = ~Mode_reg[2] &amp; Mode_reg[1] &amp; Mode_reg[0]; // CAS Latency Decode wire Cas_latency_2 = ~Mode_reg[6] &amp; Mode_reg[5] &amp; ~Mode_reg[4]; wire Cas_latency_3 = ~Mode_reg[6] &amp; Mode_reg[5] &amp; Mode_reg[4]; // Write Burst Mode wire Write_burst_mode = Mode_reg[9]; wire Debug; // Debug messages : 1 = On; 0 = Off wire Dq_chk = Sys_clk &amp; Data_in_enable; // Check setup/hold time for DQ reg [31:0] mem_d; event sdram_r,sdram_w,compare; assign Dq = Dq_reg; // DQ buffer // Commands Operation `define ACT 0 `define NOP 1 `define READ 2 `define READ_A 3 `define WRITE 4 `define WRITE_A 5 `define PRECH 6 `define A_REF 7 `define BST 8 `define LMR 9// // Timing Parameters for -75 (PC133) and CAS Latency = 2// parameter tAC = 8; //test 6.5// parameter tHZ = 7.0;// parameter tOH = 2.7;// parameter tMRD = 2.0; // 2 Clk Cycles// parameter tRAS = 44.0;// parameter tRC = 66.0;// parameter tRCD = 20.0;// parameter tRP = 20.0;// parameter tRRD = 15.0;// parameter tWRa = 7.5; // A2 Version - Auto precharge mode only (1 Clk + 7.5 ns)// parameter tWRp = 0.0; // A2 Version - Precharge mode only (15 ns) // Timing Parameters for -7 (PC143) and CAS Latency = 3 parameter tAC = 6.5; //test 6.5 parameter tHZ = 5.5; parameter tOH = 2; parameter tMRD = 2.0; // 2 Clk Cycles parameter tRAS = 48.0; parameter tRC = 70.0; parameter tRCD = 20.0; parameter tRP = 20.0; parameter tRRD = 14.0; parameter tWRa = 7.5; // A2 Version - Auto precharge mode only (1 Clk + 7.5 ns) parameter tWRp = 0.0; // A2 Version - Precharge mode only (15 ns) // Timing Check variable integer MRD_chk; integer WR_counter [0 : 3]; time WR_chk [0 : 3]; time RC_chk, RRD_chk; time RAS_chk0, RAS_chk1, RAS_chk2, RAS_chk3; time RCD_chk0, RCD_chk1, RCD_chk2, RCD_chk3; time RP_chk0, RP_chk1, RP_chk2, RP_chk3; integer test_file; //*****display the command of the sdram************************************** parameter Mode_Reg_Set =4'b0000; parameter Auto_Refresh =4'b0001; parameter Row_Active =4'b0011; parameter Pre_Charge =4'b0010; parameter PreCharge_All =4'b0010; parameter Write =4'b0100; parameter Write_Pre =4'b0100; parameter Read =4'b0101; parameter Read_Pre =4'b0101; parameter Burst_Stop =4'b0110; parameter Nop =4'b0111; parameter Dsel =4'b1111; wire [3:0] sdram_control; reg cke_temp; reg [8*13:1] sdram_command; always@(posedge Clk) cke_temp&lt;=Cke; assign sdram_control=&#123;Cs_n,Ras_n,Cas_n,We_n&#125;; always@(sdram_control or cke_temp) begin case(sdram_control) Mode_Reg_Set: sdram_command&lt;="Mode_Reg_Set"; Auto_Refresh: sdram_command&lt;="Auto_Refresh"; Row_Active: sdram_command&lt;="Row_Active"; Pre_Charge: sdram_command&lt;="Pre_Charge"; Burst_Stop: sdram_command&lt;="Burst_Stop"; Dsel: sdram_command&lt;="Dsel"; Write: if(cke_temp==1) sdram_command&lt;="Write"; else sdram_command&lt;="Write_suspend"; Read: if(cke_temp==1) sdram_command&lt;="Read"; else sdram_command&lt;="Read_suspend"; Nop: if(cke_temp==1) sdram_command&lt;="Nop"; else sdram_command&lt;="Self_refresh"; default: sdram_command&lt;="Power_down"; endcase end //***************************************************** initial begin //test_file=$fopen("test_file.txt"); end initial begin Dq_reg = &#123;data_bits&#123;1'bz&#125;&#125;; &#123;Data_in_enable, Data_out_enable&#125; = 0; &#123;Act_b0, Act_b1, Act_b2, Act_b3&#125; = 4'b0000; &#123;Pc_b0, Pc_b1, Pc_b2, Pc_b3&#125; = 4'b0000; &#123;WR_chk[0], WR_chk[1], WR_chk[2], WR_chk[3]&#125; = 0; &#123;WR_counter[0], WR_counter[1], WR_counter[2], WR_counter[3]&#125; = 0; &#123;RW_interrupt_read[0], RW_interrupt_read[1], RW_interrupt_read[2], RW_interrupt_read[3]&#125; = 0; &#123;RW_interrupt_write[0], RW_interrupt_write[1], RW_interrupt_write[2], RW_interrupt_write[3]&#125; = 0; &#123;MRD_chk, RC_chk, RRD_chk&#125; = 0; &#123;RAS_chk0, RAS_chk1, RAS_chk2, RAS_chk3&#125; = 0; &#123;RCD_chk0, RCD_chk1, RCD_chk2, RCD_chk3&#125; = 0; &#123;RP_chk0, RP_chk1, RP_chk2, RP_chk3&#125; = 0; $timeformat (-9, 0, " ns", 12); //$readmemh("bank0.txt", Bank0); //$readmemh("bank1.txt", Bank1); //$readmemh("bank2.txt", Bank2); //$readmemh("bank3.txt", Bank3);/* for(dd=0;dd&lt;=mem_sizes;dd=dd+1) begin Bank0[dd]=dd[data_bits - 1 : 0]; Bank1[dd]=dd[data_bits - 1 : 0]+1; Bank2[dd]=dd[data_bits - 1 : 0]+2; Bank3[dd]=dd[data_bits - 1 : 0]+3; end*/ initial_sdram(0); end task initial_sdram; input data_sign; reg [3:0] data_sign; for(dd=0;dd&lt;=mem_sizes;dd=dd+1) begin mem_d = &#123;data_sign,data_sign,data_sign,data_sign,data_sign,data_sign,data_sign,data_sign&#125;; if(data_bits==16) begin Bank0[dd]=mem_d[15:0]; Bank1[dd]=mem_d[15:0]; Bank2[dd]=mem_d[15:0]; Bank3[dd]=mem_d[15:0]; end else if(data_bits==32) begin Bank0[dd]=mem_d[31:0]; Bank1[dd]=mem_d[31:0]; Bank2[dd]=mem_d[31:0]; Bank3[dd]=mem_d[31:0]; end end endtask // System clock generator always begin @(posedge Clk) begin Sys_clk = CkeZ; CkeZ = Cke; end @(negedge Clk) begin Sys_clk = 1'b0; end end always @ (posedge Sys_clk) begin // Internal Commamd Pipelined Command[0] = Command[1]; Command[1] = Command[2]; Command[2] = Command[3]; Command[3] = `NOP; Col_addr[0] = Col_addr[1]; Col_addr[1] = Col_addr[2]; Col_addr[2] = Col_addr[3]; Col_addr[3] = &#123;col_bits&#123;1'b0&#125;&#125;; Bank_addr[0] = Bank_addr[1]; Bank_addr[1] = Bank_addr[2]; Bank_addr[2] = Bank_addr[3]; Bank_addr[3] = 2'b0; Bank_precharge[0] = Bank_precharge[1]; Bank_precharge[1] = Bank_precharge[2]; Bank_precharge[2] = Bank_precharge[3]; Bank_precharge[3] = 2'b0; A10_precharge[0] = A10_precharge[1]; A10_precharge[1] = A10_precharge[2]; A10_precharge[2] = A10_precharge[3]; A10_precharge[3] = 1'b0; // Dqm pipeline for Read Dqm_reg0 = Dqm_reg1; Dqm_reg1 = Dqm; // Read or Write with Auto Precharge Counter if (Auto_precharge[0] == 1'b1) begin Count_precharge[0] = Count_precharge[0] + 1; end if (Auto_precharge[1] == 1'b1) begin Count_precharge[1] = Count_precharge[1] + 1; end if (Auto_precharge[2] == 1'b1) begin Count_precharge[2] = Count_precharge[2] + 1; end if (Auto_precharge[3] == 1'b1) begin Count_precharge[3] = Count_precharge[3] + 1; end // tMRD Counter MRD_chk = MRD_chk + 1; // tWR Counter for Write WR_counter[0] = WR_counter[0] + 1; WR_counter[1] = WR_counter[1] + 1; WR_counter[2] = WR_counter[2] + 1; WR_counter[3] = WR_counter[3] + 1; // Auto Refresh if (Aref_enable == 1'b1) begin if (Debug) $display ("at time %t AREF : Auto Refresh", $time); // Auto Refresh to Auto Refresh if (($time - RC_chk &lt; tRC)&amp;&amp;Debug) begin $display ("at time %t ERROR: tRC violation during Auto Refresh", $time); end // Precharge to Auto Refresh if (($time - RP_chk0 &lt; tRP || $time - RP_chk1 &lt; tRP || $time - RP_chk2 &lt; tRP || $time - RP_chk3 &lt; tRP)&amp;&amp;Debug) begin $display ("at time %t ERROR: tRP violation during Auto Refresh", $time); end // Precharge to Refresh if (Pc_b0 == 1'b0 || Pc_b1 == 1'b0 || Pc_b2 == 1'b0 || Pc_b3 == 1'b0) begin $display ("at time %t ERROR: All banks must be Precharge before Auto Refresh", $time); end // Record Current tRC time RC_chk = $time; end // Load Mode Register if (Mode_reg_enable == 1'b1) begin // Decode CAS Latency, Burst Length, Burst Type, and Write Burst Mode if (Pc_b0 == 1'b1 &amp;&amp; Pc_b1 == 1'b1 &amp;&amp; Pc_b2 == 1'b1 &amp;&amp; Pc_b3 == 1'b1) begin Mode_reg = Addr; if (Debug) begin $display ("at time %t LMR : Load Mode Register", $time); // CAS Latency if (Addr[6 : 4] == 3'b010) $display (" CAS Latency = 2"); else if (Addr[6 : 4] == 3'b011) $display (" CAS Latency = 3"); else $display (" CAS Latency = Reserved"); // Burst Length if (Addr[2 : 0] == 3'b000) $display (" Burst Length = 1"); else if (Addr[2 : 0] == 3'b001) $display (" Burst Length = 2"); else if (Addr[2 : 0] == 3'b010) $display (" Burst Length = 4"); else if (Addr[2 : 0] == 3'b011) $display (" Burst Length = 8"); else if (Addr[3 : 0] == 4'b0111) $display (" Burst Length = Full"); else $display (" Burst Length = Reserved"); // Burst Type if (Addr[3] == 1'b0) $display (" Burst Type = Sequential"); else if (Addr[3] == 1'b1) $display (" Burst Type = Interleaved"); else $display (" Burst Type = Reserved"); // Write Burst Mode if (Addr[9] == 1'b0) $display (" Write Burst Mode = Programmed Burst Length"); else if (Addr[9] == 1'b1) $display (" Write Burst Mode = Single Location Access"); else $display (" Write Burst Mode = Reserved"); end end else begin $display ("at time %t ERROR: all banks must be Precharge before Load Mode Register", $time); end // REF to LMR if ($time - RC_chk &lt; tRC) begin $display ("at time %t ERROR: tRC violation during Load Mode Register", $time); end // LMR to LMR if (MRD_chk &lt; tMRD) begin $display ("at time %t ERROR: tMRD violation during Load Mode Register", $time); end MRD_chk = 0; end // Active Block (Latch Bank Address and Row Address) if (Active_enable == 1'b1) begin if (Ba == 2'b00 &amp;&amp; Pc_b0 == 1'b1) begin &#123;Act_b0, Pc_b0&#125; = 2'b10; B0_row_addr = Addr [addr_bits - 1 : 0]; RCD_chk0 = $time; RAS_chk0 = $time; if (Debug) $display ("at time %t ACT : Bank = 0 Row = %d", $time, Addr); // Precharge to Activate Bank 0 if ($time - RP_chk0 &lt; tRP) begin $display ("at time %t ERROR: tRP violation during Activate bank 0", $time); end end else if (Ba == 2'b01 &amp;&amp; Pc_b1 == 1'b1) begin &#123;Act_b1, Pc_b1&#125; = 2'b10; B1_row_addr = Addr [addr_bits - 1 : 0]; RCD_chk1 = $time; RAS_chk1 = $time; if (Debug) $display ("at time %t ACT : Bank = 1 Row = %d", $time, Addr); // Precharge to Activate Bank 1 if ($time - RP_chk1 &lt; tRP) begin $display ("at time %t ERROR: tRP violation during Activate bank 1", $time); end end else if (Ba == 2'b10 &amp;&amp; Pc_b2 == 1'b1) begin &#123;Act_b2, Pc_b2&#125; = 2'b10; B2_row_addr = Addr [addr_bits - 1 : 0]; RCD_chk2 = $time; RAS_chk2 = $time; if (Debug) $display ("at time %t ACT : Bank = 2 Row = %d", $time, Addr); // Precharge to Activate Bank 2 if ($time - RP_chk2 &lt; tRP) begin $display ("at time %t ERROR: tRP violation during Activate bank 2", $time); end end else if (Ba == 2'b11 &amp;&amp; Pc_b3 == 1'b1) begin &#123;Act_b3, Pc_b3&#125; = 2'b10; B3_row_addr = Addr [addr_bits - 1 : 0]; RCD_chk3 = $time; RAS_chk3 = $time; if (Debug) $display ("at time %t ACT : Bank = 3 Row = %d", $time, Addr); // Precharge to Activate Bank 3 if ($time - RP_chk3 &lt; tRP) begin $display ("at time %t ERROR: tRP violation during Activate bank 3", $time); end end else if (Ba == 2'b00 &amp;&amp; Pc_b0 == 1'b0) begin $display ("at time %t ERROR: Bank 0 is not Precharged.", $time); end else if (Ba == 2'b01 &amp;&amp; Pc_b1 == 1'b0) begin $display ("at time %t ERROR: Bank 1 is not Precharged.", $time); end else if (Ba == 2'b10 &amp;&amp; Pc_b2 == 1'b0) begin $display ("at time %t ERROR: Bank 2 is not Precharged.", $time); end else if (Ba == 2'b11 &amp;&amp; Pc_b3 == 1'b0) begin $display ("at time %t ERROR: Bank 3 is not Precharged.", $time); end // Active Bank A to Active Bank B if ((Previous_bank != Ba) &amp;&amp; ($time - RRD_chk &lt; tRRD)) begin $display ("at time %t ERROR: tRRD violation during Activate bank = %d", $time, Ba); end // Load Mode Register to Active if (MRD_chk &lt; tMRD ) begin $display ("at time %t ERROR: tMRD violation during Activate bank = %d", $time, Ba); end // Auto Refresh to Activate if (($time - RC_chk &lt; tRC)&amp;&amp;Debug) begin $display ("at time %t ERROR: tRC violation during Activate bank = %d", $time, Ba); end // Record variables for checking violation RRD_chk = $time; Previous_bank = Ba; end // Precharge Block if (Prech_enable == 1'b1) begin if (Addr[10] == 1'b1) begin &#123;Pc_b0, Pc_b1, Pc_b2, Pc_b3&#125; = 4'b1111; &#123;Act_b0, Act_b1, Act_b2, Act_b3&#125; = 4'b0000; RP_chk0 = $time; RP_chk1 = $time; RP_chk2 = $time; RP_chk3 = $time; if (Debug) $display ("at time %t PRE : Bank = ALL",$time); // Activate to Precharge all banks if (($time - RAS_chk0 &lt; tRAS) || ($time - RAS_chk1 &lt; tRAS) || ($time - RAS_chk2 &lt; tRAS) || ($time - RAS_chk3 &lt; tRAS)) begin $display ("at time %t ERROR: tRAS violation during Precharge all bank", $time); end // tWR violation check for write if (($time - WR_chk[0] &lt; tWRp) || ($time - WR_chk[1] &lt; tWRp) || ($time - WR_chk[2] &lt; tWRp) || ($time - WR_chk[3] &lt; tWRp)) begin $display ("at time %t ERROR: tWR violation during Precharge all bank", $time); end end else if (Addr[10] == 1'b0) begin if (Ba == 2'b00) begin &#123;Pc_b0, Act_b0&#125; = 2'b10; RP_chk0 = $time; if (Debug) $display ("at time %t PRE : Bank = 0",$time); // Activate to Precharge Bank 0 if ($time - RAS_chk0 &lt; tRAS) begin $display ("at time %t ERROR: tRAS violation during Precharge bank 0", $time); end end else if (Ba == 2'b01) begin &#123;Pc_b1, Act_b1&#125; = 2'b10; RP_chk1 = $time; if (Debug) $display ("at time %t PRE : Bank = 1",$time); // Activate to Precharge Bank 1 if ($time - RAS_chk1 &lt; tRAS) begin $display ("at time %t ERROR: tRAS violation during Precharge bank 1", $time); end end else if (Ba == 2'b10) begin &#123;Pc_b2, Act_b2&#125; = 2'b10; RP_chk2 = $time; if (Debug) $display ("at time %t PRE : Bank = 2",$time); // Activate to Precharge Bank 2 if ($time - RAS_chk2 &lt; tRAS) begin $display ("at time %t ERROR: tRAS violation during Precharge bank 2", $time); end end else if (Ba == 2'b11) begin &#123;Pc_b3, Act_b3&#125; = 2'b10; RP_chk3 = $time; if (Debug) $display ("at time %t PRE : Bank = 3",$time); // Activate to Precharge Bank 3 if ($time - RAS_chk3 &lt; tRAS) begin $display ("at time %t ERROR: tRAS violation during Precharge bank 3", $time); end end // tWR violation check for write if ($time - WR_chk[Ba] &lt; tWRp) begin $display ("at time %t ERROR: tWR violation during Precharge bank %d", $time, Ba); end end // Terminate a Write Immediately (if same bank or all banks) if (Data_in_enable == 1'b1 &amp;&amp; (Bank == Ba || Addr[10] == 1'b1)) begin Data_in_enable = 1'b0; end // Precharge Command Pipeline for Read if (Cas_latency_3 == 1'b1) begin Command[2] = `PRECH; Bank_precharge[2] = Ba; A10_precharge[2] = Addr[10]; end else if (Cas_latency_2 == 1'b1) begin Command[1] = `PRECH; Bank_precharge[1] = Ba; A10_precharge[1] = Addr[10]; end end // Burst terminate if (Burst_term == 1'b1) begin // Terminate a Write Immediately if (Data_in_enable == 1'b1) begin Data_in_enable = 1'b0; end // Terminate a Read Depend on CAS Latency if (Cas_latency_3 == 1'b1) begin Command[2] = `BST; end else if (Cas_latency_2 == 1'b1) begin Command[1] = `BST; end if (Debug) $display ("at time %t BST : Burst Terminate",$time); end // Read, Write, Column Latch if (Read_enable == 1'b1 || Write_enable == 1'b1) begin // Check to see if bank is open (ACT) if ((Ba == 2'b00 &amp;&amp; Pc_b0 == 1'b1) || (Ba == 2'b01 &amp;&amp; Pc_b1 == 1'b1) || (Ba == 2'b10 &amp;&amp; Pc_b2 == 1'b1) || (Ba == 2'b11 &amp;&amp; Pc_b3 == 1'b1)) begin $display("at time %t ERROR: Cannot Read or Write - Bank %d is not Activated", $time, Ba); end // Activate to Read or Write if ((Ba == 2'b00) &amp;&amp; ($time - RCD_chk0 &lt; tRCD)) $display("at time %t ERROR: tRCD violation during Read or Write to Bank 0", $time); if ((Ba == 2'b01) &amp;&amp; ($time - RCD_chk1 &lt; tRCD)) $display("at time %t ERROR: tRCD violation during Read or Write to Bank 1", $time); if ((Ba == 2'b10) &amp;&amp; ($time - RCD_chk2 &lt; tRCD)) $display("at time %t ERROR: tRCD violation during Read or Write to Bank 2", $time); if ((Ba == 2'b11) &amp;&amp; ($time - RCD_chk3 &lt; tRCD)) $display("at time %t ERROR: tRCD violation during Read or Write to Bank 3", $time); // Read Command if (Read_enable == 1'b1) begin // CAS Latency pipeline if (Cas_latency_3 == 1'b1) begin if (Addr[10] == 1'b1) begin Command[2] = `READ_A; end else begin Command[2] = `READ; end Col_addr[2] = Addr; Bank_addr[2] = Ba; end else if (Cas_latency_2 == 1'b1) begin if (Addr[10] == 1'b1) begin Command[1] = `READ_A; end else begin Command[1] = `READ; end Col_addr[1] = Addr; Bank_addr[1] = Ba; end // Read interrupt Write (terminate Write immediately) if (Data_in_enable == 1'b1) begin Data_in_enable = 1'b0; end // Write Command end else if (Write_enable == 1'b1) begin if (Addr[10] == 1'b1) begin Command[0] = `WRITE_A; end else begin Command[0] = `WRITE; end Col_addr[0] = Addr; Bank_addr[0] = Ba; // Write interrupt Write (terminate Write immediately) if (Data_in_enable == 1'b1) begin Data_in_enable = 1'b0; end // Write interrupt Read (terminate Read immediately) if (Data_out_enable == 1'b1) begin Data_out_enable = 1'b0; end end // Interrupting a Write with Autoprecharge if (Auto_precharge[Bank] == 1'b1 &amp;&amp; Write_precharge[Bank] == 1'b1) begin RW_interrupt_write[Bank] = 1'b1; if (Debug) $display ("at time %t NOTE : Read/Write Bank %d interrupt Write Bank %d with Autoprecharge", $time, Ba, Bank); end // Interrupting a Read with Autoprecharge if (Auto_precharge[Bank] == 1'b1 &amp;&amp; Read_precharge[Bank] == 1'b1) begin RW_interrupt_read[Bank] = 1'b1; if (Debug) $display ("at time %t NOTE : Read/Write Bank %d interrupt Read Bank %d with Autoprecharge", $time, Ba, Bank); end // Read or Write with Auto Precharge if (Addr[10] == 1'b1) begin Auto_precharge[Ba] = 1'b1; Count_precharge[Ba] = 0; if (Read_enable == 1'b1) begin Read_precharge[Ba] = 1'b1; end else if (Write_enable == 1'b1) begin Write_precharge[Ba] = 1'b1; end end end // Read with Auto Precharge Calculation // The device start internal precharge: // 1. CAS Latency - 1 cycles before last burst // and 2. Meet minimum tRAS requirement // or 3. Interrupt by a Read or Write (with or without AutoPrecharge) if ((Auto_precharge[0] == 1'b1) &amp;&amp; (Read_precharge[0] == 1'b1)) begin if ((($time - RAS_chk0 &gt;= tRAS) &amp;&amp; // Case 2 ((Burst_length_1 == 1'b1 &amp;&amp; Count_precharge[0] &gt;= 1) || // Case 1 (Burst_length_2 == 1'b1 &amp;&amp; Count_precharge[0] &gt;= 2) || (Burst_length_4 == 1'b1 &amp;&amp; Count_precharge[0] &gt;= 4) || (Burst_length_8 == 1'b1 &amp;&amp; Count_precharge[0] &gt;= 8))) || (RW_interrupt_read[0] == 1'b1)) begin // Case 3 Pc_b0 = 1'b1; Act_b0 = 1'b0; RP_chk0 = $time; Auto_precharge[0] = 1'b0; Read_precharge[0] = 1'b0; RW_interrupt_read[0] = 1'b0; if (Debug) $display ("at time %t NOTE : Start Internal Auto Precharge for Bank 0", $time); end end if ((Auto_precharge[1] == 1'b1) &amp;&amp; (Read_precharge[1] == 1'b1)) begin if ((($time - RAS_chk1 &gt;= tRAS) &amp;&amp; ((Burst_length_1 == 1'b1 &amp;&amp; Count_precharge[1] &gt;= 1) || (Burst_length_2 == 1'b1 &amp;&amp; Count_precharge[1] &gt;= 2) || (Burst_length_4 == 1'b1 &amp;&amp; Count_precharge[1] &gt;= 4) || (Burst_length_8 == 1'b1 &amp;&amp; Count_precharge[1] &gt;= 8))) || (RW_interrupt_read[1] == 1'b1)) begin Pc_b1 = 1'b1; Act_b1 = 1'b0; RP_chk1 = $time; Auto_precharge[1] = 1'b0; Read_precharge[1] = 1'b0; RW_interrupt_read[1] = 1'b0; if (Debug) $display ("at time %t NOTE : Start Internal Auto Precharge for Bank 1", $time); end end if ((Auto_precharge[2] == 1'b1) &amp;&amp; (Read_precharge[2] == 1'b1)) begin if ((($time - RAS_chk2 &gt;= tRAS) &amp;&amp; ((Burst_length_1 == 1'b1 &amp;&amp; Count_precharge[2] &gt;= 1) || (Burst_length_2 == 1'b1 &amp;&amp; Count_precharge[2] &gt;= 2) || (Burst_length_4 == 1'b1 &amp;&amp; Count_precharge[2] &gt;= 4) || (Burst_length_8 == 1'b1 &amp;&amp; Count_precharge[2] &gt;= 8))) || (RW_interrupt_read[2] == 1'b1)) begin Pc_b2 = 1'b1; Act_b2 = 1'b0; RP_chk2 = $time; Auto_precharge[2] = 1'b0; Read_precharge[2] = 1'b0; RW_interrupt_read[2] = 1'b0; if (Debug) $display ("at time %t NOTE : Start Internal Auto Precharge for Bank 2", $time); end end if ((Auto_precharge[3] == 1'b1) &amp;&amp; (Read_precharge[3] == 1'b1)) begin if ((($time - RAS_chk3 &gt;= tRAS) &amp;&amp; ((Burst_length_1 == 1'b1 &amp;&amp; Count_precharge[3] &gt;= 1) || (Burst_length_2 == 1'b1 &amp;&amp; Count_precharge[3] &gt;= 2) || (Burst_length_4 == 1'b1 &amp;&amp; Count_precharge[3] &gt;= 4) || (Burst_length_8 == 1'b1 &amp;&amp; Count_precharge[3] &gt;= 8))) || (RW_interrupt_read[3] == 1'b1)) begin Pc_b3 = 1'b1; Act_b3 = 1'b0; RP_chk3 = $time; Auto_precharge[3] = 1'b0; Read_precharge[3] = 1'b0; RW_interrupt_read[3] = 1'b0; if (Debug) $display ("at time %t NOTE : Start Internal Auto Precharge for Bank 3", $time); end end // Internal Precharge or Bst if (Command[0] == `PRECH) begin // Precharge terminate a read with same bank or all banks if (Bank_precharge[0] == Bank || A10_precharge[0] == 1'b1) begin if (Data_out_enable == 1'b1) begin Data_out_enable = 1'b0; end end end else if (Command[0] == `BST) begin // BST terminate a read to current bank if (Data_out_enable == 1'b1) begin Data_out_enable = 1'b0; end end if (Data_out_enable == 1'b0) begin Dq_reg &lt;= #tOH &#123;data_bits&#123;1'bz&#125;&#125;; end // Detect Read or Write command if (Command[0] == `READ || Command[0] == `READ_A) begin Bank = Bank_addr[0]; Col = Col_addr[0]; Col_brst = Col_addr[0]; if (Bank_addr[0] == 2'b00) begin Row = B0_row_addr; end else if (Bank_addr[0] == 2'b01) begin Row = B1_row_addr; end else if (Bank_addr[0] == 2'b10) begin Row = B2_row_addr; end else if (Bank_addr[0] == 2'b11) begin Row = B3_row_addr; end Burst_counter = 0; Data_in_enable = 1'b0; Data_out_enable = 1'b1; end else if (Command[0] == `WRITE || Command[0] == `WRITE_A) begin Bank = Bank_addr[0]; Col = Col_addr[0]; Col_brst = Col_addr[0]; if (Bank_addr[0] == 2'b00) begin Row = B0_row_addr; end else if (Bank_addr[0] == 2'b01) begin Row = B1_row_addr; end else if (Bank_addr[0] == 2'b10) begin Row = B2_row_addr; end else if (Bank_addr[0] == 2'b11) begin Row = B3_row_addr; end Burst_counter = 0; Data_in_enable = 1'b1; Data_out_enable = 1'b0; end // DQ buffer (Driver/Receiver) if (Data_in_enable == 1'b1) begin // Writing Data to Memory // Array buffer if (Bank == 2'b00) Dq_dqm [data_bits - 1 : 0] = Bank0 [&#123;Row, Col&#125;]; if (Bank == 2'b01) Dq_dqm [data_bits - 1 : 0] = Bank1 [&#123;Row, Col&#125;]; if (Bank == 2'b10) Dq_dqm [data_bits - 1 : 0] = Bank2 [&#123;Row, Col&#125;]; if (Bank == 2'b11) Dq_dqm [data_bits - 1 : 0] = Bank3 [&#123;Row, Col&#125;]; // Dqm operation if (Dqm[0] == 1'b0) Dq_dqm [ 7 : 0] = Dq [ 7 : 0]; if (Dqm[1] == 1'b0) Dq_dqm [15 : 8] = Dq [15 : 8]; //if (Dqm[2] == 1'b0) Dq_dqm [23 : 16] = Dq [23 : 16]; // if (Dqm[3] == 1'b0) Dq_dqm [31 : 24] = Dq [31 : 24]; // Write to memory if (Bank == 2'b00) Bank0 [&#123;Row, Col&#125;] = Dq_dqm [data_bits - 1 : 0]; if (Bank == 2'b01) Bank1 [&#123;Row, Col&#125;] = Dq_dqm [data_bits - 1 : 0]; if (Bank == 2'b10) Bank2 [&#123;Row, Col&#125;] = Dq_dqm [data_bits - 1 : 0]; if (Bank == 2'b11) Bank3 [&#123;Row, Col&#125;] = Dq_dqm [data_bits - 1 : 0]; if (Bank == 2'b11 &amp;&amp; Row==10'h3 &amp;&amp; Col[7:4]==4'h4) $display("at time %t WRITE: Bank = %d Row = %d, Col = %d, Data = Hi-Z due to DQM", $time, Bank, Row, Col); //$fdisplay(test_file,"bank:%h row:%h col:%h write:%h",Bank,Row,Col,Dq_dqm); // Output result if (Dqm == 4'b1111) begin if (Debug) $display("at time %t WRITE: Bank = %d Row = %d, Col = %d, Data = Hi-Z due to DQM", $time, Bank, Row, Col); end else begin if (Debug) $display("at time %t WRITE: Bank = %d Row = %d, Col = %d, Data = %d, Dqm = %b", $time, Bank, Row, Col, Dq_dqm, Dqm); // Record tWR time and reset counter WR_chk [Bank] = $time; WR_counter [Bank] = 0; end // Advance burst counter subroutine #tHZ Burst; end else if (Data_out_enable == 1'b1) begin // Reading Data from Memory //$display("%h , %h, %h",Bank0,Row,Col); // Array buffer if (Bank == 2'b00) Dq_dqm [data_bits - 1 : 0] = Bank0 [&#123;Row, Col&#125;]; if (Bank == 2'b01) Dq_dqm [data_bits - 1 : 0] = Bank1 [&#123;Row, Col&#125;]; if (Bank == 2'b10) Dq_dqm [data_bits - 1 : 0] = Bank2 [&#123;Row, Col&#125;]; if (Bank == 2'b11) Dq_dqm [data_bits - 1 : 0] = Bank3 [&#123;Row, Col&#125;]; // Dqm operation if (Dqm_reg0[0] == 1'b1) Dq_dqm [ 7 : 0] = 8'bz; if (Dqm_reg0[1] == 1'b1) Dq_dqm [15 : 8] = 8'bz; if (Dqm_reg0[2] == 1'b1) Dq_dqm [23 : 16] = 8'bz; if (Dqm_reg0[3] == 1'b1) Dq_dqm [31 : 24] = 8'bz; // Display result Dq_reg [data_bits - 1 : 0] = #tAC Dq_dqm [data_bits - 1 : 0]; if (Dqm_reg0 == 4'b1111) begin if (Debug) $display("at time %t READ : Bank = %d Row = %d, Col = %d, Data = Hi-Z due to DQM", $time, Bank, Row, Col); end else begin if (Debug) $display("at time %t READ : Bank = %d Row = %d, Col = %d, Data = %d, Dqm = %b", $time, Bank, Row, Col, Dq_reg, Dqm_reg0); end // Advance burst counter subroutine Burst; end end // Write with Auto Precharge Calculation // The device start internal precharge: // 1. tWR Clock after last burst // and 2. Meet minimum tRAS requirement // or 3. Interrupt by a Read or Write (with or without AutoPrecharge) always @ (WR_counter[0]) begin if ((Auto_precharge[0] == 1'b1) &amp;&amp; (Write_precharge[0] == 1'b1)) begin if ((($time - RAS_chk0 &gt;= tRAS) &amp;&amp; // Case 2 (((Burst_length_1 == 1'b1 || Write_burst_mode == 1'b1) &amp;&amp; Count_precharge [0] &gt;= 1) || // Case 1 (Burst_length_2 == 1'b1 &amp;&amp; Count_precharge [0] &gt;= 2) || (Burst_length_4 == 1'b1 &amp;&amp; Count_precharge [0] &gt;= 4) || (Burst_length_8 == 1'b1 &amp;&amp; Count_precharge [0] &gt;= 8))) || (RW_interrupt_write[0] == 1'b1 &amp;&amp; WR_counter[0] &gt;= 2)) begin // Case 3 (stop count when interrupt) Auto_precharge[0] = 1'b0; Write_precharge[0] = 1'b0; RW_interrupt_write[0] = 1'b0; #tWRa; // Wait for tWR Pc_b0 = 1'b1; Act_b0 = 1'b0; RP_chk0 = $time; if (Debug) $display ("at time %t NOTE : Start Internal Auto Precharge for Bank 0", $time); end end end always @ (WR_counter[1]) begin if ((Auto_precharge[1] == 1'b1) &amp;&amp; (Write_precharge[1] == 1'b1)) begin if ((($time - RAS_chk1 &gt;= tRAS) &amp;&amp; (((Burst_length_1 == 1'b1 || Write_burst_mode == 1'b1) &amp;&amp; Count_precharge [1] &gt;= 1) || (Burst_length_2 == 1'b1 &amp;&amp; Count_precharge [1] &gt;= 2) || (Burst_length_4 == 1'b1 &amp;&amp; Count_precharge [1] &gt;= 4) || (Burst_length_8 == 1'b1 &amp;&amp; Count_precharge [1] &gt;= 8))) || (RW_interrupt_write[1] == 1'b1 &amp;&amp; WR_counter[1] &gt;= 2)) begin Auto_precharge[1] = 1'b0; Write_precharge[1] = 1'b0; RW_interrupt_write[1] = 1'b0; #tWRa; // Wait for tWR Pc_b1 = 1'b1; Act_b1 = 1'b0; RP_chk1 = $time; if (Debug) $display ("at time %t NOTE : Start Internal Auto Precharge for Bank 1", $time); end end end always @ (WR_counter[2]) begin if ((Auto_precharge[2] == 1'b1) &amp;&amp; (Write_precharge[2] == 1'b1)) begin if ((($time - RAS_chk2 &gt;= tRAS) &amp;&amp; (((Burst_length_1 == 1'b1 || Write_burst_mode == 1'b1) &amp;&amp; Count_precharge [2] &gt;= 1) || (Burst_length_2 == 1'b1 &amp;&amp; Count_precharge [2] &gt;= 2) || (Burst_length_4 == 1'b1 &amp;&amp; Count_precharge [2] &gt;= 4) || (Burst_length_8 == 1'b1 &amp;&amp; Count_precharge [2] &gt;= 8))) || (RW_interrupt_write[2] == 1'b1 &amp;&amp; WR_counter[2] &gt;= 2)) begin Auto_precharge[2] = 1'b0; Write_precharge[2] = 1'b0; RW_interrupt_write[2] = 1'b0; #tWRa; // Wait for tWR Pc_b2 = 1'b1; Act_b2 = 1'b0; RP_chk2 = $time; if (Debug) $display ("at time %t NOTE : Start Internal Auto Precharge for Bank 2", $time); end end end always @ (WR_counter[3]) begin if ((Auto_precharge[3] == 1'b1) &amp;&amp; (Write_precharge[3] == 1'b1)) begin if ((($time - RAS_chk3 &gt;= tRAS) &amp;&amp; (((Burst_length_1 == 1'b1 || Write_burst_mode == 1'b1) &amp;&amp; Count_precharge [3] &gt;= 1) || (Burst_length_2 == 1'b1 &amp;&amp; Count_precharge [3] &gt;= 2) || (Burst_length_4 == 1'b1 &amp;&amp; Count_precharge [3] &gt;= 4) || (Burst_length_8 == 1'b1 &amp;&amp; Count_precharge [3] &gt;= 8))) || (RW_interrupt_write[3] == 1'b1 &amp;&amp; WR_counter[3] &gt;= 2)) begin Auto_precharge[3] = 1'b0; Write_precharge[3] = 1'b0; RW_interrupt_write[3] = 1'b0; #tWRa; // Wait for tWR Pc_b3 = 1'b1; Act_b3 = 1'b0; RP_chk3 = $time; if (Debug) $display ("at time %t NOTE : Start Internal Auto Precharge for Bank 3", $time); end end end task Burst; begin // Advance Burst Counter Burst_counter = Burst_counter + 1; // Burst Type if (Mode_reg[3] == 1'b0) begin // Sequential Burst Col_temp = Col + 1; end else if (Mode_reg[3] == 1'b1) begin // Interleaved Burst Col_temp[2] = Burst_counter[2] ^ Col_brst[2]; Col_temp[1] = Burst_counter[1] ^ Col_brst[1]; Col_temp[0] = Burst_counter[0] ^ Col_brst[0]; end // Burst Length if (Burst_length_2) begin // Burst Length = 2 Col [0] = Col_temp [0]; end else if (Burst_length_4) begin // Burst Length = 4 Col [1 : 0] = Col_temp [1 : 0]; end else if (Burst_length_8) begin // Burst Length = 8 Col [2 : 0] = Col_temp [2 : 0]; end else begin // Burst Length = FULL Col = Col_temp; end // Burst Read Single Write if (Write_burst_mode == 1'b1) begin Data_in_enable = 1'b0; end // Data Counter if (Burst_length_1 == 1'b1) begin if (Burst_counter &gt;= 1) begin Data_in_enable = 1'b0; Data_out_enable = 1'b0; end end else if (Burst_length_2 == 1'b1) begin if (Burst_counter &gt;= 2) begin Data_in_enable = 1'b0; Data_out_enable = 1'b0; end end else if (Burst_length_4 == 1'b1) begin if (Burst_counter &gt;= 4) begin Data_in_enable = 1'b0; Data_out_enable = 1'b0; end end else if (Burst_length_8 == 1'b1) begin if (Burst_counter &gt;= 8) begin Data_in_enable = 1'b0; Data_out_enable = 1'b0; end end end endtask //**********************将SDRAM内的数据直接输出到外部文件*******************************///* integer sdram_data,ind; always@(sdram_r) begin sdram_data=$fopen("sdram_data.txt"); $display("Sdram dampout begin ",sdram_data);// $fdisplay(sdram_data,"Bank0："); for(ind=0;ind&lt;=mem_sizes;ind=ind+1) $fdisplay(sdram_data,"%h %b",ind,Bank0[ind]);// $fdisplay(sdram_data,"Bank1："); for(ind=0;ind&lt;=mem_sizes;ind=ind+1) $fdisplay(sdram_data,"%h %b",ind,Bank1[ind]);// $fdisplay(sdram_data,"Bank2："); for(ind=0;ind&lt;=mem_sizes;ind=ind+1) $fdisplay(sdram_data,"%h %b",ind,Bank2[ind]);// $fdisplay(sdram_data,"Bank3："); for(ind=0;ind&lt;=mem_sizes;ind=ind+1) $fdisplay(sdram_data,"%h %b",ind,Bank3[ind]); $fclose("sdram_data.txt"); //-&gt;compare; end */ integer sdram_data,sdram_mem; reg [24:0] aa,cc; reg [24:0] bb,ee; always@(sdram_r) begin $display("Sdram dampout begin ",$realtime); sdram_data=$fopen("sdram_data.txt"); for(aa=0;aa&lt;4*(mem_sizes+1);aa=aa+1) begin bb=aa[18:0]; if(aa&lt;=mem_sizes) $fdisplay(sdram_data,"%0d %0h",aa,Bank0[bb]); else if(aa&lt;=2*mem_sizes+1) $fdisplay(sdram_data,"%0d %0h",aa,Bank1[bb]); else if(aa&lt;=3*mem_sizes+2) $fdisplay(sdram_data,"%0d %0h",aa,Bank2[bb]); else $fdisplay(sdram_data,"%0d %0h",aa,Bank3[bb]); end $fclose("sdram_data.txt"); sdram_mem=$fopen("sdram_mem.txt"); for(cc=0;cc&lt;4*(mem_sizes+1);cc=cc+1) begin ee=cc[18:0]; if(cc&lt;=mem_sizes) $fdisplay(sdram_mem,"%0h",Bank0[ee]); else if(cc&lt;=2*mem_sizes+1) $fdisplay(sdram_mem,"%0h",Bank1[ee]); else if(cc&lt;=3*mem_sizes+2) $fdisplay(sdram_mem,"%0h",Bank2[ee]); else $fdisplay(sdram_mem,"%0h",Bank3[ee]); end $fclose("sdram_mem.txt"); end // // Timing Parameters for -75 (PC133) and CAS Latency = 2// specify// specparam//// tAH = 0.8, // Addr, Ba Hold Time//// tAS = 1.5, // Addr, Ba Setup Time//// tCH = 2.5, // Clock High-Level Width//// tCL = 2.5, // Clock Low-Level Width////// tCK = 10.0, // Clock Cycle Time 100mhz////// tCK = 7.5, // Clock Cycle Time 133mhz//// tCK = 7, // Clock Cycle Time 143mhz//// tDH = 0.8, // Data-in Hold Time//// tDS = 1.5, // Data-in Setup Time//// tCKH = 0.8, // CKE Hold Time//// tCKS = 1.5, // CKE Setup Time//// tCMH = 0.8, // CS#, RAS#, CAS#, WE#, DQM# Hold Time//// tCMS = 1.5; // CS#, RAS#, CAS#, WE#, DQM# Setup Time// tAH = 1, // Addr, Ba Hold Time// tAS = 1.5, // Addr, Ba Setup Time// tCH = 1, // Clock High-Level Width// tCL = 3, // Clock Low-Level Width//// tCK = 10.0, // Clock Cycle Time 100mhz//// tCK = 7.5, // Clock Cycle Time 133mhz// tCK = 7, // Clock Cycle Time 143mhz// tDH = 1, // Data-in Hold Time// tDS = 2, // Data-in Setup Time// tCKH = 1, // CKE Hold Time// tCKS = 2, // CKE Setup Time// tCMH = 0.8, // CS#, RAS#, CAS#, WE#, DQM# Hold Time// tCMS = 1.5; // CS#, RAS#, CAS#, WE#, DQM# Setup Time// $width (posedge Clk, tCH);// $width (negedge Clk, tCL);// $period (negedge Clk, tCK);// $period (posedge Clk, tCK);// $setuphold(posedge Clk, Cke, tCKS, tCKH);// $setuphold(posedge Clk, Cs_n, tCMS, tCMH);// $setuphold(posedge Clk, Cas_n, tCMS, tCMH);// $setuphold(posedge Clk, Ras_n, tCMS, tCMH);// $setuphold(posedge Clk, We_n, tCMS, tCMH);// $setuphold(posedge Clk, Addr, tAS, tAH);// $setuphold(posedge Clk, Ba, tAS, tAH);// $setuphold(posedge Clk, Dqm, tCMS, tCMH);// $setuphold(posedge Dq_chk, Dq, tDS, tDH);// endspecifyendmodule 仿真结果我们可以看到基于 sdram_model.v 运行了 201us 个周期后，modelsim 上打印信息显示我们初始化的操作是正确的。 仿真波形如图所示： 小结我们依芯片手册成功实现了 sdram 的上电初始化，接下来我们将继续进行后续的操作，我们将尽快更新~ 附件SDRAM 仿真模型文件：点击下载，提取码:yihx By Ricky]]></content>
      <categories>
        <category>IC Design</category>
        <category>SDRAM</category>
      </categories>
      <tags>
        <tag>SDRAM</tag>
        <tag>IC Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从计数器开始，看数字 IC 设计]]></title>
    <url>%2F%2Fposts%2F%E4%BB%8E%E8%AE%A1%E6%95%B0%E5%99%A8%E5%BC%80%E5%A7%8B%EF%BC%8C%E7%9C%8B%E6%95%B0%E5%AD%97-IC-%E8%AE%BE%E8%AE%A1.html</url>
    <content type="text"><![CDATA[计数器设计之前有实验室的学长去参加海思、中芯国际、瑞芯微、…… 数字 IC 前端方向的面试，几乎都问到了同一系列问题——设计一个计数器及相关问题。这里很多朋友就会觉得很有意思了，为什么一个简单的计数器能有这么多东西，那我们就『简单』的东西简单看。 0x00 请你设计一个 10 进制的异步复位无限循环计数器（0-9）首先，第一个问题，请你设计一个 10 进制的异步复位无限循环计数器（0-9），你会怎么做？ 相信到这很多朋友就开始洋洋洒洒地写道： 12345678910111213141516171819202122module counter10( input clk, input rst_n, output wire cnt_flag );reg[3:0] cnt_reg;always @(posedge clk or negedge rst) begin if( ~rst_n) begin cnt_reg &lt;= 4'b0; end else begin if(cnt_reg == 4'd9) cnt_reg &lt;= 4'b0; else cnt_reg &lt;= cnt_reg + 4'b1; end endassign cnt_flag = (cnt_reg == 4'd9) ? 1'b1 : 1'b0;endmodule 0x01 请画出对应的电路图Bravo! 没有任何问题！接下来开始有分水岭了，请画出对应的电路图 ，有的朋友可能会抓脑袋了： 这里给一点提示，看你能想起什么，确定状态 —— 确定激励方程 —— 逻辑图 —— 自启动检查 —— 状态表。这是什么？数字电路基础，为什么？我们这是数字集成电路设计啊！最终还是要回归到数字电路上来啊！ 好，那我们先用 D 触发器来做（不经过编码优化，只是还原最简单的设计步骤），回忆一下最初我们大一大二时怎么弄的。 状态表： 计数顺序 现状态 次状态 - Q3 Q2 Q1 Q0 D3 D2 D1 D0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 1 0 2 0 0 1 0 0 0 1 1 3 0 0 1 1 0 1 0 0 4 0 1 0 0 0 1 0 1 5 0 1 0 1 0 1 1 0 6 0 1 1 0 0 1 1 1 7 0 1 1 1 1 0 0 0 8 1 0 0 0 1 0 0 1 9 1 0 0 1 0 0 0 0 激励方程： 逻辑图： …… 剩下的估计大家都能回忆起来了 以上就是我们之前数字电路设计流程，我们回过头来看我们的硬件描述过程，有 if 判断值，那少不了比较器，有 + 运算，自然也有一个加法器 …… 当然我们真正的设计应该是先想好了有比较器和其他逻辑电路才有对应的硬件描述，但我们不妨来看一下我们设计的电路，不正是如下图所示： 0x02 上图中的关键路径是哪一条？Ok~ 解决了电路图，下一个问题又来了，上图中的关键路径是哪一条？ 要知道关键路径就需要时序分析啦，这里为接下来的另一个数字 IC 的小专栏———时序分析与约束挖下第一坑。 关键路径应该是：Q &gt; + &gt; MUX &gt; D (具体分析将在后面填坑，大家也可以先想想为什么不是 Q &gt; CMP &gt; MUX &gt; D) 0x03 上面图中 CMP = 9 即原描述中 cnt_reg == 4’d9 的电路是什么？接下来的问题，上面图中 CMP = 9 即原描述中 cnt_reg == 4’d9 的电路是什么？其实答案就在我们的触发器版原理图对应的组合电路中，精简后如下图所示： 0x04 cnt_reg == 4’d9 和 cnt_reg &gt; 8 有什么区别？功能上确实是一样的，但是如果是一个把 Verilog 当编程玩的朋友对于接下来的东就蛮有意义的了，cnt_reg == 4’d9 实现的电路如上图所示，是一个相对简单的组合逻辑电路。如果是 cnt_reg &gt; 8，对于我们 4 位数据来说可能的范围为 9~15，则综合工具会把所有的情况都列出，cnt_reg == 9,10,11 …… 这样在无形中就浪费了资源。若位宽更大则会被综合为cnt_reg - 8 &gt; 0，由此便会引入一个加法器 …… 0x05 加法器对应的电路是什么？如何验证这个计数器？……一系列的问题，我们可以发现并非那么简单的。要知道直到现在优化加法器的文章依然不时可以出现在 sci 检索期刊中，这另外说明为什么上一问引入加法器后带来的浪费用省略号来表示，为什么关键路径是到 + 而不是比较器 …… 小结引用《手把手教你设计 CPU——RISC-V 处理器篇》作者胡振波老师的一段话，当年第一次 Verilog 课时我的授课老师董乾博士也强调过类似的话。 先定义电路微架构而后编写代码。谨记 Verilog 只是一种硬件描述语言，IC 设计的本质是对于电路的设计，虽然现在Verilog Coding 采用 RTL 级别的抽象描述，但是必须清楚所描述的代码能够映射出的电路结构，其面积和时序的影响都了然于胸，只有如此才能够成为一名优秀的 IC 设计工程师。不要纠结 Verilog 的语法，而应立足实战。Verilog 的设计语法子集非常精简简单，很快就可以上手入门。入门之后最好的学习方法是进行设计实战（实战是最好的老师），而不是进一步纠结 Verilog 的语法（不要浪费脑力试图记住大多数高级的 Verilog 语法，而是在需要使用的时候查阅即可）。 By Ricky]]></content>
      <categories>
        <category>IC Design</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>IC Design</tag>
        <tag>计数器</tag>
        <tag>数字前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Docker + GitLab 构建自用的代码管理服务]]></title>
    <url>%2F%2Fposts%2F%E4%BD%BF%E7%94%A8-Docker-GitLab-%E6%9E%84%E5%BB%BA%E8%87%AA%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1.html</url>
    <content type="text"><![CDATA[准备工作系统要求 一台 Ubuntu 系统的电脑作为服务器（我这里是一台 Ubuntu Xenial 16.04 的电脑），其他版本和系统也可以，只要 Docker CE 支持即可，详情请访问 Docker 官网。 GitLab CE 要求内存 2G 以上 Docker 安装及配置Docker 是什么Docker 使用 Google 公司推出的 Go 语言进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 它是目前最流行的 Linux 容器解决方案！ 卸载旧版本旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：123$ sudo apt-get remove docker \ docker-engine \ docker.io 使用 APT 安装由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。 123456$ sudo apt-get update$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 鉴于国内网络的问题，建议使用国内源，官方源在注释中查看。为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。12345$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# 官方源# $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 然后，向 source.list 中添加 Docker 软件源 1234567891011$ sudo add-apt-repository \ "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) \ stable"# 官方源# $ sudo add-apt-repository \# "deb [arch=amd64] https://download.docker.com/linux/ubuntu \# $(lsb_release -cs) \# stable" 安装 Docker CE更新 apt 软件包缓存，并安装 docker-ce：123$ sudo apt-get update$ sudo apt-get install docker-ce 启动 Docker CE123$ sudo systemctl enable docker$ sudo systemctl start docker 建立 Docker 用户组默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 用户组：123$ sudo groupadd docker #新建 docker 用户组$ sudo usermod -aG docker $USER #将当前用户加入 docker 组 退出当前终端并重新登录，进行如下测试。 测试 Docker 是否正确安装12345678910111213141516171819202122232425262728$ docker run hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-worldd1725b59e92d: Pull completeDigest: sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 若能正常输出以上信息，则说明安装成功。 配置镜像加速因为国内网络的原因，后续拉取 Docker 镜像会十分缓慢，建议安装好 Docker 后配置一下国内镜像加速。Ubuntu 16.04 的配置方法如下（参考：Docker 中国）：修改 /etc/docker/daemon.json 文件并写入如下内容（如果文件不存在请新建该文件）：12345&#123; "registry-mirrors": [ "https://registry.docker-cn.com" ]&#125; 注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。 之后重新启动服务123$ sudo systemctl daemon-reload$ sudo systemctl restart docker 到此为止，Docker 就配置好了，接下来安装 GitLab CE 就十分简单了。 GitLab 安装及配置GitLab 是什么GitLab 是一个类似与 GitHub 的开源源码托管服务，它提供了一个基于 Git 的全功能软件开发平台，可以通过 Web 界面访问公有或私有的项目，还具备很多与软件开发协作相关的其他功能。利用 GitLab 提供的这些功能，可以实践一些项目管理和协作流程。这套流程借鉴于很多成功的开源项目，非常适合在小型团队里使用。 拉取 GitLab 镜像安装最新版 GitLab 镜像1sudo docker pull gitlab/gitlab-ce:latest 启动 GitLab使用 Docker 命令运行容器，命令如下：123456789sudo docker run -d \ --hostname gitlab.asicfans.com \ -p 8443:443 -p 8080:80 -p 2222:22 \ --name gitlab \ --restart always \ -v /srv/gitlab/config:/etc/gitlab \ -v /srv/gitlab/logs:/var/log/gitlab \ -v /srv/gitlab/data:/var/opt/gitlab \ gitlab/gitlab-ce:latest 注意修改 hostname 为自己的域名或者 ip 地址。-v 命令表示将原有的挂载目录重新映射到自己的目录，这三个参数将 GitLab 的配置、数据和日志持久化到文件系统上，这样就可以保证后面升级 GitLab 时数据不会丢失。-p 命令表示将原有的端口映射一下，避免常用端口被占用。我这里使用的都是安全端口。如果大家的环境没有限制或不冲突可以使用与容器同端口，如：-p 443:443 -p 80:80 -p 22:22上面的命令太长，也可以写成 shell 脚本123456789101112131415$ cat &lt;&lt;EOF &gt; start.sh#!/bin/bashHOST_NAME=gitlab.asicfans.comdocker stop gitlabdocker rm gitlabsudo docker run -d \\ --hostname \$&#123;HOST_NAME&#125; \\ -p 8443:443 -p 8080:80 -p 2222:22 \\ --name gitlab \\ --restart always \\ -v /srv/gitlab/config:/etc/gitlab \\ -v /srv/gitlab/logs:/var/log/gitlab \\ -v /srv/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:latestEOF 脚本编辑好之后运行脚本就可以了，就再也不用输入这么长的命令了！1$ sh start.sh 配置环境修改 /etc/hosts 文件，使在本地端可以使用域名访问1127.0.0.1 gitlab.asicfans.com 这样就可以使用 http://gitlab.asicfans.com:8080 域名在本地从浏览器访问 GitLab 了（GitLab 初次启动会比较慢，等待大约一分钟）。 试用 GitLab首先根据提示输入管理员密码，这个密码是管理员用户的密码。对应的用户名是 root，用于以管理员身份登录 GitLab。 设置好密码后去注册一个普通账号 注册成功后会跳到首页，这样就可以创建一个项目了 项目建好了，我们加一个 ssh key，以后本地 pull/push 就简单啦! 首先去到添加 ssh key 的页面 然后拿到我们的 ssh key 贴到框框里就行了获取 ssh key：123456# 先看看是不是已经有了，如果有内容就直接 copy 贴过去就行啦$ cat ~/.ssh/id_rsa.pub# 如果上一步没有这个文件 我们就创建一个，运行下面命令（邮箱改成自己的），一路回车就好了$ ssh-keygen -t rsa -C "youremail@example.com"$ cat ~/.ssh/id_rsa.pub 点开我们刚创建的项目，复制项目 ssh 的地址。添加个文件，测试一下（我的项目叫 test）12345678$ git clone ssh://git@gitlab.asicfans.com:2222/wangqq/test.git$ cd test &amp;&amp; echo test &gt; README.md # 添加文件#push 上去$ git add .$ git commit -m "test"$ git push origin master 这样我们就可以在 GitLab 上看到我们刚才提交的结果了。到这 GitLab 的本地端使用就已经没问题了，但是要想不在家，或者在其他地方也可以访问，那我们就需要进行一下，内网穿透！ frp 配置配置 frp 你需要有一个有公网 ip 的云服务器和自己的域名，然后在云服务器和本地端分别下载安装 frp 并进行配置。 下载与系统对应的 frp 文件，frp 支持多种系统架构，详情请访问 frp 查看 123456789$ uname -a # 首先使用 uname 命令查看一下你的系统# 我这里是 Ubuntu x86_x64 所以下载 Linux_amd64 的软件包$ wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz# 解压安装包$ tar -zxvf frp_0.21.0_linux_amd64.tar.gz$ cd frp_0.21.0_linux_amd64 然后分别配置服务器端的 frps.ini 文件和本地端的 frpc.ini 文件。 1.修改 frps.ini 文件 123456# frps.ini[common] bind_port = 7000 # 穿透使用的端口vhost_http_post = 80 # 从外网访问的端口subdomain_host = asicfans.com # 主域名token = xxxx # 服务器与本地的校验信息，校验信息错误无法穿透，自行设置 2.启动 frps 1$ ./frps -c ./frps.ini 3.修改 frpc.ini 文件 12345678910# frpc.ini[common]server_addr = x.x.x.x # 你的服务器 ip 地址server_port = 7000 # 开放的穿透端口token = xxxx # 需要与服务器端一致[gitlab]type = httplocal_port = 8080subdomain = gitlab 4.启动 frpc 1$ ./frpc -c ./frpc.ini 5.将 gitlab.asicfans.com 的域名 A 记录解析到 ip x.x.x.x， 如果服务器已经有了对应的域名，也可以将 CNAME 记录解析到服务器原先的域名。 6.通过浏览器访问 http://gitlab.asicfans.com 即可访问到处于内网的 gitlab 服务了。这样就不用使用 ssh key 的方式 clone/pull/push 代码仓库了，就可以直接使用 http 的方式进行操作了！ 十分方便！ 自此，我们就可以让自己和小伙伴们一起愉快的在 GitLab 上玩耍啦！！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>GitLab</tag>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提升数字 IC 设计效率从 Vim 开始]]></title>
    <url>%2F%2Fposts%2F%E6%8F%90%E5%8D%87%E6%95%B0%E5%AD%97-IC-%E8%AE%BE%E8%AE%A1%E6%95%88%E7%8E%87%E4%BB%8E-Vim-%E5%BC%80%E5%A7%8B.html</url>
    <content type="text"><![CDATA[Vim这篇文章主要分享给在 Windows 下进行数字 IC 开发的盆友们，如果早已 linux，请大神自行忽略，另外建议在 Windows 下的盆友早日脚踏两只船。相信大家都有过为了追一个信号而不断地缩放 RTL 图的经历，有没有一种办法能一键式一条龙服务呢？有！用 Vim！ Vim，一种类似于 notepad 的文本编辑器，其拥有你喜欢的一切功能（护眼模式，关键词高亮 …… 废话没有这些还叫代码文本编辑器），其针对 Verilog 的项目维护是真的善良，黑暗中的阳光。 但这阳光大多数情况下照亮于 Linux 或者 Unix 系统下，那我们试试怎么让光照进 Windows。 安装 Cygwin Cygwin 是一个在 Windows 平台上运行的 Unix 模拟环境，是 Cygnus solutions 公司开发的自由软件（该公司开发了很多好东西，著名的还有 eCos，不过现已被 Redhat 收购）。它对于学习 Unix/Linux 操作环境，或者从 Unix 到 Windows 的应用程序移植，或者进行某些特殊的开发工作，尤其是使用 gnu 工具集在 Windows 上进行嵌入式系统开发，非常有用。随着嵌入式系统开发在国内日渐流行，越来越多的开发者对 Cygwin 产生了兴趣。 下载好 Cygwin 后选择好安装路径，然后选择镜像网址，建议选择国内的镜像地址速度会快一些。可以使用网易的镜像地址：http://mirrors.163.com ,在 URL 栏自行输入镜像地址点击 add 添加后使用。 然后就进入选择安装包，初次进入建议都选择，高手可以有需要的时候可以再进来这个安装页面选择安装。安装完成之后，把 Cygwin 添加到右键菜单，打开便是当前的路径下，这才是 Windows 该有的体验不是吗？而完成这一切只需简单地修改一下注册表。（以下步骤参考网络资源）： 使用Win + R打开运行窗口, 输入 regedit, 回车, 启动注册表编辑程序，找到 HKEY_CLASSES_ROOT\Directory\Background\shell 表项; 右键点击shell，选择新建-&gt;项，命名为Cygwin，或者其他，你右键时看到的就是Cygwin,或者是你自定义的名称; 右键点击刚才创建的Cygwin，选择新建-&gt;项,命名为command，表示点击该菜单项时要执行的命令; 双击command下(默认)数据项，在数值数据(V)下输入如下内容：&quot;D:\Coding\Cygwin\bin\mintty.exe&quot;-i/Cygwin-Terminal.ico /bin/env _T=%V /bin/bash -l&quot;（你的 Cygwin 安装路径） 这样就可以直接在对应的文件夹通过右击菜单打开命令行窗口。Cygwin 配置好后，接下来我们继续配置一下 Vim 。 Vim 配置 让bash命令行支持中文输入，打开 Cygwin 终端，在终端中输入如下命令 vim ~/.inputrc，打开inputrc 文件，将下面几行的注释去掉（去掉#），保存并退出。 1234set meta-flag onset convert-meta offset input-meta onset output-meta on 让 ls 命令支持中文显示，在终端中输入命令 vim ~/.bashrc ，打开 bashrc 文件修改： 1alias ls='ls -hF –-show-control-chars –-color=tty' 配置一个个人喜好的 Vim，打开 Cygwin 终端，输入vim ~/.vimrc，编辑如下设置 1234567891011121314set fenc=utf-8 "设定默认解码 set fencs=utf-8,usc-bom,gb18030,gbk,gb2312,cp936,euc-jpset nocp "或者 set nocompatible 用于关闭 VI 的兼容模式 set number "显示行号 set ai "或者 set autoindent vim 使用自动对齐，也就是把当前行的对齐格式应用到下一行 set si "或者 set smartindent 依据上面的对齐格式，智能的选择对齐方式set tabstop=4 "设置 tab 键为4个空格set sw=4 "或者 set shiftwidth 设置当行之间交错时使用4个空格set ruler "设置在编辑过程中,于右下角显示光标位置的状态行 set incsearch "设置增量搜索,这样的查询比较smart set showmatch "高亮显示匹配的括号 set matchtime=5 "匹配括号高亮时间(单位为 1/10 s) set ignorecase "在搜索的时候忽略大小写 syntax on "高亮语法 成功后界面如下图所示 使用 Vim 提升开发效率首先，你需要进入项目工程的顶层目录，假设你整个项目最顶层的目录名叫 Vimtest，那么你就先进入这个目录，然后调用 ctags 工具生成整个工程目录的标签列表。 12$ cd Vimtest # youproject name$ ctags -R * 顺利的话，你将会看到在 Vimtest 下新创建了一个叫 tags 的文件，在这个文件里将会以“定义名称 文件位置：行数”的格式将你所有项目中的模块，信号，参数定义全部列出，而此处参数-R的含义是递归执行，也就是从顶层目录向下自动遍历全部子目录进行文件检索和定义收录。在默认配置下，ctags 可以自动识别.v和.vhdl后缀文件的语法，如果你同时希望收录测试平台中的.sv文件的话，可能你需要额外增加一个 System Verilog 的语法说明文件。有了这个标签列表之后应该如何使用呢？总不能每次都打开这个 tags 文件然后挨个查询吧？当然不是，接下来我们需要把这个 tags 文件和 Vim 结合起来。首先我们需要再次打开.vimrc 文件打开 cygwin 终端，输入 vim ~/.vimrc， 打开文件后输入一下内容: 123set tags=tags;set autochdirnnoremap t :tag 第一行命令的含义是指定标签列表名称为 tags，命令最末的;号不可省略，其含义是告知 Vim 首先在当前目录下寻找 tags 文件，如果找不到则自动向更上一级目录查找，现在你明白为什么我们一开始要把 tags 文件生成在项目的顶层目录了吧。第二行命令不是必须的，其含义是每次打开新的文件时，自动将终端切换到该文件的所在目录下。 下面就是见证奇迹的时刻了。你可以进入项目目录下的任何一个子目录，然后 vim top.v（我的工程顶层文件名，你可以叫别的名字）。如果你的vimrc配置跟我上文写的一模一样，那么你就按一下t，如果你的vimrc里没有nnoremap t:tag这一句的话，请手工输入:tag（此处有空格）。然后接着输入任何项目中存在的模块名称，信号名称或者参数名称。比如项目中有一个模块名叫uart，那么完整的命令应该是:tag uart。注意，如果你并不记得模块的完整名称也没关系，随时按下 tab 键都可以自动补全，即使你连开头都不记得了，还可以用/keyword的办法进行搜索。输入完毕后按下回车，如果 Vim 在标签列表中只找到唯一匹配定义的话，就会立刻跳转到对应文件的对应行；如果找到的匹配结果不止一个，就会把所有结果列出来让你用数字序号选择跳转目标。 很多老手看到这里可能觉得不够过瘾，就只是这样而已，我也早就会了，只不过嫌太麻烦而已，还不是要不停输入模块名称吗，能快到哪里去？呵呵，最会偷懒的我怎么可能只是做到这样的程度而已呢？大家觉得，平时在修改代码设计的时候，最需要进行频繁文件跳转的是什么时候？是不是当你找到了一个关键的寄存器，想顺着信号的传播路径一直跟踪下去的时候？当你跟着这个信号来到一个模块例化面前，是不是恨不能立刻跟着信号钻进这个模块的代码里去？其实，这非常简单。 根据我们前面的介绍，你肯定已经想到了，可以通过:tag module_name跳转到这个模块的设计文件，但是这样太麻烦了，万一模块名字老长还带有大小写，写一遍就得费老半天功夫。有一个相对简单的办法，把光标移动到模块名称上，按下ctrl+]，你会发现自己立刻飞到了该模块的设计文件中！但是！！等等！！我刚才要跟踪的信号是什么名字来着？忘记了对不对？这个方法还是不够方便。有没有更简单的办法？这个办法最好能从我们决定要进入这个模块的那一刻起，只用一个按键操作就能立刻进入这个模块的设计文件，同时光标最好还能直接定位到我们要追踪的信号位置，这个信号的名字最好还能被高亮显示！当！然！没！问！题！ 在 vimrc 文件中加入 1nnoremap [] 重新打开任何 Vim 文件，假装自己跟踪到了某个模块例化的某个信号上，类似.clk，通常你跟踪到这里的时候，光标应该是放在 clk上面，这时你在键盘上快速按下[和]这两个键，发生了什么？？！！！我是谁？？！我在哪里？！！！恭喜你！成功进入了该模块！！！并且光标飞到了之前 clk 所连接的 module 上！！好了我们可以和过去为了追信号而需要不断 zoom in zoom out 的 RTL 图说再见了~ By Ricky 参考源:https://www.jianshu.com/p/fac45920628dhttps://blog.csdn.net/samxx8/article/details/38777189https://blog.csdn.net/hao508506/article/details/52440220http://kellen.wang/zh/useful-skills-of-vim-while-coding-verilog/]]></content>
      <categories>
        <category>IC Design</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>IC Design</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总线- SoC 内部的主干道]]></title>
    <url>%2F%2Fposts%2F%E6%80%BB%E7%BA%BF-SoC-%E5%86%85%E9%83%A8%E7%9A%84%E4%B8%BB%E5%B9%B2%E9%81%93.html</url>
    <content type="text"><![CDATA[总线—— SoC 内部的主干道开坑！从今天开始来聊一点数字 IC 的一些知识！首先来看一看总线平日里我们都在讲总线总线，连接各模块的公共线，那它在 ARM 芯片中起到了啥木作用，来胡乱绉一通。 总线的功能总线通俗得理解可以完成以下功能： 提供时钟 分配（管理）地址 响应中断 传输数据 传送控制信号 USB 总线以平日里最常见的 USB 为例，USB 其实也是一种总线如下图所示，通常我们计算机连接到 USB 后，USB 提供的总线可以拓展连接到我们的外设，例如 U 盘、键盘、鼠标等……但是设备本身不会与 CPU 进行通信，它们只与 USB HOST 进行通信，USB HOST 会给它们分配相应的中断。一旦 USB 设备插入 USB 接口引起物理上的电平变化便会有中断，此刻的中断并非 CPU 的中断，此时的中断是 USB HOST 的中断，此中断经一定的处理后发送至 CPU 后，CPU监测到是 USB HOST 中断，便将中断交付 USB HOST 进行处理。再来看地址的问题，CPU 是无法直接访问到你的设备的，红色方框内可以看做是一个“家族”，CPU 只能访问到其“家长” USB HOST，USB HOST 访问具体设备才用到地址访问。例如此时 U 盘的地址是 0x0007H，若此地址直接由 CPU 访问的话 CPU 最终只会访问到内存的 0x0007H，而非我们的 U 盘，因此将此地址交付 USB HOST 进行访问才能实现。这里就能看出不仅仅内存有地址，引入总线后，各个外设也有了对应的地址。 AMBA 总线回到 ARM 上来，ARM 的总线遵循 AMBA（ARM 爸——安谋爸爸）的总线规范，ARM 为了让大家能尽可能地接外设变作了个 AMBA 总线规范，通常 AMBA 规范下常见的总线分别是 AHB（高速总线），APB（外设总线），ASB（AHB 备胎）如图所示。 我们可以把 APB 总线当做乡村公路，AHB 总线当做一条省道，把这两条路连接起来的“十字路”可以叫做“Bus bridges”。AHB 上的设备通常速度较快例如：内存控制器，NAND Flash …… APB 就较慢，例如 UART，GPIO ……最直观的 UART 通常我们最快设置的波特率大概就 115200，还不到 M 级，因此就放在乡村公路跑就可以了。那么不同的路就要跑不同的频率，那么通常设计的外设的 controller 时，其控制时钟就由总线提供，以保证操作的同步性，那么在 IP 中我们就可以看到有叫做 HCLK（AHB）的信号和 PCLK（APB）的信号。我们还可以看到在 M3 和总线之间还有一个模块叫做 BusMatrix，其主要负责多主设备和多从设备的交互和仲裁，目的是为了提高不同主机访问不同外设情况下的带宽，另外一个就是简化 Bus Master 的协议设计（今后有机会进去分析）。 FCLK、HCLK、PCLK我们都知道的是芯片内部的“心跳”是由外部晶振给的，外部晶振通常就十几二十兆，但芯片内部动辄七八十兆甚至上 G，那这里就离不开一个叫 CLKCNTL 的东西，它负责提各个部分的“心跳”。刚才我们也说到 APB 和 AHB 是不同速度的公路，因此它们的工作频率是不同的（实际上可以相同的，但其分类的意义就不大了），而 CPU 本身的工作频率也是不同的。如图所示，给 ARM 用的是 FCLK（全局时钟）， 你可以将 PLL 出来的 70MHz 频率分频多少给 FCLK，将 70MHz 频率分频多少给 HCLK,PCLK 这就是 CLKCNTL 做的事，CLKCNTL 分配出来的 FCLK,HCLK,PCLK 三者成一定的倍数关系。 具体到 AHB,APB 总线协议和使用应用，今后我们将会逐一胡扯乱绉。技术不到家全靠虾扯蛋，错误应该是满天飞，望各位大神指正。先挖个坑，下次更 AHB 总线下 SRAM 的控制器设计。 By Ricky]]></content>
      <categories>
        <category>IC Design</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>IC Design</tag>
        <tag>SoC</tag>
        <tag>AMBA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用树莓派 3b 和 RTL_SDR 搭建小功率无线电监测点]]></title>
    <url>%2F%2Fposts%2F%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3b%E5%92%8CRTL-SDR%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%8A%9F%E7%8E%87%E6%97%A0%E7%BA%BF%E7%94%B5%E7%9B%91%E6%B5%8B%E7%82%B9.html</url>
    <content type="text"><![CDATA[最近看了两部关于无线电相关的电影（『时空接触』、『黑洞频率』），对与无线电产生了很大的兴趣。现代由于互联网的发展，玩无线电的人越来越少了，了解无线电知识的人也不多了。但是还是有很多人在学习和使用软件定义无线电( Software Defined Radio – SDR )，软件无线电可以做很多神奇事情！！ SDR 是个什么东西？ “软件无线电”( Software Defined Radio – SDR )。实际上软件无线电技术的研究和开发已经有几十年的历史了，其中传统上以硬件实现的组件（例如混频器，滤波器，放大器，调制器\解调器，检测器等），通过个人计算机或嵌入式系统上的软件实现。最初源于美军的多制式电台项目，应用在军事领域。在 21 世纪初，由于众多公司的努力，使得它已从军事领域转向民用领域，成为经济的、应用广泛的、全球第三代移动通信系统的战略基础。到今天我们日常使用的移动通信系统中就在大量使用软件无线电技术， 比如基站中的信号处理大量的使用可编程的 FPGA 和 DSP 完成，比如手机当中的基带处理器也越来越多的采用软解调的方法(少数运算量特别大实时性要求特别高的模块除外，比如 turbo 解码器、扩频相关器等，这些模块往往在基带处理器中嵌入一些高度定制化”硬”核来实现)。 所以我们想要监听周围的无线电信号，自然是需要一个硬件的。 需要的硬件 RTL-SDR (或者 HackRF等) Raspberry Pi 3 (或者 Linux 系统的电脑) 有网络 高频天线 我选择的是一根支持 rtl-sdr 的电视棒，就是采用 RTL2832u (频率范围为 64-1700mh )解调芯片的。这是瑞晟( Realtek )的一个芯片型号，原本是做电视棒芯片的。后来被人发现这个芯片具有非常广的频率接收范围，然后就被用来做 sdr 应用了。十分廉价！ 安装 RTL_SDR 驱动程序硬件已经有了，接下来就是安装相关的软件驱动，才可以使用 打开一个 Terminal 窗口，进入到你的 home 目录下。先更新一下系统的软件，然后开始安装需要的软件依赖。具体操作如下：123456$ cd ~$ sudo apt-get update$ sudo apt-get install git$ sudo apt-get install cmake$ sudo apt-get install build-essential$ sudo apt-get install libusb-1.0-0-dev 相关的依赖软件安装完成后，接下来下载 RTL2832u Osmocom 的驱动源代码，进行编译安装123456789$ git clone git://git.osmocom.org/rtl-sdr.git$ cd rtl-sdr$ mkdir -p build$ cd build$ cmake ../ -DINSTALL_UDEV_RULES=ON$ make$ sudo make install$ sudo ldconfig$ sudo cp ../rtl-sdr.rules /etc/udev/rules.d 将使用电视棒作为电视设备自动加载的默认驱动程序列入黑名单，因为它不能让电视棒作为 SDR 使用，并且将会与我们刚刚安装的新 Osmocom 驱动程序发生冲突 以 administrator 权限打开 /etc/modprobe.d 文件夹 在该目录下创建一个叫 blacklist-rtl.conf 的新文件，打开文件，在文件中加入 blacklist dvb_usb_rtl28xxu 这条指令 保存文件，并重启 机器重启后，将电视棒插入 usb 接口，打开 Terminal 窗口，输入 rtl_test -t 命令，测试电视棒是否能够被正常驱动。不用担心 PLL 未锁定或未找到 E4000 调谐器或 R820T 而不是 R820T2 等消息。如果你看到跟上图一样的内容，那么说明你的驱动程序安装成功了，并且电视棒成功运行。 接着你就可以安装一些应用程序，来收听无线电信号。 安装 dump1090电视棒的 rtl_sdr 驱动程序安装好了之后，我们在安装一个 dump1090 应用程序，这样我们就可以接收飞机的信号。能很容易的捕获到飞机是飞机在飞行过程中要不断的报告自身的飞行状态(在 1090Mhz 频率进行广播)，这就是 ADS-B( 广播式自动相关监视系统) ，即一种航空交通监视系统，而且是使用全球性导航卫星系统、飞机xo的航电设备和地面基础设施， 能够在飞机和航管地面站 ( air-to-ground 即 aircraft to ATS ) 或是空对空 ( air-to-air 即 aircraft to aircraft )之间准确和迅速自动地传送飞行讯息； 其中包括有飞机的识别、位置、高度、速度和其他数据或信息。简单来说 ADS-B 是由飞机直接发出的数据包，让地面或其他飞机可以得知它的位置、高度、速度等信息。ADS-B 利用 112 个未加密的脉冲字在 978Mhz、1090Mhz 发射的信号。我们使用电视棒捕获这些信号，并通过 dump1090 将捕获到信号解析成飞机飞行的信息，生成地图。这样我们就能知道飞机的实时位置及其他信息。 打开一个新的 Terminal 窗口，安装 dump1090，并开启 dump1090 服务，然后我们就可以在 Terminal 窗口和浏览器中查看到飞行信息12345$ cd ~$ git clone git://github.com/tedsluis/dump1090.git$ cd dump1090$ make # 编译源码$ ./dump1090 --interactive --net --enable-agc # run dump1090 收到的飞机的飞行信息如下图，dump 在启动时会开启自带的 WEB 服务器，并且 WEB 调用了谷歌地图的 API 接收到飞机的一些信息后会在页面地图上描绘出飞机的轨迹(谷歌地图目前需要科学上网) 安装 GQRX 收听各频率的广播我们可以收听广播或者火腿(无线电爱好者)的呼叫。但是这里我在树莓派上没有安装成功。因为 GUN Radio 安装不成功的问题。不过我在 windows 上听到了广播。]]></content>
      <categories>
        <category>无线电</category>
      </categories>
      <tags>
        <tag>SDR</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 ARM Cortex-M3 的启动文件分析及分散加载]]></title>
    <url>%2F%2Fposts%2F%E5%85%B3%E4%BA%8E-ARM-Cortex-M3-%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD.html</url>
    <content type="text"><![CDATA[关于 ARM Cortex-M3 的启动文件分析及分散加载下面以 ARM Cortex-M3 裸核的启动代码为例，做一下简单的分析。首先，在启动文件中完成了三项工作： 堆栈以及堆的初始化 定位中断向量表 调用 Reset Handler 在介绍之前，我们先了解一下 ARM 芯片启动文件中涉及到的一些汇编指令的用法。 补充一下，其中 DCD 相当于 C 语言当中的 &amp;，定义地址。 堆栈以及堆的初始化堆栈的初始化 Stack_Size EQU 0x00000400这个语句相当于 Stack_Size 这个标号（标号：链接器的术语，下文中提到的所有“标号”，指的都是指的链接器中的标号）等于 0x00000400 相当于 C 语言中的 #define Stack_Size 0x00000400 ，也就是说此语句只是一个声明，并未分配地址。 1AREA STACK, NOINIT, READWRITE, ALIGN=3 此语句定义了一个叫 STACK 的代码段，并指明 8 字节对齐（ALIGN = 3）。其中 NOINIT 表示未初始化，READWRITE 表示可读可写，ALIGN = 3，即表示 2^3 = 8，八字节对齐。 1Stack_Mem SPACE Stack_Size 这里是为 Stack_Mem 分配 Stack_Size 大小的一块内存区域，注意这里分配的是 RAM ，即分配了大小为 1KB 的内存空间（0x00000400 = 1024）。 1__initial_sp 紧跟着栈分配内存后，所以其为栈顶（满递减栈）。此标号有一层隐含的意思就是在 M3 中堆栈是满递减堆栈，因为它指定了堆栈指针位于堆栈的高地址（在 Stack_Mem 之后），具体如下图所示。 上图来自 Cortex_M3 的一个工程的 xxx.map 文件。可以看出栈的起始地址为 0x20000c68，大小为 1024 字节（即 0x00000400 = Stack_Size）。而堆栈指针的位置在 0x20001068，其等于栈的起始地址 0x2000c68 + 0x00000400，说明本系列的 Cortex_M3 微控制器的堆栈为满递减堆栈。所以 __initial_sp 为 1KB 空间栈的栈顶，栈主要用于局部变量和形参的调用过程的临时存储，属于编译器自动分配和释放的内存，所以这里需要注意如果你的函数所占的内存过大，那么这个空间应调整其大小但一定要小于内部 SRAM 的大小。堆是程序员空间是程序员进行分配和释放的，如果程序中未释放最后由系统回收。 堆的初始化 堆的初始化过程与堆栈的初始化相同。 中断向量表的初始化 PRESERVE8 指定了以下的代码为 8 字节对齐，这是 keil 编译器的一个编程要求，对齐情况如下图所示： THUMB 指定了接下来的代码为 THUMB 指令集。 1AREA RESET, DATA, READONLY 此语句声明 RESET 数据段。1EXPORT __Vectors 导出向量表标号，EXPORT 作用类似于 C 语言中的 extern。之后的代码就是为向量表分配存储区域。中断向量表从 FLASH 的 0x00000000 地址开始放置，以 4 个字节为一个单位，地址 0 存放的是栈顶指针（ sp ）的地址，0x00000004 存放的是复位程序的地址，往后以此类推，这里我们只设置了一个 Reset_Handler 向量。从代码上看，向量表中存放的都是中断服务函数的函数名，可我们知道 C 语言中的函数名就是一个地址。（由此我们知道，中断函数的函数名都已经知道了，我们在写对应的中断服务程序时，从对应的地址取服务例程的入口地址并跳入执行）。但是此处有一个要注意的，就是 0 号地址不是什么入口地址，而是给出的复位后的 MSP 的初值。 调用 Reset Handler 此段代码只完成了一个功能，引导程序进入 main 。 main 的具体行为在后面做具体描述。PROC 与 ENDP 两个关键字组合在汇编中定义了一段子函数。用户堆栈的初始化 这一部分也就是把初始化的堆栈地址赋值给单片机的对应寄存器以方便 C 程序进行分配释放使用。 其他代码有一些芯片厂商对芯片的加密的加密级别的代码也会放在这里，芯片上电后会自动读取这一地址的值以确定芯片的加密方式。 ARM 芯片的启动过程详解接下来介绍 main 函数的具体实现过程。首先在介绍 main 函数之前，我们先了解一些关于 ARM 芯片在启动过程中的基本知识。“ ARM 程序”是指在 ARM 系统中正在执行的程序，而非保存在 ROM 中的 .bin(.axf,.hex)映像（ image ）文件。一个 ARM 程序包含 3 部分：RO ，RW 和 ZI RO 就是只读数据，是程序中指令和常量； RW 是可读写的数据，程序中已初始化变量； ZI 是程序中未初始化的变量和初始化为 0 的变量。简单理解就是： RO 就是 readonly ，RW 就是 read/write，ZI 就是 zero initial。 注意，以上的过程并非绝对的，不同的 ARM 架构或者是不同的代码以上的执行过程是不同的。复位处理程序是在汇编器中编写的短模块，系统一启动就立即执行。复位处理程序最少要为应用程序的运行模式初始化堆栈指针。对于具有本地内存系统（如缓存、TCM 、MMU 和 MPU）的处理器，某些配置必须在初始化过程的这一阶段完成。复位处理程序在执行之后，通常跳到 main 以开始 C 库初始化序列。 main 中的 scatterload 负责设置内存，而 rt_entry 负责设置运行时的环境。scatterload 中负责把 RO/RW （非零）输出段从装载域地址复制到运行域地址（执行代码和数据复制、解压缩），并完成 ZI 段运行域数据的 0 初始化工作。然后跳到 rt_entry 设置堆栈和堆、初始化库函数和静态数据。然后，rt_entry 跳转到应用程序的入口 main() 。主应用程序结束执行后，rt_entry 将库关闭，然后把控制权交换给调试器。函数标签 main() 具有特殊含义。Main() 函数的存在强制链接器链接到 main 和 rt_entry 中的代码。如果没有标记为 main() 的函数，则没有链接到初始化序列，因而部分标准 C 库功能得不到支持。 结合代码来看芯片启动过程上电后硬件设置 sp 、pc ，刚上电复位后，硬件会自动根据向量表地址找到向量表。 在离开复位状态后， CM3 做的第一件事就是读取下列两个 32 位整数的值： 1.从地址 0x0000 0000 处取出 MSP 的初始值。 2.从地址 0x0000 0004 处取出 PC 的初始值，这个值是复位向量， LSB 必须是 1 。 然后从这个值所对应的地址处取指。硬件自动从 0x0000 0000 位置处读取数据赋给栈指针 sp，然后从 0x0000 0004 位置处读取数据赋给 pc 指针，完成复位，结果为：12SP = 0x2000 1068 PC = 0x0000 011D 这与传统的 ARM 架构不同——其实也和绝大多数的其它单片机不同。传统的 ARM 架构总是从 0 地址开始执行第一条指令。它们的 0 地址处总是一条跳转指令。在 CM3 中，在 0 地址处提供 MSP 的初始值，然后紧跟着就是向量表。向量表中的数值是 32 位的地址，而不是跳转指令。向量表的第一个条目指向复位后应执行的第一条指令，就是我们上面分析的 Reset_Handler 这个函数。 进入__main12LDR R0, =__mainBX R0 执行上两条指令，跳转到 main 程序段运行，main 的地址是 0x0000 0080 ，上一步指令 pc = 0x0000 011D 的地址没有对齐，硬件自动对齐到 0x0000 011C，执行 __main。 pc 指针通过立即数寻址，跳转到 0x0000 0081 处执行，同上这里也会自动对齐到 0x0000 0080 处。 在 scatterload 函数中又会进入 scatterload_copy ，在 __scatterload_copy 中进行代码搬运，主要是加载已经初始化的数据段和未初始化的数据段，同时还会初始化栈空间，即 ZI 段清零（其中搬运次数由代码中声明的变量类型和变量多少来决定）。 然后会跳转到 rt_entry 函数执行，rt_entry 是使用 ARM C 库的程序的起点。将所有分散加载区重新定位到其执行地址后，会将控制权传递给 rt_entry 。如下图，在 rt_entry 中主要实现如下几个功能： 1.设置用户的堆和堆栈 2.调用 __rt_lib_init 以初始化 C 库 3.调用 main() 4.调用 __rt_lib_shutdown 以关闭 C 库 5.退出 rt_lib_init 函数是库函数初始化函数，它与 rt_lib_shutdown 配合使用。并且这个函数紧靠 __rt_stackheap_init() 后面调用，即紧跟堆和堆栈初始化后面调用，并且传递一个要用作堆的初始内存块。此函数是标准ARM库初始化函数，不能重新实现此函数。 注意：最后两步是在程序退出 main() 函数的时候才会执行，而我们嵌入式程序一般都是死循环，所以基本上不会执行这两个过程。还有以上过程是针对使用标准 C Library 而言的，不包括使用 MDK 提供的 microlib 库的情况。 在 rt_entry_main 中，用户程序就开始正式执行了（进入 C 的世界）。在此之前初始化 MSP 是必需的，因为可能第 1 条指令还没来得及执行，就发生了 NMI 或是其它 fault。 MSP 初始化好后就已经为它们的服务例程准备好了堆栈。这也就是 main 中做的事情。 最后关于 microlib 库Microlib 是缺省 C 库的备选库。它旨在与需要装入到极少量内存中的深层嵌入式应用程序配合使用。这些应用程序不在操作系统中运行，因此 microlib 进行了高度优化以使代码变得很小，当然它的功能相比缺省 C 库少，并且根本不具备某些 ISO C 特性。某些库函数的运行速度也比较慢，比如 memcpy()。 Microlib与缺省C库之间的主要差异是： Microlib 不符合 ISO C 库标准。不支持，某些 ISO 特性，并且其他特性具有的功能也比较少；Microlib 不符合 IEEE754 二进制浮点算法标准；Microlib 进行了高度优化以使代码变得很小；无法对区域设置进行配置。缺省 C 区域设置是唯一可用的区域设置；不能将 main() 声明为使用参数，并且不能返回内容；不支持 stdio ，但未缓冲的 stdin、stdout 和 stderr 除外；Microlib 对 C99 函数提供有限的支持；Microlib 不支持操作系统函数；Microlib 不支持与位置无关的代码；Microlib 不提供互斥锁来防止非线程安全的代码；Microlib 不支持宽字符或多字节字符串；与stdlib 不同， microlib 不支持可选的单或双区内存模型。 Microlib 只提供双区内存模型，即单独的堆栈和堆区。 关于生成的 xxx.map 文件想要更好的了解启动代码的运行机制，我们就有必要了解一下由 Keil 的链接器“ armlink ”生成的描述文件，即 xxx.map 文件。 上图即是 armlink 的链接器为测试代码生成的 xxx.map 文件中的一部分，其描述了镜像文件的组成信息，其中可以明显看到其由两部分构成： User Code 生成的目标文件 C Library 生成的目标文件 可见我们在上文中所描述的启动过程中看到的 main 、 rt_entry 、 scartterload 以及 rt_lib_init 等，就是 C library 中的代码。所以，我们每次烧录的可执行的 ARM 的 bin 文件中不仅有开发者编写的代码，还有 C Library 的代码。 上图为存放在RAM中的RW段。 关于分散加载基本概念由于 ARM Cortex-M3 系列是哈佛架构，哈佛架构是一种将程序指令存储和数据存储分开的存储器结构，所以它在运行时，指令存储在片内的 flash 上，数据存储在片内 SRAM 中。因此程序是可以直接在 flash 上运行的，而不是先将 flash 上的程序全部搬运到 RAM 在运行。由此，我们也可以深入了解一下 ARM 映像（镜像）文件。 ARM 映像文件其实就是源文件经编译器生成的目标文件 .obj（object file）和相应的 C/C++ 运行时库（ Runtime Library ）经过连接器的处理后，生成的 axf 格式的映像文件，它可以直接烧录到目标设备的 ROM 中直接运行或加载后运行。 映像文件的类型常见的映像文件还包括 bin 、 hex 和 elf 文件，在 keil 调试过程中，调试器生成 axf 文件也是一种映像文件。Bin 文件是纯粹的二进制机器代码，或者说是“顺序格式”。按照汇编代码顺序翻译成的二进制机器码，内部没有地址标记。 Bin 文件是直接的内存映像表示，二进制文件大小即为文件所包含的数据的实际大小。Hex 文件是 Intel 标准的十六进制文件，通常用来保存单片机或其他处理器的目标程序代码。它保存物理程序存储区中的目标代码映像。一般的编程器都支持这种格式。就是机器代码的十六进制形式，并且是用一定文件格式的 ASCII 码来表示。在 Hex 文件里面，每一行代表一个记录。每条记录都由一个冒号“：”打头，其格式如下： :BBAAAATTHHHH…HHHHCC BB:字节个数。AAAA:数据记录的开始地址,高位在前,低位在后。TT: Type00 数据记录，用来记录数据。01 记录结束，放在文件末尾，用来标识文件结束。02 用来标识扩展段地址的记录04 扩展地址记录(表示 32 位地址的前缀)HHHH:一个字( Word )的数据记录,高字节在前,低字节在后。TT 之后共有 BB/2 个字的数据 。CC: 占据一个 Byte 的 CheckSum ELF（ Executableand linking format ）文件是 x86 Linux 系统下的一种常用目标文件( objectfile )格式，有三种主要类型: (1)适于连接的可重定位文件( relocatablefile )，可与其它目标文件一起创建可执行文件和共享目标文件。(2)适于执行的可执行文件( executable file )，用于提供程序的进程映像，加载到内存执行。(3)共享目标文件( shared object file )，连接器可将它与其它可重定位文件和共享目标文件连接成其它的目标文件，动态连接器又可将它与可执行文件和其它共享目标文件结合起来创建一个进程映像。Axf 文件由 ARM 编译器产生，除了包含 bin 的内容之外，还附加其他调试信息，这些调试信息加在可执行的二进制数据之前。调试时这些调试信息不会下载到 RAM 中，真正下载到 RAM 中的信息仅仅是可执行代码。因此，如果 ram 的大小小于 axf 文件的大小，程序是完全有可能在 ram 中调试的，只要 axf 除去调试信息后文件大小小于 ram 的大小即可。 总结： （1） axf 和 elf 都是编译器生成的可执行文件。区别是：ADS 编译出来的是 AXF 文件。gcc 编译出来的是 ELF 文件。两者虽然很像，但还是有差别的。这是文件格式的差别，不涉及调试格式。 （2）axf/elf 是带格式的映象，bin 是直接的内存映象的表示。 （3）Linux OS 下，ELF 通常就是可执行文件，通常 gcc -o test test.c，生成的 test 文件就是 ELF 格式的，在 Linux Shell 下输入 ./test 就可以执行。在 Embedded 中，上电开始运行，没有 OS 系统，如果将 ELF 格式的文件烧写进去，包含一些 ELF 格式的东西，arm 运行碰到这些指令，就会导致失败，如果用 bin 文件，程序就可以一步一步运行。所以最终放进 flash 的是 bin 文件。 elf 文件可转化为 hex 和 bin 两种文件， hex 也可以直接转换为 bin 文件，但是 bin 要转化为 hex 文件必须要给定一个基地址。而 hex 和 bin 不能转化为 elf 文件，因为 elf 的信息量要大。 Axf 文件可以转化为 bin 文件，KEIL 下可用以下命令 fromelf -nodebug xx.axf -bin xx.bin 即可。 映像文件的组成镜像文件组成如下图所示： 可执行文件由映像、区（域）、输出节（段）和输入节（段）的层次结构构成： 映像由一个或多个区组成。每个区由一个或多个输出节组成。每个输出节包含一个或多个输入节。输入节是对象文件中的代码和数据信息。输入节：输入节包含代码、初始化数据，或描述未初始化的或在映像执行之前必须设定为 0 的内存片段。这些特性通过 RO 、 RW 和 ZI 这样的属性来表示。输出节：一个输出节由若干个具有相同 RO 、 RW 或 ZI 属性的相邻输入节组成。输出节的属性与组成它的输入节的属性相同 。区：一个区由一个、两个或者三个相邻的输出节组成。区中的输出节根据其属性排序。首先是 RO 输出节，然后是 RW 输出节，最后是 ZI 输出节。区通常映射到物理内存设备，如 ROM 、 RAM 或外围设备。 有时候用户希望将不同代码放在不同存储空间，也就是通过编译器生成的映像文件需要包含多个域，每个域在加载和运行时可以有不同的地址。要生成这样的映像文件，必须通过某种方式告知编译器相关的地址映射关系。在 Keil/ADS/IAR 等编译工具中，可通过分散加载机制实现。分散加载通过配置文件实现，这样的文件就称为分散加载文件。分散加载( scatter loading )为 *.scf 文件。它提供这样一种机制：可以将内存变量定位于不同的物理地址上的存储器或端口，通过访问内存变量即可达到访问外部存储器或外设的目的；同时通过分散加载，让大多数程序代码在高速的内部 RAM 中运行，从而使得系统的实时性大大增强。这样，定位在 RAM 存储器的代码和数据就在 RAM 存储器中运行，而不再从 ROM 存储器中取数据或取指令，从而大大提高了 CPU 的运行速率和效率。编译过程加载过程 ROM（Flash）size = Code + RO_Data + RW_Data = 0.5kb；RAM size = RW_Data + ZI_Data = 4.1kb。 加载时域的描述sct 文件 LR_IROM1 加载区域名，用于“ Linker ”区别不同的加载区域，最多 31 个字符；用来保存永久性数据（程序和只读变量）的区域；ER_IROM1 执行区域名；程序执行时，从加载区域将数据复制到相应执行区后才能被正确执行； 例如：12345678910LR_IROM1 0x00000000 0x00040000 &#123; ; load region size_region ER_IROM1 0x00000000 0x00010000 &#123; ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) &#125; RW_IRAM1 0x20010000 0x00010000 &#123; ; RW data .ANY (+RW +ZI) &#125;&#125; LR_IROM1 0x00000000 0x00040000定义一个加载时域，域基址：0x00000000，域大小为 0x00040000，对应实际 Flash 的大小ER_IROM1 0x00000000 0x00010000定义一个运行时域，第一个运行时域必须和加载时域起始地址相同，否则库不能加载到该时域的错误，其域大小一般也和加载时域大小相同，但是我们这里没有 flash ，只有 128k 的 RAM ，这里分配 64k 作为程序存储器，所以这里是 0x00010000 大小。 *.o (RESET, +First)将 RESET 段最先加载到本域的起始地址外，即 RESET 的起始地址为 0，RESET 存储的是向量表 .ANY (+RO)加载所有匹配目标文件的只读属性数据，包含：RW-Code、RO-Data。 RW_IRAM1 0x20010000 0x00010000定义一个运行时域，域基址：0x20010000，域大小为 0x00010000 ，对应实际 RAM 大小，这时就不能从 0x20000000 开始了，因为实际 RAM 中前 64K 已经用于程序存储了，所以运行段向后偏移 0x00010000 大小，起始地址从 0x20010000 开始。之前就是因为这里的内存分配不对，地址从 0x20000000 开始，结果程序在搬运初始化过程中，把自己清零了，导致代码在进入 mian() 函数以后就跑飞了。 (+RW +ZI)加载所有区配目标文件的 RW-Data、ZI-Data 这里也可以用 .ANY 替代 * 号 下图为 STM32 的 sct 文件： 下面为 OnSemiconductor RSL10 芯片的 sct 文件，编译环境为 eclipse 加 armlink。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152SECTIONS 0x00100000&#123; ; For Cortex-M devices, the beginning of the startup code is stored in ; the .interrupt_vector section, which goes to FLASH. All other code ; follows this section.;对于 Cortex-M 设备，启动代码的开头存储在 .interrupt_vector 部分，该部分转到 FLASH 。 所有其他代码都在本节后面。 FLASH 0x00100000 0x60000 &#123;; Flash 起始地址为 0x00100000 大小为 0x60000 384k * (RESET +FIRST) ; Remaining program code; 只读代码部分 * (+RO) ; All remaining DSP code ; DSP 代码 * (.dsp, .dsp.*) &#125;; Define the data sections; 定义运行域 DRAM 0x20000000 (0x6000 - 2048) &#123;; DRAM 起始地址 0x20000000 大小 0x6000 大约 24k ; Place the system clock variable first; 首先放置系统时钟变量 * (.systemclock +FIRST) ; Place the defined data sections; 放置已定义的数据部分 * (.data_begin, .data_begin.*) * (.data, .data.*) * (.data_end, .data_end.*) ; Place all remaining read-write and zero-initialized data ; 放置所有剩余的读写和零初始化数据 * (+RW) * (+ZI) &#125;; Define a heap region; 定义堆区域 起始地址 0x20005800 大小 0x400 1k ARM_LIB_HEAP 0x20005800 EMPTY 0x400 &#123; &#125;; Define a stack region; 定义栈区域 起始地址 0x20005C00 大小 0x400 1k ARM_LIB_STACK 0x20005C00 EMPTY 0x400 &#123; &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>CM3</tag>
        <tag>启动文件</tag>
        <tag>分散加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[make 命令及 makefile 文件编写]]></title>
    <url>%2F%2Fposts%2Fmake-%E5%91%BD%E4%BB%A4%E5%8F%8A-makefile-%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99.html</url>
    <content type="text"><![CDATA[前言前段时间因为工作需要简单学习了一下 make 命令以及 makefile 文件的编写，这里整理一篇在网上看到的比较简洁明了的教程。 代码变成可执行文件，叫做 编译（ compile ）；先编译这个，还是先编译那个（即编译的安排），叫做 构建（ build ）。 Make 是最常用的构建工具，诞生于 1977 年，主要用于 C 语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用 Make 构建。 本文介绍 Make 命令的用法，从简单的讲起，不需要任何基础，只要会使用命令行，就能看懂。我的参考资料主要是 Isaac Schlueter 的《 Makefile 文件教程》和《 GNU Make 手册》。 来源： http://www.ruanyifeng.com/blog/2015/02/make.html作者： 阮一峰 Make 的概念Make 这个词，英语的意思是”制作”。Make 命令直接用了这个意思，就是要做出某个文件。比如，要做出文件 test.txt ，就可以执行下面的命令。1$ make test.txt 但是，如果你真的输入这条命令，它并不会起作用。因为 Make 命令本身并不知道，如何做出 test.txt ，需要有人告诉它，如何调用其他命令完成这个目标。 比如，假设文件 test.txt 依赖于 a.txt 和 b.txt ，是后面两个文件连接（ cat 命令）的产物。那么， make 需要知道下面的规则。12test.txt: a.txt b.txt cat a.txt b.txt &gt; test.txt 也就是说， make test.txt 这条命令的背后，实际上分成两步：第一步，确认 a.txt 和 b.txt 必须已经存在，第二步使用 cat 命令 将这个两个文件合并，输出为新文件。 像这样的规则，都写在一个叫做 Makefile 的文件中， Make 命令依赖这个文件进行构建。 Makefile 文件也可以写为 makefile ， 或者用命令行参数指定为其他文件名。123$ make -f rules.txt# 或者$ make --file=rules.txt 上面代码指定 make 命令依据 rules.txt 文件中的规则，进行构建。 总之， make 只是一个根据指定的 Shell 命令进行构建的工具。它的规则很简单，你规定要构建哪个文件、它依赖哪些源文件，当那些文件有变动时，如何重新构建它。 Makefile 文件格式构建规则都写在 Makefile 文件里面，要学会如何 Make 命令，就必须学会如何编写 Makefile 文件。 Makefile 概述Makefile 文件由一系列规则（ rules ）构成。每条规则的形式如下：12&lt;target&gt;: &lt;prerequisites&gt;[tab] &lt;commands&gt; 上面第一行冒号前面的部分，叫做“目标”（ target ），冒号后面的部分叫做“前置条件”（ prerequisites ）；第二行必须由一个 tab 键起首，后面跟着“命令”（ commands ）。 “目标”是必需的，不可省略；“前置条件”和“命令”都是可选的，但是两者之中必须至少存在一个。 每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。 目标（target）一个目标（ target ）就构成一条规则。目标通常是文件名，指明 Make 命令所要构建的对象，比如上文的 test.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。 除了文件名，目标还可以是某个操作的名字，这称为“伪目标”（ phony target ）。12clean: rm *.o 上面代码的目标是 clean ，它不是文件名，而是一个操作的名字，属于“伪目标”，作用是删除对象文件。1$ make clean 但是，如果当前目录中，正好有一个文件叫做 clean ，那么这个命令不会执行。因为 Make 发现 clean 文件已经存在，就认为没有必要重新构建了，就不会执行指定的 rm 命令。 为了避免这种情况，可以明确声明 clean 是“伪目标”，写法如下:123.PHONY:cleanclean: rm *.o temp 声明 clean 是“伪目标”之后， make 就不会去检查是否存在一个叫做 clean 的文件，而是每次运行都执行对应的命令。像 .PHONY 这样的内置目标名还有不少，可以查看手册。 如果 Make 命令运行时没有指定目标，默认会执行 Makefile 文件的第一个目标。1$ make 上面代码执行 Makefile 文件的第一个目标。 前置条件（ prerequisites )前置条件通常是一组文件名，之间用空格分隔。它指定了“目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的 last-modification 时间戳比目标的时间戳新），“目标”就需要重新构建。12result.txt: source.txt cp source.txt result.txt 上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中， source.txt 已经存在，那么 make result.txt 可以正常运行，否则必须再写一条规则，来生成 source.txt 。12source.txt echo &quot;this is the source&quot; &gt; source.txt 上面代码中， source.txt 后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用 make source.txt ，它都会生成。12$ make result.txt$ make result.txt 上面命令连续执行两次 make result.txt 。第一次执行会先新建 source.txt ，然后再新建 result.txt 。第二次执行， Make 发现 source.txt 没有变动（时间戳晚于 result.txt ），就不会执行任何操作， result.txt 也不会重新生成。 如果需要生成多个文件，往往采用下面的写法:1source: file1 file2 file3 上面代码中， source 是一个伪目标，只有三个前置文件，没有任何对应的命令。1$ make source 执行 make source 命令后，就会一次性生成 file1 ， file2 ， file3 三个文件。这比下面的写法要方便很多:123$ make file1$ make file2$ make file3 命令（ commands ）命令（ commands ）表示如何更新目标文件，由一行或多行的 Shell 命令组成。它是构建“目标”的具体指令，它的运行结果通常就是生成目标文件。 每行命令之前必须有一个 tab 键。如果想用其他键，可以用内置变量 .RECIPEPREFIX 声明。123.RECTPEPREFIX = &gt;all:&gt; echo Hello, world 上面代码用 .RECIPEPREFIX 指定，大于号（ &gt; ）替代 tab 键。所以，每一行命令的起首变成了大于号，而不是 tab 键。 需要注意的是，每行命令在一个单独的 shell 中执行。这些 Shell 之间没有继承关系。123var-lost: export foo=bar echo &quot;foo=[$$foo]&quot; 上面代码执行后（make var-lost），取不到 foo 的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。12var-kept: export foo=bar; echo &quot;foo=[$$foo]&quot; 另一个解决办法是在换行符前加反斜杠转义。123var-kept: export foo=bar; \ echo &quot;foo=[$$foo]&quot; 最后一个方法是加上 .ONESHELL:命令。1234.ONESHELL:var-kept: export foo=bar; echo &quot;foo=[$$foo]&quot; Makefile 文件语法注释井号（#）在 Makefile 中表示注释。1234# 这是注释result.txt: source.txt # 这是注释 cp source.txt result.txt # 这是注释 回声（ echoing ）正常情况下，make 会打印每条命令，然后再执行，这就叫做回声（echoing）。12test: # 这是测试 执行上面的规则，会得到下面的结果。12$ make test# 这是测试 在命令的前面加上 @ ，就可以关闭回声。12test: @# 这是测试 现在再执行 make test，就不会有任何输出。 由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的 echo 命令前面加上 @ 。123test: @# 这是测试 @echo TODO 通配符通配符（ wildcard ）用来指定一组符合条件的文件名。 Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 [...] 。比如， *.o 表示所有后缀名为 .o 的文件。12clean: rm -f *.o 模式匹配Make 命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是 %。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。1%.o: %.c 等同于下面的写法。12f1.o: f1.cf2.o: f2.c 使用通配符 %，可以将大量同类型的文件，只用一条规则就完成构建。 变量和赋值符Makefile 允许使用等号自定义变量。123txt = Hello Worldtest: @echo $(txt) 上面代码中，变量 txt 等于 Hello World 。调用时，变量需要放在 $( ) 之中。 调用 Shell 变量，需要在美元符号前，再加一个美元符号，这是因为 Make 命令会对美元符号转义。12test: @echo $$HOME 有时，变量的值可能指向另一个变量。1v1 = $(v2) 上面代码中，变量 v1 的值是另一个变量 v2 。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。 为了解决类似问题， Makefile 一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看 StackOverflow 。1234567891011VARIABLE = value# 在执行时扩展，允许递归扩展。VARIABLE := value# 在定义时扩展。VARIABLE ?= value# 只有在该变量为空时才设置值。VARIABLE += value# 将值追加到变量的尾端。 内置变量（Implicit Variables）Make 命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的 Make 工具。这主要是为了跨平台的兼容性，详细的内置变量清单见手册。12output: $(CC) -o output input.c 自动变量（Automatic Variables）Make 命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。(1) $@$@ 指代当前目标，就是 Make 命令当前构建的那个目标。 比如，make foo的 $@ 就指代 foo。12a.txt b.txt: touch $@ 等同于下面的写法。1234a.txt: touch a.txtb.txt: touch b.txt (2) $&lt;$&lt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么 $&lt; 就指代 p1。12a.txt: b.txt c.txt cp $&lt; $@ 等同于下面的写法。12a.txt: b.txt c.txt cp b.txt a.txt (3) $?$? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$? 就指代 p2 。(4) $^$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。(5) $* $ 指代匹配符 % 匹配的部分， 比如 % 匹配 f1.txt 中的 f1 ，$\ 就表示 f1。(6) $(@D) 和 $(@F)$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@ 是 src/input.c，那么 $(@D) 的值为 src ，$(@F) 的值为 input.c。(7) $(&lt;D) 和 $(&lt;F)$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。 所有的自动变量清单，请看手册。下面是自动变量的一个例子。123dest/%.txt: src/%.txt @[ -d dest ] || mkdir dest cp $&lt; $@ 上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&lt; 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。 判断和循环Makefile 使用 Bash 语法，完成判断和循环。12345ifeq ($(CC),gcc) libs=$(libs_for_gcc)else libs=$(normal_libs)endif 上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。123456789101112LIST = one two threeall: for i in $(LIST); do \ echo $$i; \ done# 等同于all: for i in one two three; do \ echo $i; \ done 上面代码的运行结果:123onetwothree 函数Makefile 还可以使用函数，格式如下：123$(function arguments)# 或者$&#123;function arguments&#125; Makefile 提供了许多内置函数，可供调用。下面是几个常用的内置函数。(1) shell 函数shell 函数用来执行 shell 命令1srcfiles := $(shell echo src/&#123;00..99&#125;.txt) (2) wildcard 函数wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。1srcfiles := $(wildcard src/*.txt) (3) subst 函数subst 函数用来文本替换，格式如下:1$(subst from,to,text) 下面的例子将字符串”feet on the street”替换成”fEEt on the strEEt”。1$(subst ee,EE,feet on the street) 下面是一个稍微复杂的例子。1234567comma:= ,empty:=# space 变量用两个空变量作为标识符，当中是一个空格space:= $(empty) $(empty)foo:= a b cbar:= $(subst $(space),$(comma),$(foo))# bar is now 'a,b,c'. (4) patsubst 函数patsubst 函数用于模式匹配的替换，格式如下。1$(patsubst pattern,replacement,text) 下面的例子将文件名 “x.c.c bar.c”，替换成 “x.c.o bar.o”。1$(patsubst %.c,%.o,x.c.c bar.c) (5) 替换后缀名替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上 patsubst 函数的一种简写形式。1min: $(OUTPUT:.js=.min.js) 上面代码的意思是，将变量 OUTPUT 中的后缀名 .js 全部替换成 .min.js 。 Makefile 实例(1) 执行多目标编译12345678910.PHONY: cleanall cleanobj cleandiffcleanall : cleanobj cleandiff rm programcleanobj : rm *.ocleandiff : rm *.diff 上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（ cleanall ），删除所有指定类型的文件。(2) 编译 C 语言项目12345678910111213141516edit : main.o kbd.o command.o display.o cc -o edit main.o kbd.o command.o display.omain.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h cc -c display.cclean : rm edit main.o kbd.o command.o display.o.PHONY: edit clean Make 命令和Makefile文件的介绍就到这里。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>make</tag>
        <tag>makefile</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS 基础知识]]></title>
    <url>%2F%2Fposts%2FROS-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[ROS 基础知识上一篇，我们已经正确的安装好了 ROS ，但是在使用 ROS 进行机器人开发工作之前，我们先来了解一点 ROS 的基础知识，以便于后面的开发使用。当然我这里自然是没有 ROS wiki 上介绍的详细，要想学习更多的操作请先看 ROS wiki 上的入门教程这里我只简单介绍一下，在我的项目中会用到的一些操作。 创建工作空间ROS 使用一个名为 catkin 的 ROS 专用构建系统。为了使用它，用户需要创建并初始化 catkin 工作空间，如下所示。除非用户创建新的工作空间，否则此设置只需设置一次。工作空间（ workspace ）简单来说就是一个存放工程开发相关文件的文件夹。主要目录结构如下： src: 代码空间 ( source space ) build: 编译空间 ( build space ) devel: 开发空间 ( development space ) install: 安装空间 ( install space ) 创建工作空间123$ mkdir -p ~/catkin_ws/src # 创建工作空间机源码空间$ cd ~/catkin_ws/src$ catkin_init_workspace # 初始化工作空间 编译工作空间目前，只有 src 目录和 CMakeLists.txt 文件(运行初始化命令后就会生成)在 catkin 工作目录中，即使 src 目录中没有源代码，我们仍然可以使用 catkin_make 命令来进行构建。12$ cd ~/catkin_ws/$ catkin_make 如果构建没有问题，运行 ls 命令。除了自己创建的 src 目录之外，还出现了一个新的 build 和 devel 目录。 catkin 的构建系统的相关文件保存在 build 目录中，构建后的可执行文件保存在 devel 目录中。 设置环境变量1$ source ~/catkin_ws/devel/setup.bash 检查环境变量12$ echo $ROS_PACKAGE_PATH/home/ubuntu/catkin_ws/src:/opt/ros/kinetic/share:/opt/ros/kinetic/stacks 创建功能包一个功能包它是是构成 ROS 的基本单元。 ROS 应用程序是以功能包为单位开发的。功能包包括至少一个以上的节点或拥有用于运行其他功能包的节点的配置文件。它还包含功能包所需的所有文件，如用于运行各种进程的 ROS 依赖库、数据集和配置文件等。 创建功能包123$ cd ~/catkin_ws/src# 创建功能包命令格式如下：$ catkin_create_pkg [功能包名称] [依赖功能包 1] [依赖功能包 n] 「catkin_create_pkg」命令在创建用户功能包时会生成 catkin 构建系统所需的 CMakeLists.txt 和 package.xml 文件的包目录。注：同一个工作空间下，不允许存在同名功能包；在不同工作空间下，允许存在同名功能包。 编译功能包12$ cd ~/catkin_ws$ catkin_make ROS 通信为了最大化用户的可重用性，ROS 是以节点的形式开发的，而节点是根据其目的细分的可执行程序的最小单位。节点则通过消息（ message ）与其他的节点交换数据，最终成为一个大型的程序。这里的关键概念是节点之间的消息通信，它分为三种。单向消息发送/接收方式的话题（ topic ）；双向消息请求/响应方式的服务（ service ）；双向消息目标（ goal ）/结果（ result ）/反馈（ feedback ）方式的动作（ action ）。另外，节点中使用的参数可以从外部进行修改。这在大的框架中也可以被看作消息通信。如下图所示： 种类 区别 方向 响应 话题 异步 单向 连续单向地发送/接收数据的情况 服务 同步 双向 需要对请求给出即时响应的情况 动作 异步 双向 请求与响应之间需要太长的时间，所以难以使用服务的情况，或需要中途反馈值的情况 话题通信话题消息通信是指发送信息的发布者和接收信息的订阅者以话题消息的形式发送和接收信息。希望接收话题的订阅者节点接收的是与在主节点中注册的话题名称对应的发布者节点的信息。基于这个信息，订阅者节点直接连接到发布者节点来发送和接收消息。另外，单个发布者可以与多个订阅者进行通信，相反，一个订阅者可以在单个话题上与多个发布者进行通信。当然，这两家发布者都可以和多个订阅者进行通信。 服务通信服务消息通信是指请求服务的服务客户端与负责服务响应的服务服务器之间的同步双向服务消息通信。前述的发布和订阅概念的话题通信方法是一种异步方法，是根据需要传输和接收给定数据的一种非常好的方法。然而，在某些情况下，需要一种同时使用请求和响应的同步消息交换方案。因此，ROS 提供叫做服务的消息同步方法。一个服务被分成服务服务器和服务客户端，其中服务服务器只在有请求（ request ）的时候才响应（response），而服务客户端会在发送请求后接收响应。与话题不同，服务是一次性消息通信。因此，当服务的请求和响应完成时，两个连接的节点将被断开。该服务通常被用作请求机器人执行特定操作时使用的命令，或者用于根据特定条件需要产生事件的节点。由于它是一次性的通信方式，又因为它在网络上的负载很小，所以它也被用作代替话题的手段，因此是一种非常有用的通信手段。 动作通信动作消息通信是在如下情况使用的消息通信方式：服务器收到请求后直到响应所需的时间较长，且需要中途反馈值。这与服务非常相似，服务具有与请求和响应分别对应的目标（ goal ）和结果（ result ）。除此之外动作中还多了反馈（ feedback ）。收到请求后需要很长时间才能响应，又需要中间值时，使用这个反馈发送相关的数据。消息传输方案本身与异步方式的话题（ topic ）相同。反馈在动作客户端（ action client ）和动作服务器（ action server ）之间执行异步双向消息通信，其中动作客户端设置动作目标（ goal ），而动作服务器根据目标执行指定的工作，并将动作反馈和动作结果发送给动作客户端。 消息通信过程主节点管理节点信息，每个节点根据需要与其他节点进行连接和消息通信。以话题消息为例，具体通信步骤如下。 运行主节点节点之间的消息通信当中，管理连接信息的主节点是为使用 ROS 必须首先运行的必需元素。ROS 主节点使用 roscore 命令来运行，并使用 XMLRPC 运行服务器。主节点为了节点与节点的连接，会注册节点的名称、话题、服务、动作名称、消息类型、URI 地址和端口，并在有请求时将此信息通知给其他节点。运行 roscore 命令就启动了主节点。 运行订阅者节点订阅者节点使用 rosrun 或 roslaunch 命令来运行。订阅者节点在运行时向主节点注册其订阅者节点名称、话题名称、消息类型、URI 地址和端口。主节点和节点使用 XMLRPC 进行通信。12$ rosrun PACKAGE_NAME NODE_NAME$ roslaunch PACKAGE_NAME LAUNCH_NAME 运行发布者节点发布者节点（与订阅者节点类似）使用 rosrun 或 roslaunch 命令来运行。发布者节点向主节点注册发布者节点名称、话题名称、消息类型、 URI 地址和端口。主节点和节点使用 XMLRPC 进行通信。 通知发布者信息主节点向订阅者节点发送此订阅者希望访问的发布者的名称、话题名称、消息类型、 URI 地址和端口等信息。主节点和节点使用 XMLRPC 进行通信。 订阅者节点的连接请求订阅者节点根据从主节点接收的发布者信息，向发布者节点请求直接连接。在这种情况下，要发送的信息包括订阅者节点名称、话题名称和消息类型。发布者节点和订阅者节点使用 XMLRPC 进行通信。 发布者节点的连接响应发布者节点将 TCP 服务器的 URI 地址和端口作为连接响应发送给订阅者节点。发布者节点和订阅者节点使用 XMLRPC 进行通信。 TCPROS 连接订阅者节点使用 TCPROS 创建一个与发布者节点对应的客户端，并直接与发布者节点连接。节点间通信使用一种称为 TCPROS 的 TCP/IP 方式。 发送消息发布者节点向订阅者节点发送消息。节点间通信使用一种称为 TCPROS 的 TCP/IP 方式。服务消息，服务服务器和客户端之间的连接与上述发布者和订阅者之间的 TCPROS 连接相同，但是与话题不同，服务只连接一次，在执行请求和响应之后彼此断开连接。如果有必要，需要重新连接。动作消息，动作（ action ）在执行的方式上好像是在服务（ service ）的请求（ goal ）和响应( result ）之间仅仅多了中途反馈环节，但实际的运作方式与话题相同。事实上，如果使用 rostopic 命令来查阅话题，那么可以看到该动作的 goal、status、cancel、result 和 feedback 等五个话题。动作服务器和客户端之间的连接与上述发布者和订阅中的 TCPROS 连接相同，但某些用法略有不同。例如，动作客户端发送取消命令或服务器发送结果值会中断连接，等。]]></content>
      <categories>
        <category>学习</category>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Jetson TX2 上安装 ROS 机器人操作系统]]></title>
    <url>%2F%2Fposts%2F%E5%9C%A8-Jetson-TX2-%E4%B8%8A%E5%AE%89%E8%A3%85-ROS-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html</url>
    <content type="text"><![CDATA[ROS 机器人操作系统关于 ROS ( Robot Operating System 机器人操作系统)，这里做一下简单的介绍。ROS 就是一个机器人软件平台，类似于个人电脑的操作系统( Windows、Linux、Mac OS 等)，智能手机的操作系统( Android、iOS 等)。机器人和电脑、手机一样可以通过各种硬件组合的硬件模块组成，自然就出现了用来管理这些硬件的操作系统。操作系统提供了基于硬件抽象的软件开发环境，存在提供各种服务的应用程序。ROS 就是这样一个提供了类似操作系统的硬件抽象。在 ROS 维基中将 ROS 定义为 “ ROS 是一个开放源代码的机器人元操作系统。它提供了我们对操作系统期望的服务，包括硬件抽象、低级设备控制、常用功能的实现、进程之间的消息传递以及功能包管理。它还提供了用于在多台计算机之间获取、构建、编写和运行代码的工具和库。 ”因此，ROS 并不是一种新的操作系统，确切的说，ROS 是一种元级操作系统。是基于现有操作系统的，利用应用程序和分布式计算资源之间的虚拟化层来运用分布式计算资源来执行调度、加载、监视、错误处理等任务的系统。同时提供一个或多个操作系统下的数据通信。 对于 ROS 的安装，之前官方网站上是没有中文教程的，对于我这种塑料英语，直接看官网英文教程还是蛮有难度的。不过好在现在 ROS 官网已经有中文版的安装教程了。直接参考官网上的教程安装就好了！官网安装教程：http://wiki.ros.org/cn/kinetic/Installation ROS 版本虽然官方已经有了中文版本的安装教程，但是我这里还是简单记录一下。首先，ROS 目前大家使用的主流版本还是 ROS 1.0 的版本，ROS 1.0 版本目前只支持 Linux 系统。而对 ROS 兼容性最好的就是 Ubuntu 操作系统了，恰好我们的 Jetson TX2 就是 Ubuntu 系统。 这里还要说明的是，我们在 TX2 上安装 ROS 系统，并不是要直接在 TX2 上来做开发的(虽然也可以)， TX2 主要是作为部署端的。因此，还需要有一台 Ubuntu 电脑也需要安装上 ROS 来进行开发工作，安装步骤相同。 其次， Ubuntu 和 ROS 都有很多版本，各版本之间是存在兼容性问题的。ROS 和 Ubuntu 之间的版本对应关系如下表： ROS 版本 发布日期 对应的 Ubuntu 版本 停止支持日期 ROS Melodic 2018.5.23 Ubuntu 18.04(Bionic)/Ubuntu 17.10(Artful) 2023.5 ROS Lunar 2017.5.23 Ubuntu 17.04(Zesty)/Ubuntu 16.10(Yakkety)/Ubuntu16.04(Xenial) 2019.5 ROS Kinetic(推荐) 2016.5.23 Ubuntu 16.04(Xenial)/Ubuntu 15.10(Wily) 2021.4 ROS Jade 2015.5.23 Ubuntu 15.04(Wily)/Ubuntu LTS 14.04(Trusty) 2017.5 ROS Kinetic 2014.7.22 Ubuntu LTS 14.04(Trusty) 2019.4 目前主流版本还是 ROS Kinetic 且支持时间较长，今年新出的 Melodic 版资料相对较少。所以推荐安装 ROS Kinetic 版本。 安装软件中心配置打开软件和更新对话框，配置你的 Ubuntu 软件仓库( repositories )以允许“restricted”，“universe”和“multiverse”这三种安装模式。如下图：配置完成关闭窗口。 添加source.list设置你的电脑可以从 packages.ros.org 接收软件。打开一个 Terminal ( Ctrl+Alt+T )，输入以下命令：1$ sudo sh -c &apos;echo “deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc)main”&gt; /etc/apt/sources.list.d/ros-latest.list&apos; 这个镜像国内会比较慢，建议更换为国内镜像源，就是把上面的命令更换一下。官方镜像 添加密钥1$ sudo apt-key adv --keyserver hkp：//ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 如果你遇到连接到 keyserver 的问题，你可以在以上命令尝试替换 hkp://pgp.mit.edu:80 或 hkp://keyserver.ubuntu.com:80密钥可以根据服务器的操作发生变更，如有变化，请参考官方wiki页面。 安装 ROS首先，确保你的系统软件是最新版本1$ sudo apt-get update 接下来，就可以安装 ROS 了，但是 ROS Kinetic 也有好几个版本，这里我们安装全功能版本(包括ROS、rqt、RViz、机器人相关的库、仿真和导航等等。部署端一般基础版就可以了)。1$ sudo apt-get install ros-kinetic-desktop-full 这里可能会要等待几分钟，因网速而定。如果一切顺利的话，那就安装完了。安装完成后，可以使用下面的命令查看可使用的软件包(可以搜索到大约1600多个功能包)：1$ apt-cache search ros-kinetic 如果想个别安装功能包，请使用如下命令:12&gt; $ sudo apt-get install ros-kinetic-[功能包名称]&gt; 现在是安装完了，但是我们还需要初始化 ROS 以及配置环境变量 初始化 rosdep在开始使用 ROS 之前还需要初始化 rosdep 。rosdep 可以方便地在需要编译某些源码的时候为其安装一些系统依赖，同时也是某些 ROS 核心功能组件所必需用到的工具。12$ sudo rosdep init$ rosdep update 配置环境如果每次打开一个新的终端时 ROS 环境变量都能够自动配置好(即添加到 bash 会话中)，那将会方便很多：12$ echo &quot;source /opt/ros/kinetic/setup.bash&quot; &gt;&gt; ~/.bashrc$ source ~/.bashrc 可以使用 gedit 或者 vi 等编辑器打开 bashrc 文件查看是否配置成功。在 bashrc 文件最底部我们可以看到已经有了很多设置。不要修改以前的设置，如果你需要修改的话在最底部添加就好了。1234567# Set ROS Kineticsource /opt/ros/kinetic/setup.bashsource ~/catkin_ws/devel/setup.bash# Set ROS Networkexport ROS_HOSTNAME=xxx.xxx.xxx.xxxexport ROS_MASTER_URI=http://$&#123;ROS_HOSTNAME&#125;:11311 安装构建依赖到目前为止，已经安装了运行核心 ROS 包所需的内容。为了创建和管理自己的 ROS 工作区，有各种各样的工具和需求分别分布。例如：rosinstall 是一个经常使用的命令行工具，它能够轻松地从一个命令下载许多 ROS 包的源树。 要安装这个工具和其他构建 ROS 包的依赖项，请运行:1$ sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential 好！到这里，ROS 就基本安装完成了。下面就来测试一下，看看是否可以正常运行。 测试 ROS首先，启动 ROS 环境输入 roscore 命令，测试测试结果如下：12345678910111213141516171819$ roscore... logging to /home/ubuntu/.ros/log/3e61b674-03cf-11e8-ac54-9cb70ddc3658/roslaunch-ubuntu-31481.logChecking log directory for disk usage. This may take awhile.Press Ctrl-C to interruptDone checking log file disk usage. Usage is &lt;1GB.started roslaunch server http://ubuntu:11311/ros_comm version 1.12.12SUMMARY========PARAMETERS * /rosdistro: kinetic * /rosversion: 1.12.12NODESauto-starting new masterprocess[master]: started with pid [31495]ROS_MASTER_URI=http://ubuntu:11311/setting /run_id to 3e61b674-03cf-11e8-ac54-9cb70ddc3658process[rosout-1]: started with pid [31508]started core service [/rosout] 如果看到 started core service [/rosout] ，那就说明安装成功了！退出按『Ctrl+c』。 如果你安装过程中出现了问题，可以尝试换个网络，或者多试几次吧，有时候服务器就是连不上！*_*]]></content>
      <categories>
        <category>学习</category>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>Jetson TX2</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetson TX2 重新编译内核添加usb等驱动]]></title>
    <url>%2F%2Fposts%2FJetson-TX2-%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%B7%BB%E5%8A%A0usb%E7%AD%89%E9%A9%B1%E5%8A%A8.html</url>
    <content type="text"><![CDATA[Jetson TX2 重新编译内核添加usb驱动上一篇我们已经简单说明了怎么给 Jetson TX2 刷机，Jetson TX2 虽然已经成功完成刷机了，但是 Nvidia 的默认配置是禁用了一些驱动的，比如说板子上的 UART 串口就不可以用，需要用户自己安装，重新编译新的镜像。本文这里就简单介绍一下，添加驱动并重新编译镜像。在 GitHub 上有别人开源的编译新镜像的脚本文件，在 Jetsonhacks 的仓库里有。这里我们就使用他的脚本文件。 下载脚本首先从 GitHub 上下载编译脚本1$ git clone https://github.com/jetsonhacks/buildJetsonTX2Kernel.git 如果你是 JetPack3.2.1 版本，直接使用 git 下载的话没有问题，因为目前他更新到的最新版本是 JetPack 3.2.1 内核版本为 28.2.1 (2018-8-20)。但是我安装的是 JetPack 3.1 对应的内核版本是 28.1 所以是不能直接使用的。因此需要下载对应的内核版本的脚本才可以使用。JetPack 3.1 版本的话就需要下载这个。https://github.com/jetsonhacks/buildJetsonTX2Kernel/archive/vL4T28.1.tar.gz 解压，获取源码下载好之后，解压缩，进入解压出来的文件夹，打开 Terminal 运行 getKernelSources.sh 脚本获取内核源码。1$ ./getKernelSources.sh 添加配置下载完成之后就会打开一个 xconfig 配置界面。设置你的镜像名称。打开设置 Genral Setup-&gt;Local version - append to kernel release，双击 Local version - append to kernel release在文本框中输入名字，如我这里为 -jetsonbot-v0.1 ， 回车；如下图所示： 在 xconfig 中按 Ctrl+F ，会弹出一个搜索框，输入你想要添加的设备驱动，比如可以添加 USB ACM， CH341 和 cp210x 串口驱动等，在搜索结果中选择对应的驱动，选中框打上勾即可。我这里搜索的是 ACM 驱动，如下图所示： 设置好了之后，一定要保存你的设置， File-&gt;Save 编译新内核保存好设置，关闭 xconfig 配置窗口，准备开始编译内核，编译过程大约需要 20 分钟。运行 makeKernel.sh 脚本，开始编译新的内核。1$ ./makeKernel.sh 重启编译过程中，你可以去喝杯 coffee 放松一下，等待编译完成。编译结束后，运行 copyImage.sh 脚本，将新编译的镜像文件拷贝到 /boot 目录下。拷贝完成重启 TX2 即可。12$ ./copyImage.sh$ reboot 结束语至此，我们添加有 USB 串口相关驱动的镜像就在 TX2 上被安装好了，这样就可以愉快的使用串口了。快使用新镜像进行开发吧！]]></content>
      <categories>
        <category>学习</category>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>Jetson TX2</tag>
        <tag>Nvidia</tag>
        <tag>内核编译</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nvidia Jetson TX2 刷机并安装JetPack3.1]]></title>
    <url>%2F%2Fposts%2FNvidia-Jetson-TX2-%E5%88%B7%E6%9C%BA%E5%B9%B6%E5%AE%89%E8%A3%85JetPack3.1.html</url>
    <content type="text"><![CDATA[Nvidia Jetson TX2 刷机并安装 JetPack3.1上篇，我已经简单介绍了一下我的整个小车的物理框架和软件架构。下面我可能会分成几次推文，介绍一下搭建小车的具体过程。本次主要记录一下给 Nvidia Jetson TX2 开发板刷机的过程。 准备工具1.一块Jetson TX2 开发板 2.一台安装 Ubuntu 系统的独立主机(不建议使用虚拟机，推荐使用 Ubuntu 16.04) 3.一台路由器 4.两根网线，一根 micro usb 数据线 准备工作1.首先需要从 Nvidia 的官方网站上下载 Jet Pack3.1 的安装包，使用 Ubuntu host 直接下载或者下载好拷贝到 host 上也可以。(我当时最新的是 Jet Pack3.1 ，现在已经到 3.3 了，你也可以使用最新的版本。下载的话需要 Nvidia 账号才可以)下载网址：https://developer.nvidia.com/embedded/jetpack 2.将 TX2 开发板和主机都通过网线连接到一台路由器上。准备好 TX2 开发板和 Ubuntu Host 之后就可以开始刷机了。 安装下载好 Jet Pack3.1 安装包后，打开 Terminal 进入到安装包所在的目录，执行下面这条命令运行安装包。运行效果如下图。(如果文件没有执行权限可以使用 chmod -x file 命令来改变执行权限) $ ./JetPack-L4T-3.1-linux-x64.run 运行完会弹出 JetPack L4T 3.1 Installer, 一路 Next 就好，如下图： 注意选择 Jetson TX2 开发板 点击 Next 之后会提示输入密码，待安装完成后，就会进入 JetPack L4T Component Manager。(这里要注意，如果网络不好可能会要等很久也出不来安装包信息，所以一定要保证网络环境好，可能有一些包还需要科学上网。)如果你的包加载好了，检查一下 CUDA Toolkit 和 OpenCV for Tegra 这两个包是否选择了，这两个一定要安装。选择好之后，点击 Next 。在弹出的弹框中勾选所有协议，等待各种包下载完成。 下载完成后，选择 Host 和 TX2 的连接方式，我们选择第一项，通过同一路由器连接在同一网络。网口选择保持默认就好。 接下来就是将包移动到 TX2 开发板上。文件较大，可能要等一会。执行下一步后，会出现一个提示重启 TX2 的步骤。按照提示进行操作。 第一步，将 TX2 关机， 拔下电源，使用 micro usb 数据线将 TX2 与 Host 相连。 第二步，重新插上电源，启动 TX2 ，同时按住 rec 和 rst 两个按键两秒钟， 然后松开 rst 按键，按住 rec 按键 3 秒钟。 第三步，这时在 Host 端，重新打开一个 terminal，查看 usb 端口信息(使用命令 lsusb 就可以查看)，这时应该就可以看 ID 为 0955:7C18 的叫 Nvidia Corp 的端口，就说明 TX2 已经进入 REC 模式并和 host 连接好了，这时回到有重启步骤的窗口，按回车 Enter，就开始 TX2 固件更新了。 安装完成后 TX2 就会重新启动，然后接下来会进行 CUDA 等一些软件的安装。 至此，Nvidia TX2 的安装就基本完成了。就可以愉快的在 Jetson TX2 上进行开发啦！ 结束语在 TX2 上进行基本开发的环境就已经基本搭建好了，但是大型的开发可能 TX2 本身自带的 30 多个 G 内存可能是不够的，因此我们可能还需要一个容量较大的 SSD 来放系统。还有就是 TX2 开发板默认的镜像设置可能会有一些端口没有开放，为了跟好的开发，所以后面需要我们自己重新编译镜像。这些在后面我会继续介绍。]]></content>
      <categories>
        <category>学习</category>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>Jetson TX2</tag>
        <tag>Nvidia</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的毕业设计--基于ROS的移动机器人]]></title>
    <url>%2F%2Fposts%2F%E6%88%91%E7%9A%84%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8EROS%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA.html</url>
    <content type="text"><![CDATA[在做毕设的时候就有这个想法，想把毕设过程中学到的和遇到坑全都一点点的记录下来。但是由于毕设时间也比较紧张，又要上班，所以一直拖到现在也没有写些什么。好在最近毕设也答辩结束了，也毕业了，稍稍轻松了一些，准备最近花一些时间来整理一些毕设的东西，写几篇文字记录一下。接下来整体介绍一下这个机器人。 简单来说，我的毕设就是做一个可以进行室内 SLAM 建图的移动机器人。首先呢，我把我的机器人分为上层和底层两个部分。上层为决策层，主要是在 Jetson TX2 开发板上，运行 ROS 机器人操作系统以及 SLAM 算法。通过激光雷达或者深度相机获取深度数据，进行机器人的同时定位与地图构建。底层为具体的控制层，主要是 STM32 通过串口通讯与上层进行通信，接收决策层的速度控制指令，以及进行电机速度控制。机器人的系统框架如下图所示。 各部分的具体介绍，将在后面我有空的时候慢慢更新，哈哈哈~~]]></content>
      <categories>
        <category>学习</category>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书]]></title>
    <url>%2F%2Fposts%2F%E8%AF%BB%E4%B9%A6.html</url>
    <content type="text"><![CDATA[前段时间，自己陆陆续续收集和整理了，好多电子书，还买了一个Kindle。也买了好些书，可是到现在也没看几本。下半年还是要多读书，多写字，多赚钱！ 这里简单列一下我的书单，我兴趣爱好广泛，所以读的书也就比较杂，姑且就简单分为两类吧！技术类的和消遣的书吧。 技术类：已读 OpenCV3编程入门 低功耗蓝牙开发权威指南 Cortex-M3权威指南 在读 C和指针 C专家编程 C陷阱与缺陷 TODO C++沉思录 深入理解计算机系统 程序员的数学 1，2，3 信息简史 大话设计模式 计算机原理与设计：Verilog HDL版 经典算法大全 算法导论 消遣类：已读 他改变了中国 人类简史 三体 I 三体: 黑暗森林 在读 三体: 死神永生 浪潮之巅 太阳的距离 数学之美 TODO 未来简史 宇宙最初三分钟 爱因斯坦传 Alibaba 2017技术集锦]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[strongwongのdiary]]></title>
    <url>%2F%2Fposts%2Fstrongwong%E3%81%AEdiary.html</url>
    <content type="text"><![CDATA[简单记录一下我每天搞了什么。成长之路，点滴记录！ 2018-8-1~8-51.搭建了博客，学习了 MarkDown 语法规则，学习用 MarkDown 来写作。2.测试 UlpBench3.移植 UlpBench 部分代码到 M3 上运行，测试功耗4.测试单指令差异5.整理分析测试数据 2018-8-61.阅读整理 Event Arbiter 代码，分析链路层和事件仲裁器之间的关系2.看了很多大佬的博客，调整了博客的一些设置 2018-8-81.今天还是在看 Event Arbiter 的代码和文档资料。2.尝试性的把 Event Arbiter 的部分代码进行了移植，但是没跑通，还要很多问题，明天继续解决。进展有点慢，测试方案还不知道怎么弄 _3.十年前的今天奥运会开幕了，我在家看奥运会；今天的我大学毕业了，在这里敲代码；十年后的我怎么样了，我会在干什么？4.博客还是要坚持写，加油！ 2018-8-91.今天还是搞 EA 这个东西，没什么进展，难受！2.领导让写一个 CM3 进 sleep 的代码，写了，内存中对应的位也写入值了，但是 J-link 还是可以正常连接，有很多东西好像并没有关掉，怀疑是设计的 SOC 有问题。 2018-8-101.我昨天给领导写的代码应该是没问题的，只是 FPGA 上不能进行这样的调试。但是还是有一些问题，比如说中断使能没做，也没有 rtc 或者 wakeup 的功能，还需要增加。2.EA 的大部分功能都已经移植好了，但是和底层相关的定时器我没有，还是有问题，不能进行正常调试。然后就是 EA 的整个测试流程怎么搞，我还不太明白，对单个函数的测好做，但是如果要测试多个事件的仲裁，测试 EA 的完整功能还不知道怎么弄。可能我需要有一个简单的任务切换，每个任务里请求一个事件，然后有 EA 来进行判断和仲裁。 2018-8-131.继续搞 EA ，底层的一些时间相关的寄存器我打算使用 Systick 和 Timer 结合起来模拟。但是还有一些问题，还需要解决。2.今天戚博有给了一个另外的任务，需要我在服务器上使用 arm-none-eabi-gcc 来做开发。让我写一套 Makefile ，虽然我之前有简单使用过 Makefile 、make ，但是我还没弄过这种相对大一些的项目的编译、开发。我找了些 makefile 的文档来学习，看看 Makefile 该怎么写。 2018-8-141.学习 Linux 下面的开发，学习 Makefile 的编写。了解补充一些编译、链接相关的知识，熟悉一下 GUN 相关的工具链。2.整理我之前写的代码，今天发现之前写的还是有一些问题，做了很多调整，今天主要调整了 UART 相关的代码。明天可能还需要把 timer 、 gpio 的代码做一些调整。然后往服务器上迁移。 2018-8-261.前段时间回家了一个多星期，断更了。现在回来了，接着写。2.今天整理了一下关于 Jetson TX2 内核重新编译的东西，写了一篇博文。3.请假之前领导让写 Makefile ，做一个使用 arm-none-eabi-gcc 在 Linux 下编译的版本。回来这几天搞完了。 在 Cygwin 下的编译 stm32 还是有点问题，还需要修改。 2018-8-311.仔细看了一些 Makefile 文件的编写规则，解决了编译问题。2.当当网有购书优惠，屯了 10 本技术相关的书籍。 2018-9-5今天突然发现不能上 Google 学习了，很尴尬，迅速寻找解决方案！成功切换到 v2ray 了上。哈哈，又可以愉快的学习了。 2018-9-151.又有好几天没有更新了，最近对无线电有了很大兴趣。于是前些天买了一个 RTL_SDR 鼓捣了一下软件无线电。挺好玩的~2.和做基带的同学，做了一些沟通，配合他们做一下 BB 的测试。 2018-9-20 ea 的基本测试做了一些，还没做完。 在和戚博的讨论过程中发现了我之前写的代码有一些不太合理的地方。缺乏面向对象的思想，代码没有很好的做到低耦合。需要做一些改动。 2018-10-6给博客增加了 Google Adsense ，文章下面会有 Google 广告，点击广告就会有一定的收益！来访问的小伙伴，看到广告记得帮我点一点啊~~]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo+Github Pages 搭建个人博客]]></title>
    <url>%2F%2Fposts%2F%E4%BD%BF%E7%94%A8Hexo-GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[使用 Hexo+Github Pages 搭建个人博客记录最近在学习的时候发现很多人都推荐说，要学会写作。很多大牛都会有自己的博客，或者微信公众号。不仅要学会学习，更要学会表达，而写作就是一个很好的方式。通过把自己学到的东西再次输出出来，才有价值，写作是一个人吸收知识，并增强记忆转化成自己东西的过程。很多人认为学校里出来了之后应该会很少写文字了，其实不然，在工作中经常会有各种各样的汇报和报告需要你去写。如果你不经常去写一些文字，慢慢的也就生疏了，也就忘了该怎么通过书面方式更好的表达信息。比如我们领导让大家每周写一份周报，每到周五的时候大家总是在纠结，这周报该怎么写。还有做测试的时候要有测试方案，测试结果，测试报告（分析）都是要写文档的。跟文字打交道的时候还是很多的啊！所以啊，平时还得多写写！ 我在看一些大牛的博客的时候，发现他们的博客，好像都很好看。我很羡慕，于是我也想搭建一个自己的个人博客，所以就有了本站！我了解到建站的方法有很多，比如: Hexo + GitHub Pages Jekyll + GitHub Pages WordPress + 服务器 + 域名 DeDeCMS + 服务器 + 域名 …… 我选择了使用 Hexo + GitHub Pages + 域名 的方法来建站。首先 Hexo 简约风格我很喜欢，其次利用 GitHub Pages 的免费存储空间不需要自己购买服务器，有一个 GitHub 账号就 ok 了，然后域名其实是一个可选项，GitHub 会提供一个 http://xxxx.github.io/ 这种形式的域名进行访问。 下面来简单记录一下，本站的搭建过程安装 Hexo 很简单，但是在安装前需要配置一些环境，需要安装 Node.js 和 Git 。因为 Hexo 博客系统是基于 Node.js 写的，需要 Node.js 的环境才能运行。 Hexo 运行之后会在本地生成网页，所以我们需要使用 Git 把本地网页文件上传到 GitHub 上的远程仓库里。（当然使用 GitHub 桌面版也可以上传。） 安装 Node.js在 Node.js 官网：https://nodejs.org/en/ 下载最新的稳定版，安装时保持默认设置，一路 next 就好，等待安装完成。安装好之后，按Win+R,输入 cmd，运行命令提示符，输入node -v和 nmp -v，如果出现版本号，那么就安装成功了。 安装 Git去 Git 官网：https://git-scm.com/ 下载最新的稳定版的 git 安装包，直接默认配置安装就好了，一路 next 就好。安装完成后，在桌面右键，点击Git Bush Here，输入 git --version，如果成功出现 Git 的版本号，到这里 Git 的环境配置就完成了！（如果你对 Git 不太熟悉，不太会用 Git 来上传你的博客，你也可以考虑使用 GitHub 的桌面版。） 注册 GitHub 和配置身为一个程序员，怎么能不知道 GitHub！每个程序员都应该有一个 GitHub 账号！GitHub是一个大型的代码托管平台，上面有很多技术大牛，也有很多有趣的开源项目，像Google、FaceBook、Macrosoft 等大公司也都在使用 GitHub。我们的博客就是托管在 GitHub 上的。 GitHub Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默认提供的域名 github.io 或者使用自定义域名来发布站点。 如果你还没有 Github 账号的话，需要先到 GitHub 官网进行注册： https://github.com/ 注册完成之后，我们需要创建一个仓库来存放我们的博客。新建一个项目，如下图所示：仓库名称一般使用用户名加 .github.io后缀，如下图所示：最后，创建完成后，就可以直接访问 https://yourname.github.io/ ,如果可以正常访问，那么 GitHub 的配置就搞完了。到这里环境就基本上搭好了，下面就开始安装 Hexo 正式搭建个人博客。 安装HexoHexo 是什么？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown (或者其他渲染引擎)解析文章，在几秒内，即可利用靓丽的主题生成静态网页。并且一条指令即可部署到 GitHub Pages 或者其他网站。想更多了解 Hexo 请阅读 Hexo 官方文档: https://hexo.io/zh-cn/ 首先，在你的电脑里，新建一个文件夹专门用来存放你的博客文件。比如我的都放在 D:\study\hexo 目录下。 然后在该目录下，右键点击 Git Bush Here，打开 Git 控制台窗口，接下来的操作都在 Git 控制台进行，反正我是挺喜欢敲命令行的感觉。 接下来，在该目录下，输入 npm install -g hexo-cli，安装 Hexo ，这里会有一个 WARN，不用担心这不会影响正常使用。然后在安装 Hexo 部署到 Github Pages 的 deployer。12$ npm install -g hexo-cli $ npm install hexo-deployer-git --save 查看 Hexo 的版本，输入 hexo -v，正确输入如下信息就表示 Hexo 安装成功了。 Hexo基础配置Hexo 安装完成后，执行下面的命令来初始化 Hexo ，对应的用户名(文件夹名称)改成自己的。Hexo 会在指定的文件夹中新建博客系统，和安装必备组件。 123$ hexo init strongwong.github.io$ cd strongwong.github.io$ npm install 新建完成后，在本地运行 Hexo 查看效果: 123$ hexo generate #或者运行 hexo g 根据配置生成博客$ hexo server #或者运行 hexo s 在本地运行 Hexo 登录 localhost:4000 查看 #按 ctrl + c 即可关闭本地服务器 这时我们到浏览器中输入 localhost:4000 就可以在本地端正常访问了(如下图)，这样的话就说明博客已经打起来了，但是现在只是在本地，别人还不能访问，接下来我们就要把本地博客部署到 GitHub 上，让别人也可以看到你的博客。 本地 Hexo 仓库与 GitHub 关联配置 GitHub 的 SSH 密钥，让本地项目通过 git 命令与远程 GitHub 仓库建立联系，我们在本地做了修改之后直接通过 git 命令就可以把博客同步到 GitHub 上。 1.首先，在 git 控制台中，输入如下命令，配置个人参数(你的名字，你的邮箱)。12$ git config --global user.name "yourname"$ git config --global user.email "your_email@example.com" 2.接下来生成 SSH key 根据提示进行操作(其实一路回车就好了。)1$ ssh-keygen -t rsa -C "your_email@example.com" 3.执行完之后就会在默认路径下生成 id_rsa.pub文件。默认路径是：C:\Users\Administrator\.ssh\id_rsa.pub 需要注意的是 .ssh 是隐藏文件夹。使用记事本打开这个文件，复制文件内容，然后粘贴到 https://github.com/settings/ssh/ 的 “new SSH key” 中。 4.输入下面的命令，查看 SSH 是否配置成功。1$ ssh -T git@github.com 如果是下面的反馈123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 直接输入 yes 就好了，然后就会看到：1Hi strongwong! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 这样的话，我们 SSH key 就配置成功了。 5.配置 deploy 参数在博客根目录下，找到 __config.yml 文件，找到 deploy 关键字，进行如下配置。1234deploy: type: git repo: git@github.com:strongwong/strongwong.github.io.git branch: master 6.将本地博客提交到 GitHub Pages1234$ hexo g #根据你的改动生成新的静态文件(即 public 文件夹)$ hexo s #启动本地预览 ctrl + c 关闭$ hexo d #部署到远程站点$ hexo clean #清除旧的静态文件(即 public 文件夹) 7.这时在浏览器输入 https://strongwong.github.io/ ，可以正常访问就说明 hexo 搭建的博客已经成功部署到 GitHub 了，小伙伴们都可以通过这个地址访问自己的博客了。 将个人域名解析到 GitHub看着这个 GitHub 下面的二级域名，总觉得让人不太爽，所以有很多小伙伴都买了自己的域名，然后将自己域名绑定到 GitHub Pages 的博客上。于是我也就到阿里云上购买了一个万网域名，也不是很贵。进入阿里云网站，打开阿里云域名控制台，点击管理，然后点击域名解析。 在下图中点击添加记录，添加解析： 记录类型选择CNAME主机记录填 www解析线路选择 默认记录值填 yourname.github.ioTTL 值为 10 分钟再添加一个解析，记录类型 A主机记录填 @解析线路选择 默认记录值填你 GitHub 的 IP 地址 (在 cmd 中 ping：ping yourname.github.io) 在本地博客的 source 目录下新建一个 CNAME 文件(没有扩展名)，用记事本打开填入购买的域名地址:1www.strongwong.top 将博客重新发布一次：1$ hexo g -d #generate 和 deploy 的组合命令 此时，在浏览器中输入你的个人域名(www.strongwong.top)，如果正常访问你的博客就说明，域名绑定成功，域名解析成功啦！！在这伟大的互联网时代，终于拥有了自己的网站啦！ 发表一篇文章运行下面的命令，就会创建一个文章文件，在本地博客的 source_posts 文件夹下就会有一个新建的 markdown 文件。1$ hexo new "文章标题" # hexo n "文章标题" 这种简写也可以 文章编辑好之后，推送到 GitHub 上我们在站点上就可以看到新的文章了。12$ hexo g #生成 $ hexo d #部署 安装 Next 主题及个性化Hexo 有非常多的主题可以选择，可以到官方主题库进行选择： https://hexo.io/themes/我这里选择了资料相对详细、丰富的 Next 主题，前往 Next 主题发布页面下载：https://github.com/iisnan/hexo-theme-next/releases/下载最新版本的 Next 主题包，解压缩，将文件名称改为 next，放置到博客根目录的 themes 目录下。打开站点配置文件 _config.yml，找到 themes 字段，修改为 next。到此，next 主题安装完成。 关于 next 主题的一些配置请查阅 next 主题官方文档：https://theme-next.iissnan.com/ 结束语花了两天时间把博客搭起来，还是挺开心的。博客使用 Hexo 搭建，主题使用 Next，评论系统使用 Valine ，文章浏览统计使用 LeanCloud ，网站访客数量使用不蒜子，另外还使用了 Google 统计，方便自己查看数据。我会坚持在工作之余，写点技术分享，记录一下我的学习历程。我也不知道我会分享哪些东西，但是我想可能还是嵌入式软件方面可能会比较多一些吧，其他方面也可能会分享一些学习、工作、生活中的经历和经验吧！祝我未来，越来越好！ strongwong 2018.8.2]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2F%2Fposts%2F%E5%85%B3%E4%BA%8E.html</url>
    <content type="text"><![CDATA[欢迎您访问我的网站，希望我分享的东西会对您有一些帮助！祝您 Coding 愉快！ 关于我，你什么也不需要知道，哈哈哈~~ 关于本站，我有时间就写点东西喽，嘿嘿~~，开心就好！ 关于分享什么，聊一点技术、谈一点理想、做一点实事不枉来世一遭！ 达则兼济天下，穷则独善其身~~ 做一个快乐的程序员！]]></content>
      <categories>
        <category>About</category>
      </categories>
      <tags>
        <tag>About</tag>
      </tags>
  </entry>
</search>
