<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[strongwongのdiary]]></title>
    <url>%2F2028%2F08%2F08%2Fstrongwong%E3%81%AEdiary%2F</url>
    <content type="text"><![CDATA[简单记录一下我每天搞了什么。成长之路，点滴记录！ 2018-8-1~8-51.搭建了博客，学习了 MarkDown 语法规则，学习用 MarkDown 来写作。2.测试 UlpBench3.移植 UlpBench 部分代码到 M3 上运行，测试功耗4.测试单指令差异5.整理分析测试数据 2018-8-61.阅读整理 Event Arbiter 代码，分析链路层和事件仲裁器之间的关系2.看了很多大佬的博客，调整了博客的一些设置 2018-8-81.今天还是在看 Event Arbiter 的代码和文档资料。2.尝试性的把 Event Arbiter 的部分代码进行了移植，但是没跑通，还要很多问题，明天继续解决。进展有点慢，测试方案还不知道怎么弄 _3.十年前的今天奥运会开幕了，我在家看奥运会；今天的我大学毕业了，在这里敲代码；十年后的我怎么样了，我会在干什么？4.博客还是要坚持写，加油！ 2018-8-91.今天还是搞 EA 这个东西，没什么进展，难受！2.领导让写一个 CM3 进 sleep 的代码，写了，内存中对应的位也写入值了，但是 J-link 还是可以正常连接，有很多东西好像并没有关掉，怀疑是设计的 SOC 有问题。 2018-8-101.我昨天给领导写的代码应该是没问题的，只是 FPGA 上不能进行这样的调试。但是还是有一些问题，比如说中断使能没做，也没有 rtc 或者 wakeup 的功能，还需要增加。2.EA 的大部分功能都已经移植好了，但是和底层相关的定时器我没有，还是有问题，不能进行正常调试。然后就是 EA 的整个测试流程怎么搞，我还不太明白，对单个函数的测好做，但是如果要测试多个事件的仲裁，测试 EA 的完整功能还不知道怎么弄。可能我需要有一个简单的任务切换，每个任务里请求一个事件，然后有 EA 来进行判断和仲裁。 2018-8-131.继续搞 EA ，底层的一些时间相关的寄存器我打算使用 Systick 和 Timer 结合起来模拟。但是还有一些问题，还需要解决。2.今天戚博有给了一个另外的任务，需要我在服务器上使用 arm-none-eabi-gcc 来做开发。让我写一套 Makefile ，虽然我之前有简单使用过 Makefile 、make ，但是我还没弄过这种相对大一些的项目的编译、开发。我找了些 makefile 的文档来学习，看看 Makefile 该怎么写。 2018-8-141.学习 Linux 下面的开发，学习 Makefile 的编写。了解补充一些编译、链接相关的知识，熟悉一下 GUN 相关的工具链。2.整理我之前写的代码，今天发现之前写的还是有一些问题，做了很多调整，今天主要调整了 UART 相关的代码。明天可能还需要把 timer 、 gpio 的代码做一些调整。然后往服务器上迁移。 2018-8-261.前段时间回家了一个多星期，断更了。现在回来了，接着写。2.今天整理了一下关于 Jetson TX2 内核重新编译的东西，写了一篇博文。3.请假之前领导让写 Makefile ，做一个使用 arm-none-eabi-gcc 在 Linux 下编译的版本。回来这几天搞完了。 在 Cygwin 下的编译 stm32 还是有点问题，还需要修改。 2018-8-311.仔细看了一些 Makefile 文件的编写规则，解决了编译问题。2.当当网有购书优惠，屯了 10 本技术相关的书籍。]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS 基础知识]]></title>
    <url>%2F2018%2F09%2F01%2FROS-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[ROS 基础知识上一篇，我们已经正确的安装好了 ROS ，但是在使用 ROS 进行机器人开发工作之前，我们先来了解一点 ROS 的基础知识，以便于后面的开发使用。当然我这里自然是没有 ROS wiki 上介绍的详细，要想学习更多的操作请先看 ROS wiki 上的入门教程这里我只简单介绍一下，在我的项目中会用到的一些操作。 创建工作空间工作空间（workspace）是一个存放工程开发相关文件的文件夹。主要目录结构如下： src: 代码空间 ( source space ) build: 编译空间 ( build space ) devel: 开发空间 ( development space ) install: 安装空间 ( install space ) 创建工作空间123$ mkdir -p ~/catkin_ws/src # 创建工作空间机源码空间$ cd ~/catkin_ws/src$ catkin_init_workspace # 初始化工作空间 编译工作空间12$ cd ~/catkin_ws/$ catkin_mate 设置环境变量1$ source devel/setup.bash 检查环境变量12$ echo $ROS_PACKAGE_PATH/home/ubuntu/catkin_ws/src:/opt/ros/kinetic/share:/opt/ros/kinetic/stacks 创建功能包一个功能包]]></content>
      <categories>
        <category>毕业设计</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Jetson TX2 上安装 ROS 机器人操作系统]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%9C%A8-Jetson-TX2-%E4%B8%8A%E5%AE%89%E8%A3%85-ROS-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[ROS 机器人操作系统关于 ROS ( Robot Operating System 机器人操作系统)，这里做一下简单的介绍。ROS 就是一个机器人软件平台，类似于个人电脑的操作系统( Windows、Linux、Mac OS 等)，智能手机的操作系统( Android、iOS 等)。机器人和电脑、手机一样可以通过各种硬件组合的硬件模块组成，自然就出现了用来管理这些硬件的操作系统。操作系统提供了基于硬件抽象的软件开发环境，存在提供各种服务的应用程序。ROS 就是这样一个提供了类似操作系统的硬件抽象。在 ROS 维基中将 ROS 定义为 “ ROS 是一个开放源代码的机器人元操作系统。它提供了我们对操作系统期望的服务，包括硬件抽象、低级设备控制、常用功能的实现、进程之间的消息传递以及功能包管理。它还提供了用于在多台计算机之间获取、构建、编写和运行代码的工具和库。 ”因此，ROS 并不是一种新的操作系统，确切的说，ROS 是一种元级操作系统。是基于现有操作系统的，利用应用程序和分布式计算资源之间的虚拟化层来运用分布式计算资源来执行调度、加载、监视、错误处理等任务的系统。同时提供一个或多个操作系统下的数据通信。 对于 ROS 的安装，之前官方网站上是没有中文教程的，对于我这种塑料英语，直接看官网英文教程还是蛮有难度的。不过好在现在 ROS 官网已经有中文版的安装教程了。直接参考官网上的教程安装就好了！官网安装教程：http://wiki.ros.org/cn/kinetic/Installation ROS 版本虽然官方已经有了中文版本的安装教程，但是我这里还是简单记录一下。首先，ROS 目前大家使用的主流版本还是 ROS 1.0 的版本，ROS 1.0 版本目前只支持 Linux 系统。而对 ROS 兼容性最好的就是 Ubuntu 操作系统了，恰好我们的 Jetson TX2 就是 Ubuntu 系统。 这里还要说明的是，我们在 TX2 上安装 ROS 系统，并不是要直接在 TX2 上来做开发的(虽然也可以)， TX2 主要是作为部署端的。因此，还需要有一台 Ubuntu 电脑也需要安装上 ROS 来进行开发工作，安装步骤相同。 其次， Ubuntu 和 ROS 都有很多版本，各版本之间是存在兼容性问题的。ROS 和 Ubuntu 之间的版本对应关系如下表： ROS 版本 发布日期 对应的 Ubuntu 版本 停止支持日期 ROS Melodic 2018.5.23 Ubuntu 18.04(Bionic)/Ubuntu 17.10(Artful) 2023.5 ROS Lunar 2017.5.23 Ubuntu 17.04(Zesty)/Ubuntu 16.10(Yakkety)/Ubuntu16.04(Xenial) 2019.5 ROS Kinetic(推荐) 2016.5.23 Ubuntu 16.04(Xenial)/Ubuntu 15.10(Wily) 2021.4 ROS Jade 2015.5.23 Ubuntu 15.04(Wily)/Ubuntu LTS 14.04(Trusty) 2017.5 ROS Kinetic 2014.7.22 Ubuntu LTS 14.04(Trusty) 2019.4 目前主流版本还是 ROS Kinetic 且支持时间较长，今年新出的 Melodic 版资料相对较少。所以推荐安装 ROS Kinetic 版本。 安装软件中心配置打开软件和更新对话框，配置你的 Ubuntu 软件仓库( repositories )以允许“restricted”，“universe”和“multiverse”这三种安装模式。如下图：配置完成关闭窗口。 添加source.list设置你的电脑可以从 packages.ros.org 接收软件。打开一个 Terminal ( Ctrl+Alt+T )，输入以下命令：1$ sudo sh -c &apos;echo “deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc)main”&gt; /etc/apt/sources.list.d/ros-latest.list&apos; 这个镜像国内会比较慢，建议更换为国内镜像源，就是把上面的命令更换一下。官方镜像 添加密钥1$ sudo apt-key adv --keyserver hkp：//ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 如果你遇到连接到 keyserver 的问题，你可以在以上命令尝试替换 hkp://pgp.mit.edu:80 或 hkp://keyserver.ubuntu.com:80 安装 ROS首先，确保你的系统软件是最新版本1$ sudo apt-get update 接下来，就可以安装 ROS 了，但是 ROS Kinetic 也有好几个版本，这里我们安装全功能版本(部署端一般基础版就可以了)。1$ sudo apt-get install ros-kinetic-desktop-full 这里可能会要等待几分钟，因网速而定。如果一切顺利的话，那就安装完了。安装完成后，可以使用下面的命令查看可使用的软件包：1$ apt-cache search ros-kinetic 现在是安装完了，但是我们还需要初始化 ROS 以及配置环境变量 初始化 rosdep在开始使用 ROS 之前还需要初始化 rosdep 。rosdep 可以方便地在需要编译某些源码的时候为其安装一些系统依赖，同时也是某些 ROS 核心功能组件所必需用到的工具。12$ sudo rosdep init$ rosdep update 配置环境如果每次打开一个新的终端时 ROS 环境变量都能够自动配置好(即添加到 bash 会话中)，那将会方便很多：12$ echo &quot;source /opt/ros/kinetic/setup.bash&quot; &gt;&gt; ~/.bashrc$ source ~/.bashrc 安装构建依赖到目前为止，已经安装了运行核心 ROS 包所需的内容。为了创建和管理自己的 ROS 工作区，有各种各样的工具和需求分别分布。例如：rosinstall 是一个经常使用的命令行工具，它能够轻松地从一个命令下载许多 ROS 包的源树。 要安装这个工具和其他构建 ROS 包的依赖项，请运行:1$ sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential 好！到这里，ROS 就基本安装完成了。下面就来测试一下，看看是否可以正常运行。 测试 ROS首先，启动 ROS 环境输入 roscore 命令，测试测试结果如下：12345678910111213141516171819$ roscore... logging to /home/ubuntu/.ros/log/3e61b674-03cf-11e8-ac54-9cb70ddc3658/roslaunch-ubuntu-31481.logChecking log directory for disk usage. This may take awhile.Press Ctrl-C to interruptDone checking log file disk usage. Usage is &lt;1GB.started roslaunch server http://ubuntu:11311/ros_comm version 1.12.12SUMMARY========PARAMETERS * /rosdistro: kinetic * /rosversion: 1.12.12NODESauto-starting new masterprocess[master]: started with pid [31495]ROS_MASTER_URI=http://ubuntu:11311/setting /run_id to 3e61b674-03cf-11e8-ac54-9cb70ddc3658process[rosout-1]: started with pid [31508]started core service [/rosout] 如果看到 started core service [/rosout] ，那就说明安装成功了！ 如果你安装过程中出现了问题，可以尝试换个网络，或者多试几次吧，有时候服务器就是连不上！/_/]]></content>
      <categories>
        <category>毕业设计</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Jetson TX2</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetson TX2 重新编译内核添加usb等驱动]]></title>
    <url>%2F2018%2F08%2F20%2FJetson-TX2-%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%B7%BB%E5%8A%A0usb%E7%AD%89%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[Jetson TX2 重新编译内核添加usb驱动上一篇我们已经简单说明了怎么给 Jetson TX2 刷机，Jetson TX2 虽然已经成功完成刷机了，但是 Nvidia 的默认配置是禁用了一些驱动的，比如说板子上的 UART 串口就不可以用，需要用户自己安装，重新编译新的镜像。本文这里就简单介绍一下，添加驱动并重新编译镜像。在 GitHub 上有别人开源的编译新镜像的脚本文件，在 Jetsonhacks 的仓库里有。这里我们就使用他的脚本文件。 下载脚本首先从 GitHub 上下载编译脚本1$ git clone https://github.com/jetsonhacks/buildJetsonTX2Kernel.git 如果你是 JetPack3.2.1 版本，直接使用 git 下载的话没有问题，因为目前他更新到的最新版本是 JetPack 3.2.1 内核版本为 28.2.1 (2018-8-20)。但是我安装的是 JetPack 3.1 对应的内核版本是 28.1 所以是不能直接使用的。因此需要下载对应的内核版本的脚本才可以使用。JetPack 3.1 版本的话就需要下载这个。https://github.com/jetsonhacks/buildJetsonTX2Kernel/archive/vL4T28.1.tar.gz 解压，获取源码下载好之后，解压缩，进入解压出来的文件夹，打开 Terminal 运行 getKernelSources.sh 脚本获取内核源码。1$ ./getKernelSources.sh 添加配置下载完成之后就会打开一个 xconfig 配置界面。设置你的镜像名称。打开设置 Genral Setup-&gt;Local version - append to kernel release，双击 Local version - append to kernel release在文本框中输入名字，如我这里为 -jetsonbot-v0.1 ， 回车；如下图所示： 在 xconfig 中按 Ctrl+F ，会弹出一个搜索框，输入你想要添加的设备驱动，比如可以添加 USB ACM， CH341 和 cp210x 串口驱动等，在搜索结果中选择对应的驱动，选中框打上勾即可。我这里搜索的是 ACM 驱动，如下图所示： 设置好了之后，一定要保存你的设置， File-&gt;Save 编译新内核保存好设置，关闭 xconfig 配置窗口，准备开始编译内核，编译过程大约需要 20 分钟。运行 makeKernel.sh 脚本，开始编译新的内核。1$ ./makeKernel.sh 重启编译过程中，你可以去喝杯 coffee 放松一下，等待编译完成。编译结束后，运行 copyImage.sh 脚本，将新编译的镜像文件拷贝到 /boot 目录下。拷贝完成重启 TX2 即可。12$ ./copyImage.sh$ reboot 结束语至此，我们添加有 USB 串口相关驱动的镜像就在 TX2 上被安装好了，这样就可以愉快的使用串口了。快使用新镜像进行开发吧！]]></content>
      <categories>
        <category>毕业设计</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Jetson TX2</tag>
        <tag>Nvidia</tag>
        <tag>内核编译</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nvidia Jetson TX2 刷机并安装JetPack3.1]]></title>
    <url>%2F2018%2F08%2F12%2FNvidia-Jetson-TX2-%E5%88%B7%E6%9C%BA%E5%B9%B6%E5%AE%89%E8%A3%85JetPack3.1%2F</url>
    <content type="text"><![CDATA[Nvidia Jetson TX2 刷机并安装 JetPack3.1上篇，我已经简单介绍了一下我的整个小车的物理框架和软件架构。下面我可能会分成几次推文，介绍一下搭建小车的具体过程。本次主要记录一下给 Nvidia Jetson TX2 开发板刷机的过程。 准备工具1.一块Jetson TX2 开发板 2.一台安装 Ubuntu 系统的独立主机(不建议使用虚拟机，推荐使用 Ubuntu 16.04) 3.一台路由器 4.两根网线，一根 micro usb 数据线 准备工作1.首先需要从 Nvidia 的官方网站上下载 Jet Pack3.1 的安装包，使用 Ubuntu host 直接下载或者下载好拷贝到 host 上也可以。(我当时最新的是 Jet Pack3.1 ，现在已经到 3.3 了，你也可以使用最新的版本。下载的话需要 Nvidia 账号才可以)下载网址：https://developer.nvidia.com/embedded/jetpack 2.将 TX2 开发板和主机都通过网线连接到一台路由器上。准备好 TX2 开发板和 Ubuntu Host 之后就可以开始刷机了。 安装下载好 Jet Pack3.1 安装包后，打开 Terminal 进入到安装包所在的目录，执行下面这条命令运行安装包。运行效果如下图。(如果文件没有执行权限可以使用 chmod -x file 命令来改变执行权限) $ ./JetPack-L4T-3.1-linux-x64.run 运行完会弹出 JetPack L4T 3.1 Installer, 一路 Next 就好，如下图： 注意选择 Jetson TX2 开发板 点击 Next 之后会提示输入密码，待安装完成后，就会进入 JetPack L4T Component Manager。(这里要注意，如果网络不好可能会要等很久也出不来安装包信息，所以一定要保证网络环境好，可能有一些包还需要科学上网。)如果你的包加载好了，检查一下 CUDA Toolkit 和 OpenCV for Tegra 这两个包是否选择了，这两个一定要安装。选择好之后，点击 Next 。在弹出的弹框中勾选所有协议，等待各种包下载完成。 下载完成后，选择 Host 和 TX2 的连接方式，我们选择第一项，通过同一路由器连接在同一网络。网口选择保持默认就好。 接下来就是将包移动到 TX2 开发板上。文件较大，可能要等一会。执行下一步后，会出现一个提示重启 TX2 的步骤。按照提示进行操作。 第一步，将 TX2 关机， 拔下电源，使用 micro usb 数据线将 TX2 与 Host 相连。 第二步，重新插上电源，启动 TX2 ，同时按住 rec 和 rst 两个按键两秒钟， 然后松开 rst 按键，按住 rec 按键 3 秒钟。 第三步，这时在 Host 端，重新打开一个 terminal，查看 usb 端口信息(使用命令 lsusb 就可以查看)，这时应该就可以看 ID 为 0955:7C18 的叫 Nvidia Corp 的端口，就说明 TX2 已经进入 REC 模式并和 host 连接好了，这时回到有重启步骤的窗口，按回车 Enter，就开始 TX2 固件更新了。 安装完成后 TX2 就会重新启动，然后接下来会进行 CUDA 等一些软件的安装。 至此，Nvidia TX2 的安装就基本完成了。就可以愉快的在 Jetson TX2 上进行开发啦！ 结束语在 TX2 上进行基本开发的环境就已经基本搭建好了，但是大型的开发可能 TX2 本身自带的 30 多个 G 内存可能是不够的，因此我们可能还需要一个容量较大的 SSD 来放系统。还有就是 TX2 开发板默认的镜像设置可能会有一些端口没有开放，为了跟好的开发，所以后面需要我们自己重新编译镜像。这些在后面我会继续介绍。]]></content>
      <categories>
        <category>毕业设计</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Jetson TX2</tag>
        <tag>Nvidia</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的毕业设计--基于ROS的移动机器人]]></title>
    <url>%2F2018%2F08%2F12%2F%E6%88%91%E7%9A%84%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8EROS%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[在做毕设的时候就有这个想法，想把毕设过程中学到的和遇到坑全都一点点的记录下来。但是由于毕设时间也比较紧张，又要上班，所以一直拖到现在也没有写些什么。好在最近毕设也答辩结束了，也毕业了，稍稍轻松了一些，准备最近花一些时间来整理一些毕设的东西，写几篇文字记录一下。接下来整体介绍一下这个机器人。 简单来说，我的毕设就是做一个可以进行室内 SLAM 建图的移动机器人。首先呢，我把我的机器人分为上层和底层两个部分。上层为决策层，主要是在 Jetson TX2 开发板上，运行 ROS 机器人操作系统以及 SLAM 算法。通过激光雷达或者深度相机获取深度数据，进行机器人的同时定位与地图构建。底层为具体的控制层，主要是 STM32 通过串口通讯与上层进行通信，接收决策层的速度控制指令，以及进行电机速度控制。机器人的系统框架如下图所示。 各部分的具体介绍，将在后面我有空的时候慢慢更新，哈哈哈~~]]></content>
      <categories>
        <category>毕业设计</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>机器人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书]]></title>
    <url>%2F2018%2F08%2F08%2F%E8%AF%BB%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[前段时间，自己陆陆续续收集和整理了，好多电子书，还买了一个Kindle。也买了好些书，可是到现在也没看几本。下半年还是要多读书，多写字，多赚钱！ 这里简单列一下我的书单，我兴趣爱好广泛，所以读的书也就比较杂，姑且就简单分为两类吧！技术类的和消遣的书吧。 技术类：已读 OpenCV3编程入门 低功耗蓝牙开发权威指南 Cortex-M3权威指南 在读 C和指针 C专家编程 C陷阱与缺陷 TODO C++沉思录 深入理解计算机系统 程序员的数学 1，2，3 信息简史 大话设计模式 计算机原理与设计：Verilog HDL版 经典算法大全 算法导论 消遣类：已读 他改变了中国 人类简史 在读 浪潮之巅 太阳的距离 数学之美 TODO 未来简史 三体 宇宙最初三分钟 爱因斯坦传 Alibaba 2017技术集锦]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo+Github Pages 搭建个人博客]]></title>
    <url>%2F2018%2F08%2F02%2F%E4%BD%BF%E7%94%A8Hexo-GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[使用 Hexo+Github Pages 搭建个人博客记录最近在学习的时候发现很多人都推荐说，要学会写作。很多大牛都会有自己的博客，或者微信公众号。不仅要学会学习，更要学会表达，而写作就是一个很好的方式。通过把自己学到的东西再次输出出来，才有价值，写作是一个人吸收知识，并增强记忆转化成自己东西的过程。很多人认为学校里出来了之后应该会很少写文字了，其实不然，在工作中经常会有各种各样的汇报和报告需要你去写。如果你不经常去写一些文字，慢慢的也就生疏了，也就忘了该怎么通过书面方式更好的表达信息。比如我们领导让大家每周写一份周报，每到周五的时候大家总是在纠结，这周报该怎么写。还有做测试的时候要有测试方案，测试结果，测试报告（分析）都是要写文档的。跟文字打交道的时候还是很多的啊！所以啊，平时还得多写写！ 我在看一些大牛的博客的时候，发现他们的博客，好像都很好看。我很羡慕，于是我也想搭建一个自己的个人博客，所以就有了本站！我了解到建站的方法有很多，比如: Hexo + GitHub Pages Jekyll + GitHub Pages WordPress + 服务器 + 域名 DeDeCMS + 服务器 + 域名 …… 我选择了使用 Hexo + GitHub Pages + 域名 的方法来建站。首先 Hexo 简约风格我很喜欢，其次利用 GitHub Pages 的免费存储空间不需要自己购买服务器，有一个 GitHub 账号就 ok 了，然后域名其实是一个可选项，GitHub 会提供一个 http://xxxx.github.io/ 这种形式的域名进行访问。 下面来简单记录一下，本站的搭建过程安装 Hexo 很简单，但是在安装前需要配置一些环境，需要安装 Node.js 和 Git 。因为 Hexo 博客系统是基于 Node.js 写的，需要 Node.js 的环境才能运行。 Hexo 运行之后会在本地生成网页，所以我们需要使用 Git 把本地网页文件上传到 GitHub 上的远程仓库里。（当然使用 GitHub 桌面版也可以上传。） 安装 Node.js在 Node.js 官网：https://nodejs.org/en/ 下载最新的稳定版，安装时保持默认设置，一路 next 就好，等待安装完成。安装好之后，按Win+R,输入 cmd，运行命令提示符，输入node -v和 nmp -v，如果出现版本号，那么就安装成功了。 安装 Git去 Git 官网：https://git-scm.com/ 下载最新的稳定版的 git 安装包，直接默认配置安装就好了，一路 next 就好。安装完成后，在桌面右键，点击Git Bush Here，输入 git --version，如果成功出现 Git 的版本号，到这里 Git 的环境配置就完成了！（如果你对 Git 不太熟悉，不太会用 Git 来上传你的博客，你也可以考虑使用 GitHub 的桌面版。） 注册 GitHub 和配置身为一个程序员，怎么能不知道 GitHub！每个程序员都应该有一个 GitHub 账号！GitHub是一个大型的代码托管平台，上面有很多技术大牛，也有很多有趣的开源项目，像Google、FaceBook、Macrosoft 等大公司也都在使用 GitHub。我们的博客就是托管在 GitHub 上的。 GitHub Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默认提供的域名 github.io 或者使用自定义域名来发布站点。 如果你还没有 Github 账号的话，需要先到 GitHub 官网进行注册： https://github.com/ 注册完成之后，我们需要创建一个仓库来存放我们的博客。新建一个项目，如下图所示：仓库名称一般使用用户名加 .github.io后缀，如下图所示：最后，创建完成后，就可以直接访问 https://yourname.github.io/ ,如果可以正常访问，那么 GitHub 的配置就搞完了。到这里环境就基本上搭好了，下面就开始安装 Hexo 正式搭建个人博客。 安装HexoHexo 是什么？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown (或者其他渲染引擎)解析文章，在几秒内，即可利用靓丽的主题生成静态网页。并且一条指令即可部署到 GitHub Pages 或者其他网站。想更多了解 Hexo 请阅读 Hexo 官方文档: https://hexo.io/zh-cn/ 首先，在你的电脑里，新建一个文件夹专门用来存放你的博客文件。比如我的都放在 D:\study\hexo 目录下。 然后在该目录下，右键点击 Git Bush Here，打开 Git 控制台窗口，接下来的操作都在 Git 控制台进行，反正我是挺喜欢敲命令行的感觉。 接下来，在该目录下，输入 npm install -g hexo-cli，安装 Hexo ，这里会有一个 WARN，不用担心这不会影响正常使用。然后在安装 Hexo 部署到 Github Pages 的 deployer。12$ npm install -g hexo-cli $ npm install hexo-deployer-git --save 查看 Hexo 的版本，输入 hexo -v，正确输入如下信息就表示 Hexo 安装成功了。 Hexo基础配置Hexo 安装完成后，执行下面的命令来初始化 Hexo ，对应的用户名(文件夹名称)改成自己的。Hexo 会在指定的文件夹中新建博客系统，和安装必备组件。 123$ hexo init strongwong.github.io$ cd strongwong.github.io$ npm install 新建完成后，在本地运行 Hexo 查看效果: 123$ hexo generate #或者运行 hexo g 根据配置生成博客$ hexo server #或者运行 hexo s 在本地运行 Hexo 登录 localhost:4000 查看 #按 ctrl + c 即可关闭本地服务器 这时我们到浏览器中输入 localhost:4000 就可以在本地端正常访问了(如下图)，这样的话就说明博客已经打起来了，但是现在只是在本地，别人还不能访问，接下来我们就要把本地博客部署到 GitHub 上，让别人也可以看到你的博客。 本地 Hexo 仓库与 GitHub 关联配置 GitHub 的 SSH 密钥，让本地项目通过 git 命令与远程 GitHub 仓库建立联系，我们在本地做了修改之后直接通过 git 命令就可以把博客同步到 GitHub 上。 1.首先，在 git 控制台中，输入如下命令，配置个人参数(你的名字，你的邮箱)。12$ git config --global user.name "yourname"$ git config --global user.email "your_email@example.com" 2.接下来生成 SSH key 根据提示进行操作(其实一路回车就好了。)1$ ssh-keygen -t rsa -C "your_email@example.com" 3.执行完之后就会在默认路径下生成 id_rsa.pub文件。默认路径是：C:\Users\Administrator\.ssh\id_rsa.pub 需要注意的是 .ssh 是隐藏文件夹。使用记事本打开这个文件，复制文件内容，然后粘贴到 https://github.com/settings/ssh/ 的 “new SSH key” 中。 4.输入下面的命令，查看 SSH 是否配置成功。1$ ssh -T git@github.com 如果是下面的反馈123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 直接输入 yes 就好了，然后就会看到：1Hi strongwong! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 这样的话，我们 SSH key 就配置成功了。 5.配置 deploy 参数在博客根目录下，找到 __config.yml 文件，找到 deploy 关键字，进行如下配置。1234deploy: type: git repo: git@github.com:strongwong/strongwong.github.io.git branch: master 6.将本地博客提交到 GitHub Pages1234$ hexo g #根据你的改动生成新的静态文件(即 public 文件夹)$ hexo s #启动本地预览 ctrl + c 关闭$ hexo d #部署到远程站点$ hexo clean #清除旧的静态文件(即 public 文件夹) 7.这时在浏览器输入 https://strongwong.github.io/ ，可以正常访问就说明 hexo 搭建的博客已经成功部署到 GitHub 了，小伙伴们都可以通过这个地址访问自己的博客了。 将个人域名解析到 GitHub看着这个 GitHub 下面的二级域名，总觉得让人不太爽，所以有很多小伙伴都买了自己的域名，然后将自己域名绑定到 GitHub Pages 的博客上。于是我也就到阿里云上购买了一个万网域名，也不是很贵。进入阿里云网站，打开阿里云域名控制台，点击管理，然后点击域名解析。 在下图中点击添加记录，添加解析： 记录类型选择CNAME主机记录填 www解析线路选择 默认记录值填 yourname.github.ioTTL 值为 10 分钟再添加一个解析，记录类型 A主机记录填 @解析线路选择 默认记录值填你 GitHub 的 IP 地址 (在 cmd 中 ping：ping yourname.github.io) 在本地博客的 source 目录下新建一个 CNAME 文件(没有扩展名)，用记事本打开填入购买的域名地址:1www.strongwong.top 将博客重新发布一次：1$ hexo g -d #generate 和 deploy 的组合命令 此时，在浏览器中输入你的个人域名(www.strongwong.top)，如果正常访问你的博客就说明，域名绑定成功，域名解析成功啦！！在这伟大的互联网时代，终于拥有了自己的网站啦！ 发表一篇文章运行下面的命令，就会创建一个文章文件，在本地博客的 source_posts 文件夹下就会有一个新建的 markdown 文件。1$ hexo new "文章标题" # hexo n "文章标题" 这种简写也可以 文章编辑好之后，推送到 GitHub 上我们在站点上就可以看到新的文章了。12$ hexo g #生成 $ hexo d #部署 安装 Next 主题及个性化Hexo 有非常多的主题可以选择，可以到官方主题库进行选择： https://hexo.io/themes/我这里选择了资料相对详细、丰富的 Next 主题，前往 Next 主题发布页面下载：https://github.com/iisnan/hexo-theme-next/releases/下载最新版本的 Next 主题包，解压缩，将文件名称改为 next，放置到博客根目录的 themes 目录下。打开站点配置文件 _config.yml，找到 themes 字段，修改为 next。到此，next 主题安装完成。 关于 next 主题的一些配置请查阅 next 主题官方文档：https://theme-next.iissnan.com/ 结束语花了两天时间把博客搭起来，还是挺开心的。博客使用 Hexo 搭建，主题使用 Next，评论系统使用 Valine ，文章浏览统计使用 LeanCloud ，网站访客数量使用不蒜子，另外还使用了 Google 统计，方便自己查看数据。我会坚持在工作之余，写点技术分享，记录一下我的学习历程。我也不知道我会分享哪些东西，但是我想可能还是嵌入式软件方面可能会比较多一些吧，其他方面也可能会分享一些学习、工作、生活中的经历和经验吧！祝我未来，越来越好！ strongwong 2018.8.2]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%85%B3%E4%BA%8E%2F</url>
    <content type="text"><![CDATA[欢迎您访问我的网站，希望我分享的东西会对您有一些帮助！祝您 Coding 愉快！ 关于我，你什么也不需要知道，哈哈哈~~ 关于本站，我有时间就写点东西喽，嘿嘿~~，开心就好！ 关于分享什么，聊一点技术、谈一点理想、做一点实事不枉来世一遭！ 达则兼济天下，穷则独善其身~~ 做一个快乐的程序员！]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
</search>
