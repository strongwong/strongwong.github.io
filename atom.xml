<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StrongWong</title>
  
  <subtitle>Embedded Software Engineer. Blogging about tech and life.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.strongwong.top/"/>
  <updated>2018-10-04T12:25:53.900Z</updated>
  <id>https://blog.strongwong.top/</id>
  
  <author>
    <name>strongwong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用树莓派 3b 和 RTL_SDR 搭建小功率无线电监测点</title>
    <link href="https://blog.strongwong.top//posts/%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE3b%E5%92%8CRTL-SDR%E6%90%AD%E5%BB%BA%E5%B0%8F%E5%8A%9F%E7%8E%87%E6%97%A0%E7%BA%BF%E7%94%B5%E7%9B%91%E6%B5%8B%E7%82%B9.html"/>
    <id>https://blog.strongwong.top//posts/使用树莓派3b和RTL-SDR搭建小功率无线电监测点.html</id>
    <published>2018-09-16T12:03:40.000Z</published>
    <updated>2018-10-04T12:25:53.900Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了两部关于无线电相关的电影（『时空接触』、『黑洞频率』），对与无线电产生了很大的兴趣。现代由于互联网的发展，玩无线电的人越来越少了，了解无线电知识的人也不多了。但是还是有很多人在学习和使用软件定义无线电( Software Defined Radio – SDR )，软件无线电可以做很多神奇事情！！</p><a id="more"></a><h2 id="SDR-是个什么东西？"><a href="#SDR-是个什么东西？" class="headerlink" title="SDR 是个什么东西？"></a>SDR 是个什么东西？</h2><blockquote><p>“软件无线电”( Software Defined Radio – SDR )。实际上软件无线电技术的研究和开发已经有几十年的历史了，其中传统上以硬件实现的组件（例如混频器，滤波器，放大器，调制器\解调器，检测器等），通过个人计算机或嵌入式系统上的软件实现。最初源于美军的多制式电台项目，应用在军事领域。<br>在 21 世纪初，由于众多公司的努力，使得它已从军事领域转向民用领域，成为经济的、应用广泛的、全球第三代移动通信系统的战略基础。<br>到今天我们日常使用的移动通信系统中就在大量使用软件无线电技术， 比如基站中的信号处理大量的使用可编程的 FPGA 和 DSP 完成，比如手机当中的基带处理器也越来越多的采用软解调的方法(少数运算量特别大实时性要求特别高的模块除外，比如 turbo 解码器、扩频相关器等，这些模块往往在基带处理器中嵌入一些高度定制化”硬”核来实现)。</p></blockquote><p>所以我们想要监听周围的无线电信号，自然是需要一个硬件的。</p><h2 id="需要的硬件"><a href="#需要的硬件" class="headerlink" title="需要的硬件"></a>需要的硬件</h2><ul><li>RTL-SDR (或者 HackRF等)</li><li>Raspberry Pi 3 (或者 Linux 系统的电脑)</li><li>有网络</li><li>高频天线</li></ul><p>我选择的是一根支持 rtl-sdr 的电视棒，就是采用 RTL2832u (频率范围为 64-1700mh )解调芯片的。这是瑞晟( Realtek )的一个芯片型号，原本是做电视棒芯片的。后来被人发现这个芯片具有非常广的频率接收范围，然后就被用来做 sdr 应用了。十分廉价！</p><h2 id="安装-RTL-SDR-驱动程序"><a href="#安装-RTL-SDR-驱动程序" class="headerlink" title="安装 RTL_SDR 驱动程序"></a>安装 RTL_SDR 驱动程序</h2><p>硬件已经有了，接下来就是安装相关的软件驱动，才可以使用</p><p>打开一个 Terminal 窗口，进入到你的 home 目录下。先更新一下系统的软件，然后开始安装需要的软件依赖。具体操作如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install git</span><br><span class="line">$ sudo apt-get install cmake</span><br><span class="line">$ sudo apt-get install build-essential</span><br><span class="line">$ sudo apt-get install libusb-1.0-0-dev</span><br></pre></td></tr></table></figure></p><p>相关的依赖软件安装完成后，接下来下载 RTL2832u Osmocom 的驱动源代码，进行编译安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://git.osmocom.org/rtl-sdr.git</span><br><span class="line">$ <span class="built_in">cd</span> rtl-sdr</span><br><span class="line">$ mkdir -p build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ../ -DINSTALL_UDEV_RULES=ON</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br><span class="line">$ sudo ldconfig</span><br><span class="line">$ sudo cp ../rtl-sdr.rules /etc/udev/rules.d</span><br></pre></td></tr></table></figure></p><p>将使用电视棒作为电视设备自动加载的默认驱动程序列入黑名单，因为它不能让电视棒作为 SDR 使用，并且将会与我们刚刚安装的新 Osmocom 驱动程序发生冲突</p><ul><li><ol><li>以 administrator 权限打开 <code>/etc/modprobe.d</code> 文件夹</li></ol></li><li><ol start="2"><li>在该目录下创建一个叫 <code>blacklist-rtl.conf</code> 的新文件，打开文件，在文件中加入 <code>blacklist dvb_usb_rtl28xxu</code> 这条指令</li></ol></li><li><ol start="3"><li>保存文件，并重启</li></ol></li></ul><p>机器重启后，将电视棒插入 usb 接口，打开 Terminal 窗口，输入 <code>rtl_test -t</code> 命令，测试电视棒是否能够被正常驱动。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/rtl_test.png" alt=""><br>不用担心 PLL 未锁定或未找到 E4000 调谐器或 R820T 而不是 R820T2 等消息。如果你看到跟上图一样的内容，那么说明你的驱动程序安装成功了，并且电视棒成功运行。 接着你就可以安装一些应用程序，来收听无线电信号。</p><h2 id="安装-dump1090"><a href="#安装-dump1090" class="headerlink" title="安装 dump1090"></a>安装 dump1090</h2><p>电视棒的 rtl_sdr 驱动程序安装好了之后，我们在安装一个 dump1090 应用程序，这样我们就可以接收飞机的信号。<br>能很容易的捕获到飞机是飞机在飞行过程中要不断的报告自身的飞行状态(在 1090Mhz 频率进行广播)，这就是 ADS-B( 广播式自动相关监视系统) ，即一种航空交通监视系统，而且是使用全球性导航卫星系统、飞机xo的航电设备和地面基础设施， 能够在飞机和航管地面站 ( air-to-ground 即 aircraft to ATS ) 或是空对空 ( air-to-air 即 aircraft to aircraft )之间准确和迅速自动地传送飞行讯息； 其中包括有飞机的识别、位置、高度、速度和其他数据或信息。简单来说 ADS-B 是由飞机直接发出的数据包，让地面或其他飞机可以得知它的位置、高度、速度等信息。ADS-B 利用 112 个未加密的脉冲字在 978Mhz、1090Mhz 发射的信号。我们使用电视棒捕获这些信号，并通过 dump1090 将捕获到信号解析成飞机飞行的信息，生成地图。这样我们就能知道飞机的实时位置及其他信息。</p><p>打开一个新的 Terminal 窗口，安装 dump1090，并开启 dump1090 服务，然后我们就可以在 Terminal 窗口和浏览器中查看到飞行信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ git <span class="built_in">clone</span> git://github.com/tedsluis/dump1090.git</span><br><span class="line">$ <span class="built_in">cd</span> dump1090</span><br><span class="line">$ make    <span class="comment"># 编译源码</span></span><br><span class="line">$ ./dump1090 --interactive --net --<span class="built_in">enable</span>-agc<span class="comment"># run dump1090</span></span><br></pre></td></tr></table></figure></p><p>收到的飞机的飞行信息如下图，dump 在启动时会开启自带的 WEB 服务器，并且 WEB 调用了谷歌地图的 API 接收到飞机的一些信息后会在页面地图上描绘出飞机的轨迹(谷歌地图目前需要科学上网)<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/dump1090.png" alt=""><br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/dump1090air.png" alt=""><br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/dump1090air2.png" alt=""><br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/air.jpg" alt=""></p><h2 id="安装-GQRX-收听各频率的广播"><a href="#安装-GQRX-收听各频率的广播" class="headerlink" title="安装 GQRX 收听各频率的广播"></a>安装 GQRX 收听各频率的广播</h2><p>我们可以收听广播或者火腿(无线电爱好者)的呼叫。但是这里我在树莓派上没有安装成功。因为 GUN Radio 安装不成功的问题。<br>不过我在 windows 上听到了广播。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了两部关于无线电相关的电影（『时空接触』、『黑洞频率』），对与无线电产生了很大的兴趣。现代由于互联网的发展，玩无线电的人越来越少了，了解无线电知识的人也不多了。但是还是有很多人在学习和使用软件定义无线电( Software Defined Radio – SDR )，软件无线电可以做很多神奇事情！！&lt;/p&gt;
    
    </summary>
    
      <category term="无线电" scheme="https://blog.strongwong.top/categories/%E6%97%A0%E7%BA%BF%E7%94%B5/"/>
    
    
      <category term="SDR" scheme="https://blog.strongwong.top/tags/SDR/"/>
    
      <category term="树莓派" scheme="https://blog.strongwong.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>关于 ARM Cortex-M3 的启动文件分析及分散加载</title>
    <link href="https://blog.strongwong.top//posts/%E5%85%B3%E4%BA%8E-ARM-Cortex-M3-%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD.html"/>
    <id>https://blog.strongwong.top//posts/关于-ARM-Cortex-M3-的启动文件分析及分散加载.html</id>
    <published>2018-09-07T03:22:44.000Z</published>
    <updated>2018-09-09T16:04:13.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-ARM-Cortex-M3-的启动文件分析及分散加载"><a href="#关于-ARM-Cortex-M3-的启动文件分析及分散加载" class="headerlink" title="关于 ARM Cortex-M3 的启动文件分析及分散加载"></a>关于 ARM Cortex-M3 的启动文件分析及分散加载</h2><p>下面以 ARM Cortex-M3 裸核的启动代码为例，做一下简单的分析。首先，在启动文件中完成了三项工作：</p><ul><li>堆栈以及堆的初始化</li><li>定位中断向量表</li><li>调用 Reset Handler</li></ul><a id="more"></a><p>在介绍之前，我们先了解一下 ARM 芯片启动文件中涉及到的一些汇编指令的用法。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4.jpg" alt=""></p><p>补充一下，其中 DCD 相当于 C 语言当中的 &amp;，定义地址。</p><h2 id="堆栈以及堆的初始化"><a href="#堆栈以及堆的初始化" class="headerlink" title="堆栈以及堆的初始化"></a>堆栈以及堆的初始化</h2><h3 id="堆栈的初始化"><a href="#堆栈的初始化" class="headerlink" title="堆栈的初始化"></a>堆栈的初始化</h3><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%A0%86%E6%A0%88%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E7%A0%81.jpg" alt="Startup_xxx.s 中的堆栈初始化代码"></p><p><code>Stack_Size  EQU  0x00000400</code><br>这个语句相当于 Stack_Size 这个标号（标号：链接器的术语，下文中提到的所有“标号”，指的都是指的链接器中的标号）等于 0x00000400 相当于 C 语言中的 <code>#define  Stack_Size  0x00000400</code> ，也就是说此语句只是一个声明，并未分配地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br></pre></td></tr></table></figure><p>此语句定义了一个叫 STACK 的代码段，并指明 8 字节对齐（ALIGN = 3）。其中 NOINIT 表示未初始化，READWRITE 表示可读可写，ALIGN = 3，即表示 2^3 = 8，八字节对齐。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack_Mem    SPACE   Stack_Size</span><br></pre></td></tr></table></figure><p>这里是为 Stack_Mem 分配 Stack_Size 大小的一块内存区域，注意这里分配的是 RAM ，即分配了大小为 1KB 的内存空间（0x00000400 = 1024）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__initial_sp</span><br></pre></td></tr></table></figure><p>紧跟着栈分配内存后，所以其为栈顶（满递减栈）。此标号有一层隐含的意思就是在 M3 中堆栈是满递减堆栈，因为它指定了堆栈指针位于堆栈的高地址（在 Stack_Mem 之后），具体如下图所示。</p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88.jpg" alt="堆栈指针 sp 位置"></p><p>上图来自 Cortex_M3 的一个工程的 xxx.map 文件。可以看出栈的起始地址为 0x20000c68，大小为 1024 字节（即 0x00000400 = Stack_Size）。而堆栈指针的位置在 0x20001068，其等于栈的起始地址 0x2000c68 + 0x00000400，说明本系列的 Cortex_M3 微控制器的堆栈为满递减堆栈。<br>所以 __initial_sp 为 1KB 空间栈的栈顶，栈主要用于局部变量和形参的调用过程的临时存储，属于编译器自动分配和释放的内存，所以这里需要注意如果你的函数所占的内存过大，那么这个空间应调整其大小但一定要小于内部 SRAM 的大小。堆是程序员空间是程序员进行分配和释放的，如果程序中未释放最后由系统回收。</p><h3 id="堆的初始化"><a href="#堆的初始化" class="headerlink" title="堆的初始化"></a>堆的初始化</h3><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E5%A0%86%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="Startup_xxx.s 中的堆初始化代码"></p><p>堆的初始化过程与堆栈的初始化相同。</p><h2 id="中断向量表的初始化"><a href="#中断向量表的初始化" class="headerlink" title="中断向量表的初始化"></a>中断向量表的初始化</h2><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8.jpg" alt="中断向量表的初始化代码（部分）"></p><p><code>PRESERVE8</code> 指定了以下的代码为 8 字节对齐，这是 keil 编译器的一个编程要求，对齐情况如下图所示：</p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/8%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.jpg" alt="xxx.list文件中的8字节对齐示意图"></p><p><code>THUMB</code> 指定了接下来的代码为 THUMB 指令集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AREA    RESET, DATA, READONLY</span><br></pre></td></tr></table></figure><p>此语句声明 RESET 数据段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPORT  __Vectors</span><br></pre></td></tr></table></figure></p><p>导出向量表标号，EXPORT 作用类似于 C 语言中的 extern。之后的代码就是为向量表分配存储区域。中断向量表从 FLASH 的 0x00000000 地址开始放置，以 4 个字节为一个单位，地址 0 存放的是栈顶指针（ sp ）的地址，0x00000004 存放的是复位程序的地址，往后以此类推，这里我们只设置了一个 Reset_Handler 向量。从代码上看，向量表中存放的都是中断服务函数的函数名，可我们知道 C 语言中的函数名就是一个地址。（由此我们知道，中断函数的函数名都已经知道了，我们在写对应的中断服务程序时，从对应的地址取服务例程的入口地址并跳入执行）。但是此处有一个要注意的，就是 0 号地址不是什么入口地址，而是给出的复位后的 MSP 的初值。</p><h2 id="调用-Reset-Handler"><a href="#调用-Reset-Handler" class="headerlink" title="调用 Reset Handler"></a>调用 Reset Handler</h2><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/reset_handler.jpg" alt="调用 Reset Handler 的代码"></p><p>此段代码只完成了一个功能，引导程序进入 <strong>main 。 </strong>main 的具体行为在后面做具体描述。<br><code>PROC</code> 与 <code>ENDP</code> 两个关键字组合在汇编中定义了一段子函数。<br>用户堆栈的初始化</p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E5%A0%86%E6%A0%88%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81.jpg" alt="具体的堆栈以及堆的初始化行为"></p><p>这一部分也就是把初始化的堆栈地址赋值给单片机的对应寄存器以方便 C 程序进行分配释放使用。</p><h2 id="其他代码"><a href="#其他代码" class="headerlink" title="其他代码"></a>其他代码</h2><p>有一些芯片厂商对芯片的加密的加密级别的代码也会放在这里，芯片上电后会自动读取这一地址的值以确定芯片的加密方式。</p><h2 id="ARM-芯片的启动过程详解"><a href="#ARM-芯片的启动过程详解" class="headerlink" title="ARM 芯片的启动过程详解"></a>ARM 芯片的启动过程详解</h2><p>接下来介绍 <strong>main 函数的具体实现过程。<br>首先在介绍 </strong>main 函数之前，我们先了解一些关于 ARM 芯片在启动过程中的基本知识。<br>“ ARM 程序”是指在 ARM 系统中正在执行的程序，而非保存在 ROM 中的 .bin(.axf,.hex)映像（ image ）文件。<br>一个 ARM 程序包含 3 部分：RO ，RW 和 ZI</p><ul><li>RO 就是只读数据，是程序中指令和常量；</li><li>RW 是可读写的数据，程序中已初始化变量；</li><li>ZI 是程序中未初始化的变量和初始化为 0 的变量。<br>简单理解就是：<br>  RO 就是 readonly ，RW 就是 read/write，ZI 就是 zero initial。</li></ul><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/arm%E8%8A%AF%E7%89%87%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.jpg" alt="ARM 芯片的启动过程详解"></p><p>注意，以上的过程并非绝对的，不同的 ARM 架构或者是不同的代码以上的执行过程是不同的。<br>复位处理程序是在汇编器中编写的短模块，系统一启动就立即执行。复位处理程序最少要为应用程序的运行模式初始化堆栈指针。对于具有本地内存系统（如缓存、TCM 、MMU 和 MPU）的处理器，某些配置必须在初始化过程的这一阶段完成。复位处理程序在执行之后，通常跳到 <strong>main 以开始 C 库初始化序列。</strong>main 中的 <strong>scatterload 负责设置内存，而 </strong>rt_entry 负责设置运行时的环境。<strong>scatterload 中负责把 RO/RW （非零）输出段从装载域地址复制到运行域地址（执行代码和数据复制、解压缩），并完成 ZI 段运行域数据的 0 初始化工作。然后跳到 </strong>rt_entry 设置堆栈和堆、初始化库函数和静态数据。然后，<strong>rt_entry 跳转到应用程序的入口 main() 。主应用程序结束执行后，</strong>rt_entry 将库关闭，然后把控制权交换给调试器。函数标签 main() 具有特殊含义。Main() 函数的存在强制链接器链接到 <strong>main 和 </strong>rt_entry 中的代码。如果没有标记为 main() 的函数，则没有链接到初始化序列，因而部分标准 C 库功能得不到支持。</p><h2 id="结合代码来看芯片启动过程"><a href="#结合代码来看芯片启动过程" class="headerlink" title="结合代码来看芯片启动过程"></a>结合代码来看芯片启动过程</h2><p>上电后硬件设置 sp 、pc ，刚上电复位后，硬件会自动根据向量表地址找到向量表。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sp_pc.jpg" alt=""></p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sp_pc1.jpg" alt=""></p><p>在离开复位状态后， CM3 做的第一件事就是读取下列两个 32 位整数的值：</p><ul><li>1.从地址 0x0000 0000 处取出 MSP 的初始值。</li><li>2.从地址 0x0000 0004 处取出 PC 的初始值，这个值是复位向量， LSB 必须是 1 。 然后从这个值所对应的地址处取指。<br>硬件自动从 0x0000 0000 位置处读取数据赋给栈指针 sp，然后从 0x0000 0004 位置处读取数据赋给 pc 指针，完成复位，结果为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SP = 0x2000 1068 </span><br><span class="line">PC = 0x0000 011D</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/reset%E5%90%AF%E5%8A%A8.jpg" alt=""></p><p>这与传统的 ARM 架构不同——其实也和绝大多数的其它单片机不同。传统的 ARM 架构总是从 0 地址开始执行第一条指令。它们的 0 地址处总是一条跳转指令。在 CM3 中，在 0 地址处提供 MSP 的初始值，然后紧跟着就是向量表。向量表中的数值是 32 位的地址，而不是跳转指令。向量表的第一个条目指向复位后应执行的第一条指令，就是我们上面分析的 Reset_Handler 这个函数。</p><p>进入__main<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR   R0, =__main</span><br><span class="line">BX　　R0</span><br></pre></td></tr></table></figure></p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/__main%E4%BB%A3%E7%A0%81.jpg" alt=""></p><p>执行上两条指令，跳转到 <strong>main 程序段运行，</strong>main 的地址是 0x0000 0080 ，上一步指令 pc = 0x0000 011D 的地址没有对齐，硬件自动对齐到 0x0000 011C，执行 __main。</p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/0x0000012c.jpg" alt=""></p><p>pc 指针通过立即数寻址，跳转到 0x0000 0081 处执行，同上这里也会自动对齐到 0x0000 0080 处。</p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/0x00000088.jpg" alt=""></p><p>在 <strong>scatterload 函数中又会进入 </strong>scatterload_copy ，在 __scatterload_copy 中进行代码搬运，主要是加载已经初始化的数据段和未初始化的数据段，同时还会初始化栈空间，即 ZI 段清零（其中搬运次数由代码中声明的变量类型和变量多少来决定）。</p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/ZI%E6%AE%B5%E6%B8%85%E9%9B%B6.jpg" alt=""></p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/__rt_entry.jpg" alt=""></p><p>然后会跳转到 <strong>rt_entry 函数执行，</strong>rt_entry 是使用 ARM C 库的程序的起点。将所有分散加载区重新定位到其执行地址后，会将控制权传递给 <strong>rt_entry 。如下图，在 </strong>rt_entry 中主要实现如下几个功能：</p><ul><li>1.设置用户的堆和堆栈</li><li>2.调用 __rt_lib_init 以初始化 C 库</li><li>3.调用 main()</li><li>4.调用 __rt_lib_shutdown 以关闭 C 库</li><li>5.退出</li></ul><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/C_library.jpg" alt=""></p><p><strong>rt_lib_init 函数是库函数初始化函数，它与 </strong>rt_lib_shutdown 配合使用。并且这个函数紧靠 __rt_stackheap_init() 后面调用，即紧跟堆和堆栈初始化后面调用，并且传递一个要用作堆的初始内存块。此函数是标准ARM库初始化函数，不能重新实现此函数。</p><p><strong>注意：最后两步是在程序退出 main() 函数的时候才会执行，而我们嵌入式程序一般都是死循环，所以基本上不会执行这两个过程。还有以上过程是针对使用标准 C Library 而言的，不包括使用 MDK 提供的 microlib 库的情况。</strong></p><p>在 <strong>rt_entry_main 中，用户程序就开始正式执行了（进入 C 的世界）。在此之前初始化 MSP 是必需的，因为可能第 1 条指令还没来得及执行，就发生了 NMI 或是其它 fault。 MSP 初始化好后就已经为它们的服务例程准备好了堆栈。这也就是 </strong>main 中做的事情。</p><h2 id="最后关于-microlib-库"><a href="#最后关于-microlib-库" class="headerlink" title="最后关于 microlib 库"></a>最后关于 microlib 库</h2><p>Microlib 是缺省 C 库的备选库。它旨在与需要装入到极少量内存中的深层嵌入式应用程序配合使用。这些应用程序不在操作系统中运行，因此 microlib 进行了高度优化以使代码变得很小，当然它的功能相比缺省 C 库少，并且根本不具备某些 ISO C 特性。某些库函数的运行速度也比较慢，比如 memcpy()。 </p><p>Microlib与缺省C库之间的主要差异是：</p><blockquote><p>Microlib 不符合 ISO C 库标准。不支持，某些 ISO 特性，并且其他特性具有的功能也比较少；<br>Microlib 不符合 IEEE754 二进制浮点算法标准；<br>Microlib 进行了高度优化以使代码变得很小；<br>无法对区域设置进行配置。缺省 C 区域设置是唯一可用的区域设置；<br>不能将 main() 声明为使用参数，并且不能返回内容；<br>不支持 stdio ，但未缓冲的 stdin、stdout 和 stderr 除外；<br>Microlib 对 C99 函数提供有限的支持；<br>Microlib 不支持操作系统函数；<br>Microlib 不支持与位置无关的代码；<br>Microlib 不提供互斥锁来防止非线程安全的代码；<br>Microlib 不支持宽字符或多字节字符串；<br>与stdlib 不同， microlib 不支持可选的单或双区内存模型。 Microlib 只提供双区内存模型，即单独的堆栈和堆区。</p></blockquote><h2 id="关于生成的-xxx-map-文件"><a href="#关于生成的-xxx-map-文件" class="headerlink" title="关于生成的 xxx.map 文件"></a>关于生成的 xxx.map 文件</h2><p>想要更好的了解启动代码的运行机制，我们就有必要了解一下由 Keil 的链接器“ armlink ”生成的描述文件，即 xxx.map 文件。</p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/map%E6%96%87%E4%BB%B6.jpg" alt="目标文件的组成"></p><p>上图即是 armlink 的链接器为测试代码生成的 xxx.map 文件中的一部分，其描述了镜像文件的组成信息，其中可以明显看到其由两部分构成：</p><ul><li>User Code 生成的目标文件</li><li>C Library 生成的目标文件</li></ul><p>可见我们在上文中所描述的启动过程中看到的 <strong>main 、 </strong>rt_entry 、 <strong>scartterload 以及 </strong>rt_lib_init 等，就是 C library 中的代码。<br>所以，我们每次烧录的可执行的 ARM 的 bin 文件中不仅有开发者编写的代码，还有 C Library 的代码。</p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/map%E4%B8%ADRW%E6%AE%B5.jpg" alt=""><br>上图为存放在RAM中的RW段。</p><h2 id="关于分散加载"><a href="#关于分散加载" class="headerlink" title="关于分散加载"></a>关于分散加载</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>由于 ARM Cortex-M3 系列是哈佛架构，哈佛架构是一种将程序指令存储和数据存储分开的存储器结构，所以它在运行时，指令存储在片内的 flash 上，数据存储在片内 SRAM 中。因此程序是可以直接在 flash 上运行的，而不是先将 flash 上的程序全部搬运到 RAM 在运行。<br>由此，我们也可以深入了解一下 ARM 映像（镜像）文件。 ARM 映像文件其实就是源文件经编译器生成的目标文件 .obj（object file）和相应的 C/C++ 运行时库（ Runtime Library ）经过连接器的处理后，生成的 axf 格式的映像文件，它可以直接烧录到目标设备的 ROM 中直接运行或加载后运行。</p><h3 id="映像文件的类型"><a href="#映像文件的类型" class="headerlink" title="映像文件的类型"></a>映像文件的类型</h3><p>常见的映像文件还包括 bin 、 hex 和 elf 文件，在 keil 调试过程中，调试器生成 axf 文件也是一种映像文件。<br>Bin 文件是纯粹的二进制机器代码，或者说是“顺序格式”。按照汇编代码顺序翻译成的二进制机器码，内部没有地址标记。 Bin 文件是直接的内存映像表示，二进制文件大小即为文件所包含的数据的实际大小。<br>Hex 文件是 Intel 标准的十六进制文件，通常用来保存单片机或其他处理器的目标程序代码。它保存物理程序存储区中的目标代码映像。一般的编程器都支持这种格式。就是机器代码的十六进制形式，并且是用一定文件格式的 ASCII 码来表示。在 Hex 文件里面，每一行代表一个记录。每条记录都由一个冒号“：”打头，其格式如下：<br><strong> :BBAAAATTHHHH…HHHHCC </strong></p><blockquote><p>BB:字节个数。<br>AAAA:数据记录的开始地址,高位在前,低位在后。<br>TT: Type<br>00 数据记录，用来记录数据。<br>01 记录结束，放在文件末尾，用来标识文件结束。<br>02 用来标识扩展段地址的记录<br>04 扩展地址记录(表示 32 位地址的前缀)<br>HHHH:一个字( Word )的数据记录,高字节在前,低字节在后。TT 之后共有 BB/2 个字的数据 。<br>CC: 占据一个 Byte 的 CheckSum </p></blockquote><p>ELF（ Executableand linking format ）文件是 x86 Linux 系统下的一种常用目标文件( objectfile )格式，有三种主要类型:</p><blockquote><p>(1)适于连接的可重定位文件( relocatablefile )，可与其它目标文件一起创建可执行文件和共享目标文件。<br>(2)适于执行的可执行文件( executable file )，用于提供程序的进程映像，加载到内存执行。<br>(3)共享目标文件( shared object file )，连接器可将它与其它可重定位文件和共享目标文件连接成其它的目标文件，动态连接器又可将它与可执行文件和其它共享目标文件结合起来创建一个进程映像。<br>Axf 文件由 ARM 编译器产生，除了包含 bin 的内容之外，还附加其他调试信息，这些调试信息加在可执行的二进制数据之前。调试时这些调试信息不会下载到 RAM 中，真正下载到 RAM 中的信息仅仅是可执行代码。因此，如果 ram 的大小小于 axf 文件的大小，程序是完全有可能在 ram 中调试的，只要 axf 除去调试信息后文件大小小于 ram 的大小即可。</p></blockquote><p><strong> 总结：</strong></p><ul><li>（1） axf 和 elf 都是编译器生成的可执行文件。区别是：ADS 编译出来的是 AXF 文件。gcc 编译出来的是 ELF 文件。两者虽然很像，但还是有差别的。这是文件格式的差别，不涉及调试格式。</li><li>（2）axf/elf 是带格式的映象，bin 是直接的内存映象的表示。</li><li>（3）Linux OS 下，ELF 通常就是可执行文件，通常 <code>gcc -o test test.c</code>，生成的 test 文件就是 ELF 格式的，在 Linux Shell 下输入 <code>./test</code> 就可以执行。在 Embedded 中，上电开始运行，没有 OS 系统，如果将 ELF 格式的文件烧写进去，包含一些 ELF 格式的东西，arm 运行碰到这些指令，就会导致失败，如果用 bin 文件，程序就可以一步一步运行。<br>所以最终放进 flash 的是 bin 文件。 elf 文件可转化为 hex 和 bin 两种文件， hex 也可以直接转换为 bin 文件，但是 bin 要转化为 hex 文件必须要给定一个基地址。而 hex 和 bin 不能转化为 elf 文件，因为 elf 的信息量要大。 Axf 文件可以转化为 bin 文件，KEIL 下可用以下命令 <code>fromelf -nodebug xx.axf -bin xx.bin</code> 即可。</li></ul><h3 id="映像文件的组成"><a href="#映像文件的组成" class="headerlink" title="映像文件的组成"></a>映像文件的组成</h3><p>镜像文件组成如下图所示：</p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6.jpg" alt="镜像文件的组成"></p><p>可执行文件由映像、区（域）、输出节（段）和输入节（段）的层次结构构成：</p><blockquote><p>映像由一个或多个区组成。每个区由一个或多个输出节组成。<br>每个输出节包含一个或多个输入节。<br>输入节是对象文件中的代码和数据信息。<br>输入节：输入节包含代码、初始化数据，或描述未初始化的或在映像执行之前必须设定为 0 的内存片段。这些特性通过 RO 、 RW 和 ZI 这样的属性来表示。<br>输出节：一个输出节由若干个具有相同 RO 、 RW 或 ZI 属性的相邻输入节组成。输出节的属性与组成它的输入节的属性相同 。<br>区：一个区由一个、两个或者三个相邻的输出节组成。区中的输出节根据其属性排序。首先是 RO 输出节，然后是 RW 输出节，最后是 ZI 输出节。区通常映射到物理内存设备，如 ROM 、 RAM 或外围设备。</p></blockquote><p>有时候用户希望将不同代码放在不同存储空间，也就是通过编译器生成的映像文件需要包含多个域，每个域在加载和运行时可以有不同的地址。要生成这样的映像文件，必须通过某种方式告知编译器相关的地址映射关系。在 Keil/ADS/IAR 等编译工具中，可通过分散加载机制实现。分散加载通过配置文件实现，这样的文件就称为分散加载文件。<br>分散加载( scatter loading )为 *.scf 文件。它提供这样一种机制：可以将内存变量定位于不同的物理地址上的存储器或端口，通过访问内存变量即可达到访问外部存储器或外设的目的；同时通过分散加载，让大多数程序代码在高速的内部 RAM 中运行，从而使得系统的实时性大大增强。这样，定位在 RAM 存储器的代码和数据就在 RAM 存储器中运行，而不再从 ROM 存储器中取数据或取指令，从而大大提高了 CPU 的运行速率和效率。<br>编译过程<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.jpg" alt="编译过程"><br>加载过程<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E7%AE%80%E5%8D%95%E5%8A%A0%E8%BD%BD.jpg" alt="简单的加载过程"></p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E8%BE%93%E5%87%BA%E7%9A%84map%E5%A4%A7%E5%B0%8F.jpg" alt="输出的map文件"></p><p>ROM（Flash）size = Code + RO_Data + RW_Data = 0.5kb；<br>RAM size = RW_Data + ZI_Data = 4.1kb。</p><p>加载时域的描述<br>sct 文件<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/sct%E6%96%87%E4%BB%B6.jpg" alt=".sct文件"></p><p>LR_IROM1 加载区域名，用于“ Linker ”区别不同的加载区域，最多 31 个字符；用来保存永久性数据（程序和只读变量）的区域；<br>ER_IROM1 执行区域名；程序执行时，从加载区域将数据复制到相应执行区后才能被正确执行；</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 0x00000000  0x00040000  &#123;    ; load region size_region</span><br><span class="line">  ER_IROM1 0x00000000  0x00010000  &#123;  ; load address = execution address</span><br><span class="line">   *.o (RESET, +First)</span><br><span class="line">   *(InRoot$$Sections)</span><br><span class="line">   .ANY (+RO)</span><br><span class="line">  &#125;</span><br><span class="line">  RW_IRAM1 0x20010000  0x00010000  &#123;  ; RW data</span><br><span class="line">   .ANY (+RW +ZI)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>LR_IROM1 0x00000000 0x00040000<br>定义一个加载时域，域基址：0x00000000，域大小为 0x00040000，对应实际 Flash 的大小<br>ER_IROM1 0x00000000 0x00010000<br>定义一个运行时域，第一个运行时域必须和加载时域起始地址相同，否则库不能加载到该时域的错误，其域大小一般也和加载时域大小相同，但是我们这里没有 flash ，只有 128k 的 RAM ，这里分配 64k 作为程序存储器，所以这里是 0x00010000 大小。</p><p>*.o (RESET, +First)<br>将 RESET 段最先加载到本域的起始地址外，即 RESET 的起始地址为 0，RESET 存储的是向量表</p><p>.ANY (+RO)<br>加载所有匹配目标文件的只读属性数据，包含：RW-Code、RO-Data。</p><p>RW_IRAM1 0x20010000 0x00010000<br>定义一个运行时域，域基址：0x20010000，域大小为 0x00010000 ，对应实际 RAM 大小，这时就不能从 0x20000000 开始了，因为实际 RAM 中前 64K 已经用于程序存储了，所以运行段向后偏移 0x00010000 大小，起始地址从 0x20010000 开始。之前就是因为这里的内存分配不对，地址从 0x20000000 开始，结果程序在搬运初始化过程中，把自己清零了，导致代码在进入 mian() 函数以后就跑飞了。</p><ul><li>(+RW +ZI)<br>加载所有区配目标文件的 RW-Data、ZI-Data 这里也可以用 .ANY 替代 * 号 </li></ul><p>下图为 STM32 的 sct 文件：</p><p><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/stm32sct.jpg" alt=""></p><p>下面为 OnSemiconductor RSL10 芯片的 sct 文件，编译环境为 eclipse 加 armlink。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS 0x00100000</span><br><span class="line">&#123;</span><br><span class="line">    ; For Cortex-M devices, the beginning of the startup code is stored in</span><br><span class="line">    ; the .interrupt_vector section, which goes to FLASH. All other code</span><br><span class="line">; follows this section.</span><br><span class="line">;对于 Cortex-M 设备，启动代码的开头存储在 .interrupt_vector 部分，该部分转到 FLASH 。 所有其他代码都在本节后面。</span><br><span class="line">    FLASH 0x00100000 0x60000 </span><br><span class="line">&#123;</span><br><span class="line">; Flash 起始地址为 0x00100000 大小为 0x60000  384k</span><br><span class="line"></span><br><span class="line">        * (RESET +FIRST)</span><br><span class="line">        </span><br><span class="line">        ; Remaining program code</span><br><span class="line">; 只读代码部分</span><br><span class="line">        * (+RO)</span><br><span class="line">      </span><br><span class="line">        ; All remaining DSP code </span><br><span class="line">; DSP 代码</span><br><span class="line">        * (.dsp, .dsp.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">; Define the data sections</span><br><span class="line">; 定义运行域</span><br><span class="line">    DRAM 0x20000000 (0x6000 - 2048) </span><br><span class="line">&#123;</span><br><span class="line">; DRAM 起始地址 0x20000000 大小 0x6000  大约 24k</span><br><span class="line">        ; Place the system clock variable first</span><br><span class="line">; 首先放置系统时钟变量</span><br><span class="line">        * (.systemclock +FIRST)</span><br><span class="line"></span><br><span class="line">        ; Place the defined data sections</span><br><span class="line">; 放置已定义的数据部分</span><br><span class="line">        * (.data_begin, .data_begin.*)</span><br><span class="line">        * (.data, .data.*)</span><br><span class="line">        * (.data_end, .data_end.*)</span><br><span class="line">    </span><br><span class="line">        ; Place all remaining read-write and zero-initialized data </span><br><span class="line">; 放置所有剩余的读写和零初始化数据</span><br><span class="line">        * (+RW)</span><br><span class="line">        * (+ZI)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">; Define a heap region</span><br><span class="line">; 定义堆区域 起始地址 0x20005800 大小 0x400  1k</span><br><span class="line">    ARM_LIB_HEAP 0x20005800 EMPTY 0x400</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">; Define a stack region</span><br><span class="line">; 定义栈区域 起始地址 0x20005C00  大小 0x400 1k</span><br><span class="line">    ARM_LIB_STACK 0x20005C00 EMPTY 0x400</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于-ARM-Cortex-M3-的启动文件分析及分散加载&quot;&gt;&lt;a href=&quot;#关于-ARM-Cortex-M3-的启动文件分析及分散加载&quot; class=&quot;headerlink&quot; title=&quot;关于 ARM Cortex-M3 的启动文件分析及分散加载&quot;&gt;&lt;/a&gt;关于 ARM Cortex-M3 的启动文件分析及分散加载&lt;/h2&gt;&lt;p&gt;下面以 ARM Cortex-M3 裸核的启动代码为例，做一下简单的分析。首先，在启动文件中完成了三项工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆栈以及堆的初始化&lt;/li&gt;
&lt;li&gt;定位中断向量表&lt;/li&gt;
&lt;li&gt;调用 Reset Handler&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="嵌入式" scheme="https://blog.strongwong.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="学习" scheme="https://blog.strongwong.top/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ARM" scheme="https://blog.strongwong.top/tags/ARM/"/>
    
      <category term="CM3" scheme="https://blog.strongwong.top/tags/CM3/"/>
    
      <category term="启动文件" scheme="https://blog.strongwong.top/tags/%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6/"/>
    
      <category term="分散加载" scheme="https://blog.strongwong.top/tags/%E5%88%86%E6%95%A3%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>make 命令及 makefile 文件编写</title>
    <link href="https://blog.strongwong.top//posts/make-%E5%91%BD%E4%BB%A4%E5%8F%8A-makefile-%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99.html"/>
    <id>https://blog.strongwong.top//posts/make-命令及-makefile-文件编写.html</id>
    <published>2018-09-03T08:56:52.000Z</published>
    <updated>2018-09-03T09:32:49.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间因为工作需要简单学习了一下 make 命令以及 makefile 文件的编写，这里整理一篇在网上看到的比较简洁明了的教程。</p><blockquote><p>代码变成可执行文件，叫做 <a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener">编译</a>（ compile ）；先编译这个，还是先编译那个（即编译的安排），叫做 <a href="https://en.wikipedia.org/wiki/Software_build" target="_blank" rel="noopener">构建</a>（ build ）。</p><p><a href="https://en.wikipedia.org/wiki/Make_%28software%29" target="_blank" rel="noopener">Make</a> 是最常用的构建工具，诞生于 1977 年，主要用于 C 语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用 Make 构建。</p><p>本文介绍 Make 命令的用法，从简单的讲起，不需要任何基础，只要会使用命令行，就能看懂。我的参考资料主要是 Isaac Schlueter 的<a href="https://gist.github.com/isaacs/62a2d1825d04437c6f08" target="_blank" rel="noopener">《 Makefile 文件教程》</a>和<a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener">《 GNU Make 手册》</a>。</p><blockquote><p>来源： <a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/make.html</a><br>作者： 阮一峰</p></blockquote></blockquote><a id="more"></a><h2 id="Make-的概念"><a href="#Make-的概念" class="headerlink" title="Make 的概念"></a>Make 的概念</h2><p>Make 这个词，英语的意思是”制作”。Make 命令直接用了这个意思，就是要做出某个文件。比如，要做出文件 test.txt ，就可以执行下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make test.txt</span><br></pre></td></tr></table></figure></p><p>但是，如果你真的输入这条命令，它并不会起作用。因为 Make 命令本身并不知道，如何做出 test.txt ，需要有人告诉它，如何调用其他命令完成这个目标。</p><p>比如，假设文件 test.txt 依赖于 a.txt 和 b.txt ，是后面两个文件连接（ cat 命令）的产物。那么， make 需要知道下面的规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.txt: a.txt b.txt</span><br><span class="line">    cat a.txt b.txt &gt; test.txt</span><br></pre></td></tr></table></figure></p><p>也就是说， make test.txt 这条命令的背后，实际上分成两步：第一步，确认 a.txt 和 b.txt 必须已经存在，第二步使用 cat 命令 将这个两个文件合并，输出为新文件。</p><p>像这样的规则，都写在一个叫做 Makefile 的文件中， Make 命令依赖这个文件进行构建。 Makefile 文件也可以写为 makefile ， 或者用命令行参数指定为其他文件名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make -f rules.txt</span><br><span class="line"># 或者</span><br><span class="line">$ make --file=rules.txt</span><br></pre></td></tr></table></figure></p><p>上面代码指定 make 命令依据 rules.txt 文件中的规则，进行构建。</p><p>总之， make 只是一个根据指定的 Shell 命令进行构建的工具。它的规则很简单，你规定要构建哪个文件、它依赖哪些源文件，当那些文件有变动时，如何重新构建它。</p><h2 id="Makefile-文件格式"><a href="#Makefile-文件格式" class="headerlink" title="Makefile 文件格式"></a>Makefile 文件格式</h2><p>构建规则都写在 Makefile 文件里面，要学会如何 Make 命令，就必须学会如何编写 Makefile 文件。</p><h3 id="Makefile-概述"><a href="#Makefile-概述" class="headerlink" title="Makefile 概述"></a>Makefile 概述</h3><p>Makefile 文件由一系列规则（ rules ）构成。每条规则的形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt;: &lt;prerequisites&gt;</span><br><span class="line">[tab]&lt;commands&gt;</span><br></pre></td></tr></table></figure></p><p>上面第一行冒号前面的部分，叫做“目标”（ target ），冒号后面的部分叫做“前置条件”（ prerequisites ）；第二行必须由一个 tab 键起首，后面跟着“命令”（ commands ）。</p><p>“目标”是必需的，不可省略；“前置条件”和“命令”都是可选的，但是两者之中必须至少存在一个。</p><p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p><h3 id="目标（target）"><a href="#目标（target）" class="headerlink" title="目标（target）"></a>目标（target）</h3><p>一个目标（ target ）就构成一条规则。目标通常是文件名，指明 Make 命令所要构建的对象，比如上文的  test.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p><p>除了文件名，目标还可以是某个操作的名字，这称为“伪目标”（ phony target ）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm *.o</span><br></pre></td></tr></table></figure></p><p>上面代码的目标是 clean ，它不是文件名，而是一个操作的名字，属于“伪目标”，作用是删除对象文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make clean</span><br></pre></td></tr></table></figure></p><p>但是，如果当前目录中，正好有一个文件叫做 clean ，那么这个命令不会执行。因为 Make 发现 clean 文件已经存在，就认为没有必要重新构建了，就不会执行指定的 rm 命令。</p><p>为了避免这种情况，可以明确声明 clean 是“伪目标”，写法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure></p><p>声明 clean 是“伪目标”之后， make 就不会去检查是否存在一个叫做 clean 的文件，而是每次运行都执行对应的命令。像 .PHONY 这样的内置目标名还有不少，可以查看<a href="https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets" target="_blank" rel="noopener">手册</a>。</p><p>如果 Make 命令运行时没有指定目标，默认会执行 Makefile 文件的第一个目标。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure></p><p>上面代码执行 Makefile 文件的第一个目标。</p><h3 id="前置条件（-prerequisites"><a href="#前置条件（-prerequisites" class="headerlink" title="前置条件（ prerequisites )"></a>前置条件（ prerequisites )</h3><p>前置条件通常是一组文件名，之间用空格分隔。它指定了“目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的 last-modification 时间戳比目标的时间戳新），“目标”就需要重新构建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result.txt: source.txt</span><br><span class="line">    cp source.txt result.txt</span><br></pre></td></tr></table></figure></p><p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中， source.txt 已经存在，那么 make result.txt 可以正常运行，否则必须再写一条规则，来生成 source.txt 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source.txt</span><br><span class="line">    echo &quot;this is the source&quot; &gt; source.txt</span><br></pre></td></tr></table></figure></p><p>上面代码中， source.txt 后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用 make source.txt ，它都会生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make result.txt</span><br><span class="line">$ make result.txt</span><br></pre></td></tr></table></figure></p><p>上面命令连续执行两次 make result.txt 。第一次执行会先新建 source.txt ，然后再新建 result.txt 。第二次执行， Make 发现 source.txt 没有变动（时间戳晚于 result.txt ），就不会执行任何操作， result.txt 也不会重新生成。</p><p>如果需要生成多个文件，往往采用下面的写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source: file1 file2 file3</span><br></pre></td></tr></table></figure></p><p>上面代码中， source 是一个伪目标，只有三个前置文件，没有任何对应的命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">source</span></span><br></pre></td></tr></table></figure></p><p>执行 <code>make source</code> 命令后，就会一次性生成 file1 ， file2 ， file3 三个文件。这比下面的写法要方便很多:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make file1</span><br><span class="line">$ make file2</span><br><span class="line">$ make file3</span><br></pre></td></tr></table></figure></p><h3 id="命令（-commands-）"><a href="#命令（-commands-）" class="headerlink" title="命令（ commands ）"></a>命令（ commands ）</h3><p>命令（ commands ）表示如何更新目标文件，由一行或多行的 Shell 命令组成。它是构建“目标”的具体指令，它的运行结果通常就是生成目标文件。</p><p>每行命令之前必须有一个 tab 键。如果想用其他键，可以用内置变量 .RECIPEPREFIX 声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.RECTPEPREFIX = &gt;</span><br><span class="line">all:</span><br><span class="line">&gt; echo Hello, world</span><br></pre></td></tr></table></figure></p><p>上面代码用 .RECIPEPREFIX 指定，大于号（ &gt; ）替代 tab 键。所以，每一行命令的起首变成了大于号，而不是 tab 键。</p><p>需要注意的是，每行命令在一个单独的 shell 中执行。这些 Shell 之间没有继承关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var-lost:</span><br><span class="line">    export foo=bar</span><br><span class="line">echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure></p><p>上面代码执行后（<code>make var-lost</code>），取不到 foo 的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var-kept:</span><br><span class="line">    export foo=bar; echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure></p><p>另一个解决办法是在换行符前加反斜杠转义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var-kept:</span><br><span class="line">    export foo=bar; \</span><br><span class="line">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure></p><p>最后一个方法是加上 <code>.ONESHELL:</code>命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.ONESHELL:</span><br><span class="line">var-kept:</span><br><span class="line">    export foo=bar;</span><br><span class="line">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure></p><h2 id="Makefile-文件语法"><a href="#Makefile-文件语法" class="headerlink" title="Makefile 文件语法"></a>Makefile 文件语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>井号（#）在 Makefile 中表示注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 这是注释</span><br><span class="line">result.txt: source.txt</span><br><span class="line">    # 这是注释</span><br><span class="line">    cp source.txt result.txt # 这是注释</span><br></pre></td></tr></table></figure></p><h3 id="回声（-echoing-）"><a href="#回声（-echoing-）" class="headerlink" title="回声（ echoing ）"></a>回声（ echoing ）</h3><p>正常情况下，make 会打印每条命令，然后再执行，这就叫做回声（echoing）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test:</span><br><span class="line">    # 这是测试</span><br></pre></td></tr></table></figure></p><p>执行上面的规则，会得到下面的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure></p><p>在命令的前面加上 @ ，就可以关闭回声。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test:</span><br><span class="line">    @# 这是测试</span><br></pre></td></tr></table></figure></p><p>现在再执行 <code>make test</code>，就不会有任何输出。</p><p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的 echo 命令前面加上 @ 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test:</span><br><span class="line">    @# 这是测试</span><br><span class="line">    @echo TODO</span><br></pre></td></tr></table></figure></p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符（ wildcard ）用来指定一组符合条件的文件名。 Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 [...] 。比如， *.o 表示所有后缀名为 .o 的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm -f *.o</span><br></pre></td></tr></table></figure></p><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>Make 命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是 %。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o: %.c</span><br></pre></td></tr></table></figure></p><p>等同于下面的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1.o: f1.c</span><br><span class="line">f2.o: f2.c</span><br></pre></td></tr></table></figure></p><p>使用通配符 %，可以将大量同类型的文件，只用一条规则就完成构建。</p><h3 id="变量和赋值符"><a href="#变量和赋值符" class="headerlink" title="变量和赋值符"></a>变量和赋值符</h3><p>Makefile 允许使用等号自定义变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">txt = Hello World</span><br><span class="line">test:</span><br><span class="line">    @echo $(txt)</span><br></pre></td></tr></table></figure></p><p>上面代码中，变量 txt 等于 Hello World 。调用时，变量需要放在 $( ) 之中。</p><p>调用 Shell 变量，需要在美元符号前，再加一个美元符号，这是因为 Make 命令会对美元符号转义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test:</span><br><span class="line">    @echo $$HOME</span><br></pre></td></tr></table></figure></p><p>有时，变量的值可能指向另一个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1 = $(v2)</span><br></pre></td></tr></table></figure></p><p>上面代码中，变量 v1 的值是另一个变量 v2 。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。</p><p>为了解决类似问题， Makefile 一共提供了四个赋值运算符 （=、:=、？=、+=），它们的区别请看 <a href="https://stackoverflow.com/questions/448910/what-is-the-difference-between-the-gnu-makefile-variable-assignments-a" target="_blank" rel="noopener">StackOverflow</a> 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在执行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br></pre></td></tr></table></figure></p><h3 id="内置变量（Implicit-Variables）"><a href="#内置变量（Implicit-Variables）" class="headerlink" title="内置变量（Implicit Variables）"></a>内置变量（Implicit Variables）</h3><p>Make 命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的 Make 工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html" target="_blank" rel="noopener">手册</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">    $(CC) -o output input.c</span><br></pre></td></tr></table></figure></p><h3 id="自动变量（Automatic-Variables）"><a href="#自动变量（Automatic-Variables）" class="headerlink" title="自动变量（Automatic Variables）"></a>自动变量（Automatic Variables）</h3><p>Make 命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。<br><strong>(1) $@</strong><br>$@ 指代当前目标，就是 Make 命令当前构建的那个目标。 比如，<code>make foo</code>的 $@ 就指代 foo。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt b.txt:</span><br><span class="line">    touch $@</span><br></pre></td></tr></table></figure></p><p>等同于下面的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.txt:</span><br><span class="line">    touch a.txt</span><br><span class="line">b.txt:</span><br><span class="line">    touch b.txt</span><br></pre></td></tr></table></figure></p><p><strong>(2) $&lt;</strong><br>$&lt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么 $&lt; 就指代 p1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt: b.txt c.txt</span><br><span class="line">    cp $&lt; $@</span><br></pre></td></tr></table></figure></p><p>等同于下面的写法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt: b.txt c.txt</span><br><span class="line">    cp b.txt a.txt</span><br></pre></td></tr></table></figure></p><p><strong>(3) $?</strong><br>$? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$? 就指代 p2 。<br><strong>(4) $^</strong><br>$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。<br><strong>(5) $* </strong><br>$<em> 指代匹配符 % 匹配的部分， 比如 % 匹配 f1.txt 中的 f1 ，$\</em> 就表示 f1。<br><strong>(6) $(@D) 和 $(@F)</strong><br>$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@ 是 src/input.c，那么 $(@D) 的值为 src ，$(@F) 的值为 input.c。<br><strong>(7) $(&lt;D) 和 $(&lt;F)</strong><br>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p><p>所有的自动变量清单，请看<a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html" target="_blank" rel="noopener">手册</a>。下面是自动变量的一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dest/%.txt: src/%.txt</span><br><span class="line">@[ -d dest ] || mkdir dest</span><br><span class="line">cp $&lt; $@</span><br></pre></td></tr></table></figure></p><p>上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&lt; 指代前置文件（src/%.txt）， $@ 指代目标文件（dest/%.txt）。</p><h3 id="判断和循环"><a href="#判断和循环" class="headerlink" title="判断和循环"></a>判断和循环</h3><p>Makefile 使用 Bash 语法，完成判断和循环。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(CC),gcc)</span><br><span class="line">  libs=$(libs_for_gcc)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=$(normal_libs)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure></p><p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LIST = one two three</span><br><span class="line">all:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> $(LIST); <span class="keyword">do</span> \</span><br><span class="line">        <span class="built_in">echo</span> $<span class="variable">$i</span>; \</span><br><span class="line">     <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> one two three; <span class="keyword">do</span> \</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$i</span>; \</span><br><span class="line">    <span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>上面代码的运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Makefile 还可以使用函数，格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span> arguments)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="variable">$&#123;function arguments&#125;</span></span><br></pre></td></tr></table></figure></p><p>Makefile 提供了许多<a href="https://www.gnu.org/software/make/manual/html_node/Functions.html" target="_blank" rel="noopener">内置函数</a>，可供调用。下面是几个常用的内置函数。<br><strong>(1) shell 函数</strong><br>shell 函数用来执行 shell 命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srcfiles := $(shell <span class="built_in">echo</span> src/&#123;00..99&#125;.txt)</span><br></pre></td></tr></table></figure></p><p><strong>(2) wildcard 函数</strong><br>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srcfiles := $(wildcard src/*.txt)</span><br></pre></td></tr></table></figure></p><p><strong>(3) subst 函数</strong><br>subst 函数用来文本替换，格式如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(subst from,to,text)</span><br></pre></td></tr></table></figure></p><p>下面的例子将字符串”feet on the street”替换成”fEEt on the strEEt”。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(subst ee,EE,feet on the street)</span><br></pre></td></tr></table></figure></p><p>下面是一个稍微复杂的例子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line"><span class="comment"># space 变量用两个空变量作为标识符，当中是一个空格</span></span><br><span class="line">space:= $(empty) $(empty)</span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= $(subst $(space),$(comma),$(foo))</span><br><span class="line"><span class="comment"># bar is now 'a,b,c'.</span></span><br></pre></td></tr></table></figure></p><p><strong>(4) patsubst 函数</strong><br>patsubst 函数用于模式匹配的替换，格式如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst pattern,replacement,text)</span><br></pre></td></tr></table></figure></p><p>下面的例子将文件名 “x.c.c bar.c”，替换成 “x.c.o bar.o”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst %.c,%.o,x.c.c bar.c)</span><br></pre></td></tr></table></figure></p><p><strong>(5) 替换后缀名</strong><br>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上 patsubst 函数的一种简写形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min: $(OUTPUT:.js=.min.js)</span><br></pre></td></tr></table></figure></p><p>上面代码的意思是，将变量 OUTPUT 中的后缀名 .js 全部替换成 .min.js 。</p><h2 id="Makefile-实例"><a href="#Makefile-实例" class="headerlink" title="Makefile 实例"></a>Makefile 实例</h2><p>(1) 执行多目标编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">        rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">        rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">        rm *.diff</span><br></pre></td></tr></table></figure></p><p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（ cleanall ），删除所有指定类型的文件。<br>(2) 编译 C 语言项目<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o </span><br><span class="line">    cc -o edit main.o kbd.o command.o display.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h</span><br><span class="line">    cc -c display.c</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">     rm edit main.o kbd.o command.o display.o</span><br><span class="line"></span><br><span class="line">.PHONY: edit clean</span><br></pre></td></tr></table></figure></p><p>Make 命令和Makefile文件的介绍就到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间因为工作需要简单学习了一下 make 命令以及 makefile 文件的编写，这里整理一篇在网上看到的比较简洁明了的教程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码变成可执行文件，叫做 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/11/compiler.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;编译&lt;/a&gt;（ compile ）；先编译这个，还是先编译那个（即编译的安排），叫做 &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_build&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;构建&lt;/a&gt;（ build ）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Make_%28software%29&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Make&lt;/a&gt; 是最常用的构建工具，诞生于 1977 年，主要用于 C 语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用 Make 构建。&lt;/p&gt;
&lt;p&gt;本文介绍 Make 命令的用法，从简单的讲起，不需要任何基础，只要会使用命令行，就能看懂。我的参考资料主要是 Isaac Schlueter 的&lt;a href=&quot;https://gist.github.com/isaacs/62a2d1825d04437c6f08&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《 Makefile 文件教程》&lt;/a&gt;和&lt;a href=&quot;https://www.gnu.org/software/make/manual/make.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《 GNU Make 手册》&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;来源： &lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/02/make.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2015/02/make.html&lt;/a&gt;&lt;br&gt;作者： 阮一峰&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="https://blog.strongwong.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="make" scheme="https://blog.strongwong.top/tags/make/"/>
    
      <category term="makefile" scheme="https://blog.strongwong.top/tags/makefile/"/>
    
      <category term="脚本" scheme="https://blog.strongwong.top/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>ROS 基础知识</title>
    <link href="https://blog.strongwong.top//posts/ROS-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
    <id>https://blog.strongwong.top//posts/ROS-基础知识.html</id>
    <published>2018-09-01T02:59:46.000Z</published>
    <updated>2018-09-09T15:56:07.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ROS-基础知识"><a href="#ROS-基础知识" class="headerlink" title="ROS 基础知识"></a>ROS 基础知识</h3><p>上一篇，我们已经正确的安装好了 ROS ，但是在使用 ROS 进行机器人开发工作之前，我们先来了解一点 ROS 的基础知识，以便于后面的开发使用。当然我这里自然是没有 ROS wiki 上介绍的详细，要想学习更多的操作请先看 ROS wiki 上的<a href="http://wiki.ros.org/cn/ROS/StartGuide" target="_blank" rel="noopener">入门教程</a><br>这里我只简单介绍一下，在我的项目中会用到的一些操作。</p><a id="more"></a><h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><p>ROS 使用一个名为 catkin 的 ROS 专用构建系统。为了使用它，用户需要创建并初始化 catkin 工作空间，如下所示。除非用户创建新的工作空间，否则此设置只需设置一次。工作空间（ workspace ）简单来说就是一个存放工程开发相关文件的文件夹。主要目录结构如下：</p><ul><li>src: 代码空间 ( source space )</li><li>build: 编译空间 ( build space )</li><li>devel: 开发空间 ( development space )</li><li>install: 安装空间 ( install space )</li></ul><p><img src="https://ww3.sinaimg.cn/large/005YhI8igy1fuvaso3mffj30lf0jfq3c" alt="catkin 编译系统下的工作空间结构"></p><h4 id="创建工作空间-1"><a href="#创建工作空间-1" class="headerlink" title="创建工作空间"></a>创建工作空间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~/catkin_ws/src   <span class="comment"># 创建工作空间机源码空间</span></span><br><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">$ catkin_init_workspace      <span class="comment"># 初始化工作空间</span></span><br></pre></td></tr></table></figure><h4 id="编译工作空间"><a href="#编译工作空间" class="headerlink" title="编译工作空间"></a>编译工作空间</h4><p>目前，只有 src 目录和 CMakeLists.txt 文件(运行初始化命令后就会生成)在 catkin 工作目录中，即使 src 目录中没有源代码，我们仍然可以使用 catkin_make 命令来进行构建。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure></p><p>如果构建没有问题，运行 ls 命令。除了自己创建的 src 目录之外，还出现了一个新的 build 和 devel 目录。 catkin 的构建系统的相关文件保存在 build 目录中，构建后的可执行文件保存在 devel 目录中。</p><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/catkin_ws/devel/setup.bash</span><br></pre></td></tr></table></figure><h4 id="检查环境变量"><a href="#检查环境变量" class="headerlink" title="检查环境变量"></a>检查环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br><span class="line">/home/ubuntu/catkin_ws/src:/opt/ros/kinetic/share:/opt/ros/kinetic/stacks</span><br></pre></td></tr></table></figure><h3 id="创建功能包"><a href="#创建功能包" class="headerlink" title="创建功能包"></a>创建功能包</h3><p>一个功能包它是是构成 ROS 的基本单元。 ROS 应用程序是以功能包为单位开发的。功能包包括至少一个以上的节点或拥有用于运行其他功能包的节点的配置文件。它还包含功能包所需的所有文件，如用于运行各种进程的 ROS 依赖库、数据集和配置文件等。</p><h4 id="创建功能包-1"><a href="#创建功能包-1" class="headerlink" title="创建功能包"></a>创建功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line"><span class="comment"># 创建功能包命令格式如下：</span></span><br><span class="line">$ catkin_create_pkg [功能包名称] [依赖功能包 1] [依赖功能包 n]</span><br></pre></td></tr></table></figure><p>「catkin_create_pkg」命令在创建用户功能包时会生成 catkin 构建系统所需的 CMakeLists.txt 和 package.xml 文件的包目录。<br><strong>注：同一个工作空间下，不允许存在同名功能包；在不同工作空间下，允许存在同名功能包。</strong></p><h4 id="编译功能包"><a href="#编译功能包" class="headerlink" title="编译功能包"></a>编译功能包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">$ catkin_make</span><br></pre></td></tr></table></figure><h3 id="ROS-通信"><a href="#ROS-通信" class="headerlink" title="ROS 通信"></a>ROS 通信</h3><p>为了最大化用户的可重用性，ROS 是以节点的形式开发的，而节点是根据其目的细分的可执行程序的最小单位。节点则通过消息（ message ）与其他的节点交换数据，最终成为一个大型的程序。这里的关键概念是节点之间的消息通信，它分为三种。单向消息发送/接收方式的话题（ topic ）；双向消息请求/响应方式的服务（ service ）；双向消息目标（ goal ）/结果（ result ）/反馈（ feedback ）方式的动作（ action ）。另外，节点中使用的参数可以从外部进行修改。这在大的框架中也可以被看作消息通信。如下图所示：<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1.jpg" alt=""></p><table><thead><tr><th style="text-align:center">种类</th><th style="text-align:center">区别</th><th style="text-align:center">方向</th><th style="text-align:center">响应</th></tr></thead><tbody><tr><td style="text-align:center">话题</td><td style="text-align:center">异步</td><td style="text-align:center">单向</td><td style="text-align:center">连续单向地发送/接收数据的情况</td></tr><tr><td style="text-align:center">服务</td><td style="text-align:center">同步</td><td style="text-align:center">双向</td><td style="text-align:center">需要对请求给出即时响应的情况</td></tr><tr><td style="text-align:center">动作</td><td style="text-align:center">异步</td><td style="text-align:center">双向</td><td style="text-align:center">请求与响应之间需要太长的时间，所以难以使用服务的情况，或需要中途反馈值的情况</td></tr></tbody></table><h4 id="话题通信"><a href="#话题通信" class="headerlink" title="话题通信"></a>话题通信</h4><p>话题消息通信是指发送信息的发布者和接收信息的订阅者以话题消息的形式发送和接收信息。希望接收话题的订阅者节点接收的是与在主节点中注册的话题名称对应的发布者节点的信息。基于这个信息，订阅者节点直接连接到发布者节点来发送和接收消息。另外，单个发布者可以与多个订阅者进行通信，相反，一个订阅者可以在单个话题上与多个发布者进行通信。当然，这两家发布者都可以和多个订阅者进行通信。</p><h4 id="服务通信"><a href="#服务通信" class="headerlink" title="服务通信"></a>服务通信</h4><p>服务消息通信是指请求服务的服务客户端与负责服务响应的服务服务器之间的同步双向服务消息通信。前述的发布和订阅概念的话题通信方法是一种异步方法，是根据需要传输和接收给定数据的一种非常好的方法。然而，在某些情况下，需要一种同时使用请求和响应的同步消息交换方案。因此，ROS 提供叫做服务的消息同步方法。<br>一个服务被分成服务服务器和服务客户端，其中服务服务器只在有请求（ request ）的时候才响应（response），而服务客户端会在发送请求后接收响应。与话题不同，服务是一次性消息通信。因此，当服务的请求和响应完成时，两个连接的节点将被断开。该服务通常被用作请求机器人执行特定操作时使用的命令，或者用于根据特定条件需要产生事件的节点。由于它是一次性的通信方式，又因为它在网络上的负载很小，所以它也被用作代替话题的手段，因此是一种非常有用的通信手段。</p><h4 id="动作通信"><a href="#动作通信" class="headerlink" title="动作通信"></a>动作通信</h4><p>动作消息通信是在如下情况使用的消息通信方式：服务器收到请求后直到响应所需的时间较长，且需要中途反馈值。这与服务非常相似，服务具有与请求和响应分别对应的目标（ goal ）和结果（ result ）。除此之外动作中还多了反馈（ feedback ）。收到请求后需要很长时间才能响应，又需要中间值时，使用这个反馈发送相关的数据。消息传输方案本身与异步方式的话题（ topic ）相同。反馈在动作客户端（ action client ）和动作服务器（ action server ）之间执行异步双向消息通信，其中动作客户端设置动作目标（ goal ），而动作服务器根据目标执行指定的工作，并将动作反馈和动作结果发送给动作客户端。</p><h3 id="消息通信过程"><a href="#消息通信过程" class="headerlink" title="消息通信过程"></a>消息通信过程</h3><p>主节点管理节点信息，每个节点根据需要与其他节点进行连接和消息通信。以话题消息为例，具体通信步骤如下。</p><h4 id="运行主节点"><a href="#运行主节点" class="headerlink" title="运行主节点"></a>运行主节点</h4><p>节点之间的消息通信当中，管理连接信息的主节点是为使用 ROS 必须首先运行的必需元素。ROS 主节点使用 roscore 命令来运行，并使用 XMLRPC 运行服务器。主节点为了节点与节点的连接，会注册节点的名称、话题、服务、动作名称、消息类型、URI 地址和端口，并在有请求时将此信息通知给其他节点。<br>运行 <code>roscore</code> 命令就启动了主节点。</p><h4 id="运行订阅者节点"><a href="#运行订阅者节点" class="headerlink" title="运行订阅者节点"></a>运行订阅者节点</h4><p>订阅者节点使用 rosrun 或 roslaunch 命令来运行。订阅者节点在运行时向主节点注册其订阅者节点名称、话题名称、消息类型、URI 地址和端口。主节点和节点使用 XMLRPC 进行通信。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun PACKAGE_NAME NODE_NAME</span><br><span class="line">$ roslaunch PACKAGE_NAME LAUNCH_NAME</span><br></pre></td></tr></table></figure></p><h4 id="运行发布者节点"><a href="#运行发布者节点" class="headerlink" title="运行发布者节点"></a>运行发布者节点</h4><p>发布者节点（与订阅者节点类似）使用 rosrun 或 roslaunch 命令来运行。发布者节点向主节点注册发布者节点名称、话题名称、消息类型、 URI 地址和端口。主节点和节点使用 XMLRPC 进行通信。</p><h4 id="通知发布者信息"><a href="#通知发布者信息" class="headerlink" title="通知发布者信息"></a>通知发布者信息</h4><p>主节点向订阅者节点发送此订阅者希望访问的发布者的名称、话题名称、消息类型、 URI 地址和端口等信息。主节点和节点使用 XMLRPC 进行通信。</p><h4 id="订阅者节点的连接请求"><a href="#订阅者节点的连接请求" class="headerlink" title="订阅者节点的连接请求"></a>订阅者节点的连接请求</h4><p>订阅者节点根据从主节点接收的发布者信息，向发布者节点请求直接连接。在这种情况下，要发送的信息包括订阅者节点名称、话题名称和消息类型。发布者节点和订阅者节点使用 XMLRPC 进行通信。</p><h4 id="发布者节点的连接响应"><a href="#发布者节点的连接响应" class="headerlink" title="发布者节点的连接响应"></a>发布者节点的连接响应</h4><p>发布者节点将 TCP 服务器的 URI 地址和端口作为连接响应发送给订阅者节点。发布者节点和订阅者节点使用 XMLRPC 进行通信。</p><h4 id="TCPROS-连接"><a href="#TCPROS-连接" class="headerlink" title="TCPROS 连接"></a>TCPROS 连接</h4><p>订阅者节点使用 TCPROS 创建一个与发布者节点对应的客户端，并直接与发布者节点连接。节点间通信使用一种称为 TCPROS 的 TCP/IP 方式。</p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>发布者节点向订阅者节点发送消息。节点间通信使用一种称为 TCPROS 的 TCP/IP 方式。<br><img src="https://mytu-1252671182.cos.ap-shanghai.myqcloud.com/hexo/%E8%AF%9D%E9%A2%98%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg" alt=""><br>服务消息，服务服务器和客户端之间的连接与上述发布者和订阅者之间的 TCPROS 连接相同，但是与话题不同，服务只连接一次，在执行请求和响应之后彼此断开连接。如果有必要，需要重新连接。<br>动作消息，动作（ action ）在执行的方式上好像是在服务（ service ）的请求（ goal ）和响应( result ）之间仅仅多了中途反馈环节，但实际的运作方式与话题相同。事实上，如果使用 rostopic 命令来查阅话题，那么可以看到该动作的 goal、status、cancel、result 和 feedback 等五个话题。动作服务器和客户端之间的连接与上述发布者和订阅中的 TCPROS 连接相同，但某些用法略有不同。例如，动作客户端发送取消命令或服务器发送结果值会中断连接，等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ROS-基础知识&quot;&gt;&lt;a href=&quot;#ROS-基础知识&quot; class=&quot;headerlink&quot; title=&quot;ROS 基础知识&quot;&gt;&lt;/a&gt;ROS 基础知识&lt;/h3&gt;&lt;p&gt;上一篇，我们已经正确的安装好了 ROS ，但是在使用 ROS 进行机器人开发工作之前，我们先来了解一点 ROS 的基础知识，以便于后面的开发使用。当然我这里自然是没有 ROS wiki 上介绍的详细，要想学习更多的操作请先看 ROS wiki 上的&lt;a href=&quot;http://wiki.ros.org/cn/ROS/StartGuide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;入门教程&lt;/a&gt;&lt;br&gt;这里我只简单介绍一下，在我的项目中会用到的一些操作。&lt;/p&gt;
    
    </summary>
    
      <category term="毕业设计" scheme="https://blog.strongwong.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="学习" scheme="https://blog.strongwong.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ROS" scheme="https://blog.strongwong.top/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>在 Jetson TX2 上安装 ROS 机器人操作系统</title>
    <link href="https://blog.strongwong.top//posts/%E5%9C%A8-Jetson-TX2-%E4%B8%8A%E5%AE%89%E8%A3%85-ROS-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"/>
    <id>https://blog.strongwong.top//posts/在-Jetson-TX2-上安装-ROS-机器人操作系统.html</id>
    <published>2018-08-26T13:17:26.000Z</published>
    <updated>2018-09-09T15:31:35.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ROS-机器人操作系统"><a href="#ROS-机器人操作系统" class="headerlink" title="ROS 机器人操作系统"></a>ROS 机器人操作系统</h3><p>关于 ROS ( Robot Operating System 机器人操作系统)，这里做一下简单的介绍。ROS 就是一个机器人软件平台，类似于个人电脑的操作系统( Windows、Linux、Mac OS 等)，智能手机的操作系统( Android、iOS 等)。机器人和电脑、手机一样可以通过各种硬件组合的硬件模块组成，自然就出现了用来管理这些硬件的操作系统。操作系统提供了基于硬件抽象的软件开发环境，存在提供各种服务的应用程序。<br>ROS 就是这样一个提供了类似操作系统的硬件抽象。在 ROS 维基中将 ROS 定义为 “ ROS 是一个开放源代码的机器人元操作系统。它提供了我们对操作系统期望的服务，包括硬件抽象、低级设备控制、常用功能的实现、进程之间的消息传递以及功能包管理。它还提供了用于在多台计算机之间获取、构建、编写和运行代码的工具和库。 ”<br>因此，ROS 并不是一种新的操作系统，确切的说，ROS 是一种元级操作系统。是基于现有操作系统的，利用应用程序和分布式计算资源之间的虚拟化层来运用分布式计算资源来执行调度、加载、监视、错误处理等任务的系统。同时提供一个或多个操作系统下的数据通信。</p><a id="more"></a><p>对于 ROS 的安装，之前官方网站上是没有中文教程的，对于我这种塑料英语，直接看官网英文教程还是蛮有难度的。不过好在现在 ROS 官网已经有中文版的安装教程了。直接参考官网上的教程安装就好了！<br>官网安装教程：<a href="http://wiki.ros.org/cn/kinetic/Installation" target="_blank" rel="noopener">http://wiki.ros.org/cn/kinetic/Installation</a></p><h3 id="ROS-版本"><a href="#ROS-版本" class="headerlink" title="ROS 版本"></a>ROS 版本</h3><p>虽然官方已经有了中文版本的安装教程，但是我这里还是简单记录一下。<br>首先，ROS 目前大家使用的主流版本还是 ROS 1.0 的版本，ROS 1.0 版本目前只支持 Linux 系统。而对 ROS 兼容性最好的就是 Ubuntu 操作系统了，恰好我们的 Jetson TX2 就是 Ubuntu 系统。</p><p>这里还要说明的是，我们在 TX2 上安装 ROS 系统，并不是要直接在 TX2 上来做开发的(虽然也可以)， TX2 主要是作为部署端的。因此，还需要有一台 Ubuntu 电脑也需要安装上 ROS 来进行开发工作，安装步骤相同。</p><p>其次， Ubuntu 和 ROS 都有很多版本，各版本之间是存在兼容性问题的。ROS 和 Ubuntu 之间的版本对应关系如下表：</p><table><thead><tr><th style="text-align:center">ROS 版本</th><th style="text-align:center">发布日期</th><th style="text-align:center">对应的 Ubuntu 版本</th><th style="text-align:center">停止支持日期</th></tr></thead><tbody><tr><td style="text-align:center">ROS Melodic</td><td style="text-align:center">2018.5.23</td><td style="text-align:center">Ubuntu 18.04(Bionic)/Ubuntu 17.10(Artful)</td><td style="text-align:center">2023.5</td></tr><tr><td style="text-align:center">ROS Lunar</td><td style="text-align:center">2017.5.23</td><td style="text-align:center">Ubuntu 17.04(Zesty)/Ubuntu 16.10(Yakkety)/Ubuntu16.04(Xenial)</td><td style="text-align:center">2019.5</td></tr><tr><td style="text-align:center">ROS Kinetic(推荐)</td><td style="text-align:center">2016.5.23</td><td style="text-align:center">Ubuntu 16.04(Xenial)/Ubuntu 15.10(Wily)</td><td style="text-align:center">2021.4</td></tr><tr><td style="text-align:center">ROS Jade</td><td style="text-align:center">2015.5.23</td><td style="text-align:center">Ubuntu 15.04(Wily)/Ubuntu LTS 14.04(Trusty)</td><td style="text-align:center">2017.5</td></tr><tr><td style="text-align:center">ROS Kinetic</td><td style="text-align:center">2014.7.22</td><td style="text-align:center">Ubuntu LTS 14.04(Trusty)</td><td style="text-align:center">2019.4</td></tr></tbody></table><p>目前主流版本还是 ROS Kinetic 且支持时间较长，今年新出的 Melodic 版资料相对较少。所以推荐安装 ROS Kinetic 版本。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="软件中心配置"><a href="#软件中心配置" class="headerlink" title="软件中心配置"></a>软件中心配置</h4><p>打开软件和更新对话框，配置你的 Ubuntu 软件仓库( repositories )以允许“restricted”，“universe”和“multiverse”这三种安装模式。如下图：<br><img src="https://photo.ishield.cn/pic/5b89420e9dc6d659595a1950" alt=""><br>配置完成关闭窗口。</p><h4 id="添加source-list"><a href="#添加source-list" class="headerlink" title="添加source.list"></a>添加source.list</h4><p>设置你的电脑可以从 packages.ros.org 接收软件。<br>打开一个 Terminal ( Ctrl+Alt+T )，输入以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sh -c &apos;echo “deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc)main”&gt; /etc/apt/sources.list.d/ros-latest.list&apos;</span><br></pre></td></tr></table></figure></p><p>这个镜像国内会比较慢，建议更换为国内镜像源，就是把上面的命令更换一下。官方<a href="http://wiki.ros.org/ROS/Installation/UbuntuMirrors" target="_blank" rel="noopener">镜像</a></p><h4 id="添加密钥"><a href="#添加密钥" class="headerlink" title="添加密钥"></a>添加密钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key adv --keyserver hkp：//ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116</span><br></pre></td></tr></table></figure><p>如果你遇到连接到 keyserver 的问题，你可以在以上命令尝试替换 hkp://pgp.mit.edu:80 或 hkp://keyserver.ubuntu.com:80<br>密钥可以根据服务器的操作发生变更，如有变化，请参考<a href="http://wiki.ros.org/cn/kinetic/Installation/Ubuntu" target="_blank" rel="noopener">官方wiki</a>页面。</p><h4 id="安装-ROS"><a href="#安装-ROS" class="headerlink" title="安装 ROS"></a>安装 ROS</h4><p>首先，确保你的系统软件是最新版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure></p><p>接下来，就可以安装 ROS 了，但是 ROS Kinetic 也有好几个版本，这里我们安装全功能版本(包括ROS、rqt、RViz、机器人相关的库、仿真和导航等等。部署端一般基础版就可以了)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ros-kinetic-desktop-full</span><br></pre></td></tr></table></figure></p><p>这里可能会要等待几分钟，因网速而定。如果一切顺利的话，那就安装完了。<br>安装完成后，可以使用下面的命令查看可使用的软件包(可以搜索到大约1600多个功能包)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache search ros-kinetic</span><br></pre></td></tr></table></figure></p><blockquote><p>如果想个别安装功能包，请使用如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ sudo apt-get install ros-kinetic-[功能包名称]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>现在是安装完了，但是我们还需要初始化 ROS 以及配置环境变量</p><h4 id="初始化-rosdep"><a href="#初始化-rosdep" class="headerlink" title="初始化 rosdep"></a>初始化 rosdep</h4><p>在开始使用 ROS 之前还需要初始化 rosdep 。rosdep 可以方便地在需要编译某些源码的时候为其安装一些系统依赖，同时也是某些 ROS 核心功能组件所必需用到的工具。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rosdep init</span><br><span class="line">$ rosdep update</span><br></pre></td></tr></table></figure></p><h4 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h4><p>如果每次打开一个新的终端时 ROS 环境变量都能够自动配置好(即添加到 bash 会话中)，那将会方便很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;source /opt/ros/kinetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>可以使用 gedit 或者 vi 等编辑器打开 bashrc 文件查看是否配置成功。在 bashrc 文件最底部我们可以看到已经有了很多设置。不要修改以前的设置，如果你需要修改的话在最底部添加就好了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set ROS Kinetic</span></span><br><span class="line"><span class="built_in">source</span> /opt/ros/kinetic/setup.bash</span><br><span class="line"><span class="built_in">source</span> ~/catkin_ws/devel/setup.bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set ROS Network</span></span><br><span class="line"><span class="built_in">export</span> ROS_HOSTNAME=xxx.xxx.xxx.xxx</span><br><span class="line"><span class="built_in">export</span> ROS_MASTER_URI=http://<span class="variable">$&#123;ROS_HOSTNAME&#125;</span>:11311</span><br></pre></td></tr></table></figure></p><h4 id="安装构建依赖"><a href="#安装构建依赖" class="headerlink" title="安装构建依赖"></a>安装构建依赖</h4><p>到目前为止，已经安装了运行核心 ROS 包所需的内容。为了创建和管理自己的 ROS 工作区，有各种各样的工具和需求分别分布。例如：rosinstall 是一个经常使用的命令行工具，它能够轻松地从一个命令下载许多 ROS 包的源树。</p><p>要安装这个工具和其他构建 ROS 包的依赖项，请运行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br></pre></td></tr></table></figure></p><p>好！到这里，ROS 就基本安装完成了。下面就来测试一下，看看是否可以正常运行。</p><h3 id="测试-ROS"><a href="#测试-ROS" class="headerlink" title="测试 ROS"></a>测试 ROS</h3><p>首先，启动 ROS 环境<br>输入 roscore 命令，测试测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ roscore</span><br><span class="line">... logging to /home/ubuntu/.ros/log/3e61b674-03cf-11e8-ac54-9cb70ddc3658/roslaunch-ubuntu-31481.log</span><br><span class="line">Checking log directory for disk usage. This may take awhile.</span><br><span class="line">Press Ctrl-C to interrupt</span><br><span class="line">Done checking log file disk usage. Usage is &lt;1GB.</span><br><span class="line">started roslaunch server http://ubuntu:11311/</span><br><span class="line">ros_comm version 1.12.12</span><br><span class="line">SUMMARY</span><br><span class="line">========</span><br><span class="line">PARAMETERS</span><br><span class="line"> * /rosdistro: kinetic</span><br><span class="line"> * /rosversion: 1.12.12</span><br><span class="line">NODES</span><br><span class="line">auto-starting new master</span><br><span class="line">process[master]: started with pid [31495]</span><br><span class="line">ROS_MASTER_URI=http://ubuntu:11311/</span><br><span class="line">setting /run_id to 3e61b674-03cf-11e8-ac54-9cb70ddc3658</span><br><span class="line">process[rosout-1]: started with pid [31508]</span><br><span class="line">started core service [/rosout]</span><br></pre></td></tr></table></figure></p><p>如果看到 started core service [/rosout] ，那就说明安装成功了！退出按『Ctrl+c』。</p><p>如果你安装过程中出现了问题，可以尝试换个网络，或者多试几次吧，有时候服务器就是连不上！*_*</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ROS-机器人操作系统&quot;&gt;&lt;a href=&quot;#ROS-机器人操作系统&quot; class=&quot;headerlink&quot; title=&quot;ROS 机器人操作系统&quot;&gt;&lt;/a&gt;ROS 机器人操作系统&lt;/h3&gt;&lt;p&gt;关于 ROS ( Robot Operating System 机器人操作系统)，这里做一下简单的介绍。ROS 就是一个机器人软件平台，类似于个人电脑的操作系统( Windows、Linux、Mac OS 等)，智能手机的操作系统( Android、iOS 等)。机器人和电脑、手机一样可以通过各种硬件组合的硬件模块组成，自然就出现了用来管理这些硬件的操作系统。操作系统提供了基于硬件抽象的软件开发环境，存在提供各种服务的应用程序。&lt;br&gt;ROS 就是这样一个提供了类似操作系统的硬件抽象。在 ROS 维基中将 ROS 定义为 “ ROS 是一个开放源代码的机器人元操作系统。它提供了我们对操作系统期望的服务，包括硬件抽象、低级设备控制、常用功能的实现、进程之间的消息传递以及功能包管理。它还提供了用于在多台计算机之间获取、构建、编写和运行代码的工具和库。 ”&lt;br&gt;因此，ROS 并不是一种新的操作系统，确切的说，ROS 是一种元级操作系统。是基于现有操作系统的，利用应用程序和分布式计算资源之间的虚拟化层来运用分布式计算资源来执行调度、加载、监视、错误处理等任务的系统。同时提供一个或多个操作系统下的数据通信。&lt;/p&gt;
    
    </summary>
    
      <category term="毕业设计" scheme="https://blog.strongwong.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="学习" scheme="https://blog.strongwong.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Jetson TX2" scheme="https://blog.strongwong.top/tags/Jetson-TX2/"/>
    
      <category term="ROS" scheme="https://blog.strongwong.top/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Jetson TX2 重新编译内核添加usb等驱动</title>
    <link href="https://blog.strongwong.top//posts/Jetson-TX2-%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%B7%BB%E5%8A%A0usb%E7%AD%89%E9%A9%B1%E5%8A%A8.html"/>
    <id>https://blog.strongwong.top//posts/Jetson-TX2-重新编译内核添加usb等驱动.html</id>
    <published>2018-08-20T10:55:00.000Z</published>
    <updated>2018-08-26T09:26:32.591Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Jetson-TX2-重新编译内核添加usb驱动"><a href="#Jetson-TX2-重新编译内核添加usb驱动" class="headerlink" title="Jetson TX2 重新编译内核添加usb驱动"></a>Jetson TX2 重新编译内核添加usb驱动</h3><p>上一篇我们已经简单说明了怎么给 Jetson TX2 刷机，Jetson TX2 虽然已经成功完成刷机了，但是 Nvidia 的默认配置是禁用了一些驱动的，比如说板子上的 UART 串口就不可以用，需要用户自己安装，重新编译新的镜像。<br>本文这里就简单介绍一下，添加驱动并重新编译镜像。<br>在 GitHub 上有别人开源的编译新镜像的脚本文件，在 Jetsonhacks 的仓库里有。这里我们就使用他的脚本文件。</p><a id="more"></a><h3 id="下载脚本"><a href="#下载脚本" class="headerlink" title="下载脚本"></a>下载脚本</h3><p>首先从 GitHub 上下载编译脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/jetsonhacks/buildJetsonTX2Kernel.git</span><br></pre></td></tr></table></figure></p><p>如果你是 JetPack3.2.1 版本，直接使用 git 下载的话没有问题，因为目前他更新到的最新版本是 JetPack 3.2.1 内核版本为 28.2.1 (2018-8-20)。但是我安装的是 JetPack 3.1 对应的内核版本是 28.1 所以是不能直接使用的。因此需要下载对应的内核版本的脚本才可以使用。<br>JetPack 3.1 版本的话就需要下载这个。<br><code>https://github.com/jetsonhacks/buildJetsonTX2Kernel/archive/vL4T28.1.tar.gz</code></p><h3 id="解压，获取源码"><a href="#解压，获取源码" class="headerlink" title="解压，获取源码"></a>解压，获取源码</h3><p>下载好之后，解压缩，进入解压出来的文件夹，打开 Terminal 运行 getKernelSources.sh 脚本获取内核源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./getKernelSources.sh</span><br></pre></td></tr></table></figure></p><h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><p>下载完成之后就会打开一个 xconfig 配置界面。<br>设置你的镜像名称。打开设置 Genral Setup-&gt;Local version - append to kernel release，双击 Local version - append to kernel release<br>在文本框中输入名字，如我这里为 -jetsonbot-v0.1 ， 回车；如下图所示：<br><img src="https://photo.ishield.cn/pic/5b8269849dc6d6533b592669" alt=""></p><p>在 xconfig 中按 Ctrl+F ，会弹出一个搜索框，输入你想要添加的设备驱动，比如可以添加 USB ACM， CH341 和 cp210x 串口驱动等，在搜索结果中选择对应的驱动，选中框打上勾即可。<br>我这里搜索的是 ACM 驱动，如下图所示：<br><img src="https://photo.ishield.cn/pic/5b826b089dc6d6533b59266f" alt=""></p><p>设置好了之后，一定要保存你的设置， File-&gt;Save</p><h3 id="编译新内核"><a href="#编译新内核" class="headerlink" title="编译新内核"></a>编译新内核</h3><p>保存好设置，关闭 xconfig 配置窗口，准备开始编译内核，编译过程大约需要 20 分钟。<br>运行 makeKernel.sh 脚本，开始编译新的内核。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./makeKernel.sh</span><br></pre></td></tr></table></figure></p><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>编译过程中，你可以去喝杯 coffee 放松一下，等待编译完成。<br>编译结束后，运行 copyImage.sh 脚本，将新编译的镜像文件拷贝到  /boot 目录下。拷贝完成重启 TX2 即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./copyImage.sh</span><br><span class="line">$ reboot</span><br></pre></td></tr></table></figure></p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>至此，我们添加有 USB 串口相关驱动的镜像就在 TX2 上被安装好了，这样就可以愉快的使用串口了。快使用新镜像进行开发吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Jetson-TX2-重新编译内核添加usb驱动&quot;&gt;&lt;a href=&quot;#Jetson-TX2-重新编译内核添加usb驱动&quot; class=&quot;headerlink&quot; title=&quot;Jetson TX2 重新编译内核添加usb驱动&quot;&gt;&lt;/a&gt;Jetson TX2 重新编译内核添加usb驱动&lt;/h3&gt;&lt;p&gt;上一篇我们已经简单说明了怎么给 Jetson TX2 刷机，Jetson TX2 虽然已经成功完成刷机了，但是 Nvidia 的默认配置是禁用了一些驱动的，比如说板子上的 UART 串口就不可以用，需要用户自己安装，重新编译新的镜像。&lt;br&gt;本文这里就简单介绍一下，添加驱动并重新编译镜像。&lt;br&gt;在 GitHub 上有别人开源的编译新镜像的脚本文件，在 Jetsonhacks 的仓库里有。这里我们就使用他的脚本文件。&lt;/p&gt;
    
    </summary>
    
      <category term="毕业设计" scheme="https://blog.strongwong.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="学习" scheme="https://blog.strongwong.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Jetson TX2" scheme="https://blog.strongwong.top/tags/Jetson-TX2/"/>
    
      <category term="Nvidia" scheme="https://blog.strongwong.top/tags/Nvidia/"/>
    
      <category term="内核编译" scheme="https://blog.strongwong.top/tags/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/"/>
    
      <category term="驱动" scheme="https://blog.strongwong.top/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Nvidia Jetson TX2 刷机并安装JetPack3.1</title>
    <link href="https://blog.strongwong.top//posts/Nvidia-Jetson-TX2-%E5%88%B7%E6%9C%BA%E5%B9%B6%E5%AE%89%E8%A3%85JetPack3.1.html"/>
    <id>https://blog.strongwong.top//posts/Nvidia-Jetson-TX2-刷机并安装JetPack3.1.html</id>
    <published>2018-08-12T12:15:29.000Z</published>
    <updated>2018-08-20T10:50:08.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nvidia-Jetson-TX2-刷机并安装-JetPack3-1"><a href="#Nvidia-Jetson-TX2-刷机并安装-JetPack3-1" class="headerlink" title="Nvidia Jetson TX2 刷机并安装 JetPack3.1"></a>Nvidia Jetson TX2 刷机并安装 JetPack3.1</h2><p>上篇，我已经简单介绍了一下我的整个小车的物理框架和软件架构。下面我可能会分成几次推文，介绍一下搭建小车的具体过程。<br>本次主要记录一下给 Nvidia Jetson TX2 开发板刷机的过程。</p><a id="more"></a><h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><p>1.一块Jetson TX2 开发板</p><p>2.一台安装 Ubuntu 系统的独立主机(不建议使用虚拟机，推荐使用 Ubuntu 16.04)</p><p>3.一台路由器</p><p>4.两根网线，一根 micro usb 数据线</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1.首先需要从 Nvidia 的官方网站上下载 Jet Pack3.1 的安装包，使用 Ubuntu host 直接下载或者下载好拷贝到 host 上也可以。(我当时最新的是 Jet Pack3.1 ，现在已经到 3.3 了，你也可以使用最新的版本。下载的话需要 Nvidia 账号才可以)<br>下载网址：<a href="https://developer.nvidia.com/embedded/jetpack" target="_blank" rel="noopener">https://developer.nvidia.com/embedded/jetpack</a></p><p>2.将 TX2 开发板和主机都通过网线连接到一台路由器上。准备好 TX2 开发板和 Ubuntu Host 之后就可以开始刷机了。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载好 Jet Pack3.1 安装包后，打开 Terminal 进入到安装包所在的目录，执行下面这条命令运行安装包。运行效果如下图。(如果文件没有执行权限可以使用 chmod -x file 命令来改变执行权限)</p><p><code>$ ./JetPack-L4T-3.1-linux-x64.run</code></p><p>运行完会弹出 JetPack L4T 3.1 Installer, 一路 Next 就好，如下图：<br><img src="https://files.catbox.moe/n9dnwk.png" alt=""></p><p>注意选择 Jetson TX2 开发板<br><img src="https://photo.ishield.cn/pic/5b702af99dc6d6522bb72f67" alt=""></p><p>点击 Next 之后会提示输入密码，待安装完成后，就会进入 JetPack L4T Component Manager。(这里要注意，如果网络不好可能会要等很久也出不来安装包信息，所以一定要保证网络环境好，可能有一些包还需要科学上网。)<br>如果你的包加载好了，检查一下 CUDA Toolkit 和 OpenCV for Tegra 这两个包是否选择了，这两个一定要安装。选择好之后，点击 Next 。在弹出的弹框中勾选所有协议，等待各种包下载完成。<br><img src="https://photo.ishield.cn/pic/5b702c3e9dc6d6522bb72f6c" alt=""><br><img src="https://photo.ishield.cn/pic/5b702b289dc6d6522bb72f68" alt=""></p><p>下载完成后，选择 Host 和 TX2 的连接方式，我们选择第一项，通过同一路由器连接在同一网络。网口选择保持默认就好。<br><img src="https://files.catbox.moe/hvd0oi.png" alt=""></p><p>接下来就是将包移动到 TX2 开发板上。文件较大，可能要等一会。执行下一步后，会出现一个提示重启 TX2 的步骤。按照提示进行操作。</p><p>第一步，将 TX2 关机， 拔下电源，使用 micro usb 数据线将 TX2 与 Host 相连。</p><p>第二步，重新插上电源，启动 TX2 ，同时按住 rec 和 rst 两个按键两秒钟， 然后松开 rst 按键，按住 rec 按键 3 秒钟。</p><p>第三步，这时在 Host 端，重新打开一个 terminal，查看 usb 端口信息(使用命令 lsusb 就可以查看)，这时应该就可以看 ID 为 0955:7C18 的叫 Nvidia Corp 的端口，就说明 TX2 已经进入 REC 模式并和 host 连接好了，这时回到有重启步骤的窗口，按回车 Enter，就开始 TX2 固件更新了。<br><img src="https://photo.ishield.cn/pic/5b702bda9dc6d6522bb72f6a" alt=""><br><img src="https://photo.ishield.cn/pic/5b702bf19dc6d6522bb72f6b" alt=""></p><p>安装完成后 TX2 就会重新启动，然后接下来会进行 CUDA 等一些软件的安装。</p><p>至此，Nvidia TX2 的安装就基本完成了。就可以愉快的在 Jetson TX2 上进行开发啦！</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>在 TX2 上进行基本开发的环境就已经基本搭建好了，但是大型的开发可能 TX2 本身自带的 30 多个 G 内存可能是不够的，因此我们可能还需要一个容量较大的 SSD 来放系统。还有就是 TX2 开发板默认的镜像设置可能会有一些端口没有开放，为了跟好的开发，所以后面需要我们自己重新编译镜像。这些在后面我会继续介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nvidia-Jetson-TX2-刷机并安装-JetPack3-1&quot;&gt;&lt;a href=&quot;#Nvidia-Jetson-TX2-刷机并安装-JetPack3-1&quot; class=&quot;headerlink&quot; title=&quot;Nvidia Jetson TX2 刷机并安装 JetPack3.1&quot;&gt;&lt;/a&gt;Nvidia Jetson TX2 刷机并安装 JetPack3.1&lt;/h2&gt;&lt;p&gt;上篇，我已经简单介绍了一下我的整个小车的物理框架和软件架构。下面我可能会分成几次推文，介绍一下搭建小车的具体过程。&lt;br&gt;本次主要记录一下给 Nvidia Jetson TX2 开发板刷机的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="毕业设计" scheme="https://blog.strongwong.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="学习" scheme="https://blog.strongwong.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Jetson TX2" scheme="https://blog.strongwong.top/tags/Jetson-TX2/"/>
    
      <category term="Nvidia" scheme="https://blog.strongwong.top/tags/Nvidia/"/>
    
      <category term="刷机" scheme="https://blog.strongwong.top/tags/%E5%88%B7%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>我的毕业设计--基于ROS的移动机器人</title>
    <link href="https://blog.strongwong.top//posts/%E6%88%91%E7%9A%84%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8EROS%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA.html"/>
    <id>https://blog.strongwong.top//posts/我的毕业设计-基于ROS的移动机器人.html</id>
    <published>2018-08-12T11:45:32.000Z</published>
    <updated>2018-08-20T10:38:36.963Z</updated>
    
    <content type="html"><![CDATA[<p>在做毕设的时候就有这个想法，想把毕设过程中学到的和遇到坑全都一点点的记录下来。但是由于毕设时间也比较紧张，又要上班，所以一直拖到现在也没有写些什么。好在最近毕设也答辩结束了，也毕业了，稍稍轻松了一些，准备最近花一些时间来整理一些毕设的东西，写几篇文字记录一下。接下来整体介绍一下这个机器人。</p><a id="more"></a><p>简单来说，我的毕设就是做一个可以进行室内 SLAM 建图的移动机器人。首先呢，我把我的机器人分为上层和底层两个部分。上层为决策层，主要是在 Jetson TX2 开发板上，运行 ROS 机器人操作系统以及 SLAM 算法。通过激光雷达或者深度相机获取深度数据，进行机器人的同时定位与地图构建。底层为具体的控制层，主要是 STM32 通过串口通讯与上层进行通信，接收决策层的速度控制指令，以及进行电机速度控制。机器人的系统框架如下图所示。</p><p><img src="https://ww3.sinaimg.cn/large/005YhI8igy1fugcmx4e46j30m90d8mys" alt=""><br><img src="https://ww3.sinaimg.cn/large/005YhI8igy1fugcnqpd93j30rk0g2ju9" alt=""></p><p>各部分的具体介绍，将在后面我有空的时候慢慢更新，哈哈哈~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做毕设的时候就有这个想法，想把毕设过程中学到的和遇到坑全都一点点的记录下来。但是由于毕设时间也比较紧张，又要上班，所以一直拖到现在也没有写些什么。好在最近毕设也答辩结束了，也毕业了，稍稍轻松了一些，准备最近花一些时间来整理一些毕设的东西，写几篇文字记录一下。接下来整体介绍一下这个机器人。&lt;/p&gt;
    
    </summary>
    
      <category term="毕业设计" scheme="https://blog.strongwong.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="学习" scheme="https://blog.strongwong.top/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ROS" scheme="https://blog.strongwong.top/tags/ROS/"/>
    
      <category term="机器人" scheme="https://blog.strongwong.top/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>读书</title>
    <link href="https://blog.strongwong.top//posts/%E8%AF%BB%E4%B9%A6.html"/>
    <id>https://blog.strongwong.top//posts/读书.html</id>
    <published>2018-08-08T10:20:19.000Z</published>
    <updated>2018-10-04T12:25:51.744Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间，自己陆陆续续收集和整理了，好多电子书，还买了一个Kindle。也买了好些书，可是到现在也没看几本。下半年还是要多读书，多写字，多赚钱！</p><p>这里简单列一下我的书单，我兴趣爱好广泛，所以读的书也就比较杂，姑且就简单分为两类吧！技术类的和消遣的书吧。</p><a id="more"></a><h3 id="技术类："><a href="#技术类：" class="headerlink" title="技术类："></a>技术类：</h3><h4 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h4><ul><li style="list-style: none"><input type="checkbox" checked> OpenCV3编程入门</li><li style="list-style: none"><input type="checkbox" checked> 低功耗蓝牙开发权威指南</li><li style="list-style: none"><input type="checkbox" checked> Cortex-M3权威指南</li></ul><h4 id="在读"><a href="#在读" class="headerlink" title="在读"></a>在读</h4><ul><li style="list-style: none"><input type="checkbox"> C和指针</li><li style="list-style: none"><input type="checkbox"> C专家编程</li><li style="list-style: none"><input type="checkbox"> C陷阱与缺陷</li></ul><h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><ul><li style="list-style: none"><input type="checkbox"> C++沉思录</li><li style="list-style: none"><input type="checkbox"> 深入理解计算机系统</li><li style="list-style: none"><input type="checkbox"> 程序员的数学 1，2，3</li><li style="list-style: none"><input type="checkbox"> 信息简史</li><li style="list-style: none"><input type="checkbox"> 大话设计模式</li><li style="list-style: none"><input type="checkbox"> 计算机原理与设计：Verilog HDL版</li><li style="list-style: none"><input type="checkbox"> 经典算法大全</li><li style="list-style: none"><input type="checkbox"> 算法导论</li></ul><h3 id="消遣类："><a href="#消遣类：" class="headerlink" title="消遣类："></a>消遣类：</h3><h4 id="已读-1"><a href="#已读-1" class="headerlink" title="已读"></a>已读</h4><ul><li style="list-style: none"><input type="checkbox" checked> 他改变了中国</li><li style="list-style: none"><input type="checkbox" checked> 人类简史</li><li style="list-style: none"><input type="checkbox" checked> 三体 I</li></ul><h4 id="在读-1"><a href="#在读-1" class="headerlink" title="在读"></a>在读</h4><ul><li style="list-style: none"><input type="checkbox"> 浪潮之巅</li><li style="list-style: none"><input type="checkbox"> 太阳的距离</li><li style="list-style: none"><input type="checkbox"> 数学之美</li></ul><h4 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h4><ul><li style="list-style: none"><input type="checkbox"> 未来简史</li><li style="list-style: none"><input type="checkbox"> 三体: 黑暗森林</li><li style="list-style: none"><input type="checkbox"> 宇宙最初三分钟</li><li style="list-style: none"><input type="checkbox"> 爱因斯坦传</li><li style="list-style: none"><input type="checkbox"> Alibaba 2017技术集锦</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间，自己陆陆续续收集和整理了，好多电子书，还买了一个Kindle。也买了好些书，可是到现在也没看几本。下半年还是要多读书，多写字，多赚钱！&lt;/p&gt;
&lt;p&gt;这里简单列一下我的书单，我兴趣爱好广泛，所以读的书也就比较杂，姑且就简单分为两类吧！技术类的和消遣的书吧。&lt;/p&gt;
    
    </summary>
    
      <category term="读书" scheme="https://blog.strongwong.top/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="https://blog.strongwong.top/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="学习" scheme="https://blog.strongwong.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>strongwongのdiary</title>
    <link href="https://blog.strongwong.top//posts/strongwong%E3%81%AEdiary.html"/>
    <id>https://blog.strongwong.top//posts/strongwongのdiary.html</id>
    <published>2018-08-08T06:58:54.000Z</published>
    <updated>2018-10-07T06:54:25.910Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一下我每天搞了什么。成长之路，点滴记录！</p><h3 id="2018-8-1-8-5"><a href="#2018-8-1-8-5" class="headerlink" title="2018-8-1~8-5"></a>2018-8-1~8-5</h3><p>1.搭建了博客，学习了 MarkDown 语法规则，学习用 MarkDown 来写作。<br>2.测试 UlpBench<br>3.移植 UlpBench 部分代码到 M3 上运行，测试功耗<br>4.测试单指令差异<br>5.整理分析测试数据</p><a id="more"></a><h3 id="2018-8-6"><a href="#2018-8-6" class="headerlink" title="2018-8-6"></a>2018-8-6</h3><p>1.阅读整理 Event Arbiter 代码，分析链路层和事件仲裁器之间的关系<br>2.看了很多大佬的博客，调整了博客的一些设置</p><h3 id="2018-8-8"><a href="#2018-8-8" class="headerlink" title="2018-8-8"></a>2018-8-8</h3><p>1.今天还是在看 Event Arbiter 的代码和文档资料。<br>2.尝试性的把 Event Arbiter 的部分代码进行了移植，但是没跑通，还要很多问题，明天继续解决。进展有点慢，测试方案还不知道怎么弄 <em>_</em><br>3.十年前的今天奥运会开幕了，我在家看奥运会；今天的我大学毕业了，在这里敲代码；十年后的我怎么样了，我会在干什么？<br>4.博客还是要坚持写，加油！</p><h3 id="2018-8-9"><a href="#2018-8-9" class="headerlink" title="2018-8-9"></a>2018-8-9</h3><p>1.今天还是搞 EA 这个东西，没什么进展，难受！<br>2.领导让写一个 CM3 进 sleep 的代码，写了，内存中对应的位也写入值了，但是 J-link 还是可以正常连接，有很多东西好像并没有关掉，怀疑是设计的 SOC 有问题。</p><h3 id="2018-8-10"><a href="#2018-8-10" class="headerlink" title="2018-8-10"></a>2018-8-10</h3><p>1.我昨天给领导写的代码应该是没问题的，只是 FPGA 上不能进行这样的调试。但是还是有一些问题，比如说中断使能没做，也没有 rtc 或者 wakeup 的功能，还需要增加。<br>2.EA 的大部分功能都已经移植好了，但是和底层相关的定时器我没有，还是有问题，不能进行正常调试。然后就是 EA 的整个测试流程怎么搞，我还不太明白，对单个函数的测好做，但是如果要测试多个事件的仲裁，测试 EA 的完整功能还不知道怎么弄。可能我需要有一个简单的任务切换，每个任务里请求一个事件，然后有 EA 来进行判断和仲裁。</p><h3 id="2018-8-13"><a href="#2018-8-13" class="headerlink" title="2018-8-13"></a>2018-8-13</h3><p>1.继续搞 EA ，底层的一些时间相关的寄存器我打算使用 Systick 和 Timer 结合起来模拟。但是还有一些问题，还需要解决。<br>2.今天戚博有给了一个另外的任务，需要我在服务器上使用 arm-none-eabi-gcc 来做开发。让我写一套 Makefile ，虽然我之前有简单使用过 Makefile 、make ，但是我还没弄过这种相对大一些的项目的编译、开发。我找了些 makefile 的文档来学习，看看 Makefile 该怎么写。</p><h3 id="2018-8-14"><a href="#2018-8-14" class="headerlink" title="2018-8-14"></a>2018-8-14</h3><p>1.学习 Linux 下面的开发，学习 Makefile 的编写。了解补充一些编译、链接相关的知识，熟悉一下 GUN 相关的工具链。<br>2.整理我之前写的代码，今天发现之前写的还是有一些问题，做了很多调整，今天主要调整了 UART 相关的代码。明天可能还需要把 timer 、 gpio 的代码做一些调整。然后往服务器上迁移。</p><h3 id="2018-8-26"><a href="#2018-8-26" class="headerlink" title="2018-8-26"></a>2018-8-26</h3><p>1.前段时间回家了一个多星期，断更了。现在回来了，接着写。<br>2.今天整理了一下关于 Jetson TX2 内核重新编译的东西，写了一篇博文。<br>3.请假之前领导让写 Makefile ，做一个使用 arm-none-eabi-gcc 在 Linux 下编译的版本。回来这几天搞完了。 在 Cygwin 下的编译 stm32 还是有点问题，还需要修改。</p><h3 id="2018-8-31"><a href="#2018-8-31" class="headerlink" title="2018-8-31"></a>2018-8-31</h3><p>1.仔细看了一些 Makefile 文件的编写规则，解决了编译问题。<br>2.当当网有购书优惠，屯了 10 本技术相关的书籍。</p><h3 id="2018-9-5"><a href="#2018-9-5" class="headerlink" title="2018-9-5"></a>2018-9-5</h3><p>今天突然发现不能上 Google 学习了，很尴尬，迅速寻找解决方案！成功切换到 v2ray 了上。哈哈，又可以愉快的学习了。</p><h3 id="2018-9-15"><a href="#2018-9-15" class="headerlink" title="2018-9-15"></a>2018-9-15</h3><p>1.又有好几天没有更新了，最近对无线电有了很大兴趣。于是前些天买了一个 RTL_SDR 鼓捣了一下软件无线电。挺好玩的~<br>2.和做基带的同学，做了一些沟通，配合他们做一下 BB 的测试。</p><h3 id="2018-9-20"><a href="#2018-9-20" class="headerlink" title="2018-9-20"></a>2018-9-20</h3><ol><li>ea 的基本测试做了一些，还没做完。</li><li>在和戚博的讨论过程中发现了我之前写的代码有一些不太合理的地方。缺乏面向对象的思想，代码没有很好的做到低耦合。需要做一些改动。</li></ol><h3 id="2018-10-6"><a href="#2018-10-6" class="headerlink" title="2018-10-6"></a>2018-10-6</h3><p>给博客增加了 Google Adsense ，文章下面会有 Google 广告，点击广告就会有一定的收益！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单记录一下我每天搞了什么。成长之路，点滴记录！&lt;/p&gt;
&lt;h3 id=&quot;2018-8-1-8-5&quot;&gt;&lt;a href=&quot;#2018-8-1-8-5&quot; class=&quot;headerlink&quot; title=&quot;2018-8-1~8-5&quot;&gt;&lt;/a&gt;2018-8-1~8-5&lt;/h3&gt;&lt;p&gt;1.搭建了博客，学习了 MarkDown 语法规则，学习用 MarkDown 来写作。&lt;br&gt;2.测试 UlpBench&lt;br&gt;3.移植 UlpBench 部分代码到 M3 上运行，测试功耗&lt;br&gt;4.测试单指令差异&lt;br&gt;5.整理分析测试数据&lt;/p&gt;
    
    </summary>
    
      <category term="diary" scheme="https://blog.strongwong.top/categories/diary/"/>
    
    
      <category term="diary" scheme="https://blog.strongwong.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>使用 Hexo+Github Pages 搭建个人博客</title>
    <link href="https://blog.strongwong.top//posts/%E4%BD%BF%E7%94%A8Hexo-GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95.html"/>
    <id>https://blog.strongwong.top//posts/使用Hexo-GitHub-Pages搭建个人博客记录.html</id>
    <published>2018-08-02T13:22:50.000Z</published>
    <updated>2018-09-03T03:28:20.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-Hexo-Github-Pages-搭建个人博客记录"><a href="#使用-Hexo-Github-Pages-搭建个人博客记录" class="headerlink" title="使用 Hexo+Github Pages 搭建个人博客记录"></a>使用 Hexo+Github Pages 搭建个人博客记录</h2><p>最近在学习的时候发现很多人都推荐说，要学会写作。很多大牛都会有自己的博客，或者微信公众号。不仅要学会学习，更要学会表达，而写作就是一个很好的方式。通过把自己学到的东西再次输出出来，才有价值，写作是一个人吸收知识，并增强记忆转化成自己东西的过程。很多人认为学校里出来了之后应该会很少写文字了，其实不然，在工作中经常会有各种各样的汇报和报告需要你去写。<br>如果你不经常去写一些文字，慢慢的也就生疏了，也就忘了该怎么通过书面方式更好的表达信息。比如我们领导让大家每周写一份周报，每到周五的时候大家总是在纠结，这周报该怎么写。还有做测试的时候要有测试方案，测试结果，测试报告（分析）都是要写文档的。跟文字打交道的时候还是很多的啊！所以啊，平时还得多写写！</p><a id="more"></a><p>我在看一些大牛的博客的时候，发现他们的博客，好像都很好看。我很羡慕，于是我也想搭建一个自己的个人博客，所以就有了本站！<br>我了解到建站的方法有很多，比如:</p><ul><li>Hexo + GitHub Pages</li><li>Jekyll + GitHub Pages </li><li>WordPress + 服务器 + 域名</li><li>DeDeCMS + 服务器 + 域名</li><li>……</li></ul><p>我选择了使用 Hexo + GitHub Pages + 域名 的方法来建站。<br>首先 Hexo 简约风格我很喜欢，其次利用 GitHub Pages 的免费存储空间不需要自己购买服务器，<br>有一个 GitHub 账号就 ok 了，然后域名其实是一个可选项，GitHub 会提供一个 <a href="http://xxxx.github.io/" target="_blank" rel="noopener">http://xxxx.github.io/</a> 这种形式的域名进行访问。</p><h2 id="下面来简单记录一下，本站的搭建过程"><a href="#下面来简单记录一下，本站的搭建过程" class="headerlink" title="下面来简单记录一下，本站的搭建过程"></a>下面来简单记录一下，本站的搭建过程</h2><p>安装 Hexo 很简单，但是在安装前需要配置一些环境，需要安装 Node.js 和 Git 。因为 Hexo 博客系统是基于 Node.js 写的，需要 Node.js 的环境才能运行。 Hexo 运行之后会在本地生成网页，所以我们需要使用 Git 把本地网页文件上传到 GitHub 上的远程仓库里。（当然使用 GitHub 桌面版也可以上传。）</p><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>在 Node.js 官网：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载最新的稳定版，安装时保持默认设置，一路 next 就好，等待安装完成。<br>安装好之后，按<code>Win+R</code>,输入 <code>cmd</code>，运行命令提示符，输入<code>node -v</code>和 <code>nmp -v</code>，如果出现版本号，那么就安装成功了。<br><img src="https://photo.ishield.cn/pic/5b8ca1e59dc6d611b60ee2bd" alt="node -v npm -v"></p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><p>去 Git 官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a> 下载最新的稳定版的 git 安装包，直接默认配置安装就好了，一路 next 就好。<br><img src="https://photo.ishield.cn/pic/5b8ca4519dc6d611b60ee2d1" alt="git"><br>安装完成后，在桌面右键，点击<code>Git Bush Here</code>，输入 <code>git --version</code>，如果成功出现 Git 的版本号，到这里 Git 的环境配置就完成了！（如果你对 Git 不太熟悉，不太会用 Git 来上传你的博客，你也可以考虑使用 GitHub 的桌面版。）<br><img src="https://ww3.sinaimg.cn/large/005YhI8igy1fuw5x63irrj30630a0gln" alt=""></p><h2 id="注册-GitHub-和配置"><a href="#注册-GitHub-和配置" class="headerlink" title="注册 GitHub 和配置"></a>注册 GitHub 和配置</h2><p>身为一个程序员，怎么能不知道 GitHub！每个程序员都应该有一个 GitHub 账号！GitHub是一个大型的代码托管平台，上面有很多技术大牛，也有很多有趣的开源项目，像Google、FaceBook、Macrosoft 等大公司也都在使用 GitHub。我们的博客就是托管在 GitHub 上的。</p><p>GitHub Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默认提供的域名 github.io 或者使用自定义域名来发布站点。</p><p>如果你还没有 Github 账号的话，需要先到 GitHub 官网进行注册： <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> </p><p>注册完成之后，我们需要创建一个仓库来存放我们的博客。新建一个项目，如下图所示：<br><img src="https://photo.ishield.cn/pic/5b8ca25b9dc6d611b60ee2c3" alt=""><br>仓库名称一般使用用户名加 <code>.github.io</code>后缀，如下图所示：<br><img src="https://photo.ishield.cn/pic/5b8ca2889dc6d611b60ee2c5" alt=""><br>最后，创建完成后，就可以直接访问 <a href="https://yourname.github.io/" target="_blank" rel="noopener">https://yourname.github.io/</a> ,如果可以正常访问，那么 GitHub 的配置就搞完了。<br>到这里环境就基本上搭好了，下面就开始安装 Hexo 正式搭建个人博客。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>Hexo 是什么？<br>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown (或者其他渲染引擎)解析文章，在几秒内，即可利用靓丽的主题生成静态网页。并且一条指令即可部署到 GitHub Pages 或者其他网站。想更多了解 Hexo 请阅读 Hexo 官方文档: <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><p>首先，在你的电脑里，新建一个文件夹专门用来存放你的博客文件。比如我的都放在 D:\study\hexo 目录下。</p><p>然后在该目录下，右键点击 <code>Git Bush Here</code>，打开 Git 控制台窗口，接下来的操作都在 Git 控制台进行，反正我是挺喜欢敲命令行的感觉。</p><p>接下来，在该目录下，输入 <code>npm install -g hexo-cli</code>，安装 Hexo ，这里会有一个 <code>WARN</code>，不用担心这不会影响正常使用。然后在安装 Hexo 部署到 Github Pages 的 deployer。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli </span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p><img src="https://photo.ishield.cn/pic/5b8ca2ae9dc6d611b60ee2c6" alt=""></p><p>查看 Hexo 的版本，输入 <code>hexo -v</code>，正确输入如下信息就表示 Hexo 安装成功了。<br><img src="https://ww3.sinaimg.cn/large/005YhI8igy1fuw600gjbcj30gz0de74s" alt=""></p><h2 id="Hexo基础配置"><a href="#Hexo基础配置" class="headerlink" title="Hexo基础配置"></a>Hexo基础配置</h2><p>Hexo 安装完成后，执行下面的命令来初始化 Hexo ，对应的用户名(文件夹名称)改成自己的。Hexo 会在指定的文件夹中新建博客系统，和安装必备组件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init strongwong.github.io</span><br><span class="line">$ <span class="built_in">cd</span> strongwong.github.io</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p><img src="https://photo.ishield.cn/pic/5b8ca2f39dc6d611b60ee2c8" alt=""></p><p>新建完成后，在本地运行 Hexo 查看效果:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate<span class="comment">#或者运行 hexo g 根据配置生成博客</span></span><br><span class="line">$ hexo server<span class="comment">#或者运行 hexo s 在本地运行 Hexo 登录 localhost:4000 查看</span></span><br><span class="line"><span class="comment">#按 ctrl + c 即可关闭本地服务器</span></span><br></pre></td></tr></table></figure><p>这时我们到浏览器中输入 <code>localhost:4000</code> 就可以在本地端正常访问了(如下图)，这样的话就说明博客已经打起来了，但是现在只是在本地，别人还不能访问，接下来我们就要把本地博客部署到 GitHub 上，让别人也可以看到你的博客。<br><img src="https://photo.ishield.cn/pic/5b8ca3139dc6d611b60ee2cc" alt=""></p><h2 id="本地-Hexo-仓库与-GitHub-关联"><a href="#本地-Hexo-仓库与-GitHub-关联" class="headerlink" title="本地 Hexo 仓库与 GitHub 关联"></a>本地 Hexo 仓库与 GitHub 关联</h2><p>配置 GitHub 的 SSH 密钥，让本地项目通过 git 命令与远程 GitHub 仓库建立联系，我们在本地做了修改之后直接通过 git 命令就可以把博客同步到 GitHub 上。</p><p>1.首先，在 git 控制台中，输入如下命令，配置个人参数(你的名字，你的邮箱)。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">$ git config --global user.email <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure></p><p>2.接下来生成 SSH key 根据提示进行操作(其实一路回车就好了。)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure></p><p>3.执行完之后就会在默认路径下生成 <code>id_rsa.pub</code>文件。默认路径是：<code>C:\Users\Administrator\.ssh\id_rsa.pub</code> 需要注意的是 .ssh 是隐藏文件夹。<br>使用记事本打开这个文件，复制文件内容，然后粘贴到 <a href="https://github.com/settings/ssh/" target="_blank" rel="noopener">https://github.com/settings/ssh/</a> 的 “new SSH key” 中。</p><p>4.输入下面的命令，查看 SSH 是否配置成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>如果是下面的反馈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p><p>直接输入 yes 就好了，然后就会看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi strongwong! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure></p><p>这样的话，我们 SSH key 就配置成功了。</p><p>5.配置 deploy 参数<br>在博客根目录下，找到 <code>__config.yml</code> 文件，找到 deploy 关键字，进行如下配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:strongwong/strongwong.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>6.将本地博客提交到 GitHub Pages<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g<span class="comment">#根据你的改动生成新的静态文件(即 public 文件夹)</span></span><br><span class="line">$ hexo s<span class="comment">#启动本地预览 ctrl + c 关闭</span></span><br><span class="line">$ hexo d<span class="comment">#部署到远程站点</span></span><br><span class="line">$ hexo clean<span class="comment">#清除旧的静态文件(即 public 文件夹)</span></span><br></pre></td></tr></table></figure></p><p>7.这时在浏览器输入 <a href="https://strongwong.github.io/" target="_blank" rel="noopener">https://strongwong.github.io/</a> ，可以正常访问就说明 hexo 搭建的博客已经成功部署到 GitHub 了，小伙伴们都可以通过这个地址访问自己的博客了。</p><h2 id="将个人域名解析到-GitHub"><a href="#将个人域名解析到-GitHub" class="headerlink" title="将个人域名解析到 GitHub"></a>将个人域名解析到 GitHub</h2><p>看着这个 GitHub 下面的二级域名，总觉得让人不太爽，所以有很多小伙伴都买了自己的域名，然后将自己域名绑定到 GitHub Pages 的博客上。<br>于是我也就到阿里云上购买了一个万网域名，也不是很贵。<br>进入阿里云网站，打开阿里云域名控制台，点击管理，然后点击域名解析。<br><img src="https://photo.ishield.cn/pic/5b8ca34f9dc6d611b60ee2cf" alt=""><br><img src="https://photo.ishield.cn/pic/5b8ca3669dc6d611b60ee2d0" alt=""></p><p>在下图中点击添加记录，添加解析：</p><blockquote><p>记录类型选择<code>CNAME</code><br>主机记录填 <code>www</code><br>解析线路选择 <code>默认</code><br>记录值填 <code>yourname.github.io</code><br>TTL 值为 <code>10</code> 分钟<br>再添加一个解析，记录类型 <code>A</code><br>主机记录填 <code>@</code><br>解析线路选择 <code>默认</code><br>记录值填你 GitHub 的 IP 地址 (在 cmd 中 ping：<code>ping yourname.github.io</code>)<br><img src="https://ww3.sinaimg.cn/large/005YhI8igy1fuw67ojfrmj31ba05pgm6" alt=""></p></blockquote><p>在本地博客的 source 目录下新建一个 CNAME 文件(没有扩展名)，用记事本打开填入购买的域名地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.strongwong.top</span><br></pre></td></tr></table></figure></p><p>将博客重新发布一次：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d<span class="comment">#generate 和 deploy 的组合命令</span></span><br></pre></td></tr></table></figure></p><p>此时，在浏览器中输入你的个人域名(<a href="https://www.strongwong.top/" target="_blank" rel="noopener">www.strongwong.top</a>)，如果正常访问你的博客就说明，域名绑定成功，域名解析成功啦！！在这伟大的互联网时代，终于拥有了自己的网站啦！</p><h3 id="发表一篇文章"><a href="#发表一篇文章" class="headerlink" title="发表一篇文章"></a>发表一篇文章</h3><p>运行下面的命令，就会创建一个文章文件，在本地博客的 source_posts 文件夹下就会有一个新建的 markdown 文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"文章标题"</span>   <span class="comment"># hexo n "文章标题" 这种简写也可以</span></span><br></pre></td></tr></table></figure></p><p>文章编辑好之后，推送到 GitHub 上我们在站点上就可以看到新的文章了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g  <span class="comment">#生成 </span></span><br><span class="line">$ hexo d  <span class="comment">#部署</span></span><br></pre></td></tr></table></figure></p><h2 id="安装-Next-主题及个性化"><a href="#安装-Next-主题及个性化" class="headerlink" title="安装 Next 主题及个性化"></a>安装 Next 主题及个性化</h2><p>Hexo 有非常多的主题可以选择，可以到官方主题库进行选择： <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>我这里选择了资料相对详细、丰富的 Next 主题，前往 Next 主题发布页面下载：<a href="https://github.com/iisnan/hexo-theme-next/releases/" target="_blank" rel="noopener">https://github.com/iisnan/hexo-theme-next/releases/</a><br>下载最新版本的 Next 主题包，解压缩，将文件名称改为 next，放置到博客根目录的 themes 目录下。<br>打开站点配置文件 <code>_config.yml</code>，找到 themes 字段，修改为 next。<br>到此，next 主题安装完成。</p><p>关于 next 主题的一些配置请查阅 next 主题官方文档：<a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">https://theme-next.iissnan.com/</a></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>花了两天时间把博客搭起来，还是挺开心的。博客使用 Hexo 搭建，主题使用 Next，评论系统使用 Valine ，文章浏览统计使用 LeanCloud ，网站访客数量使用不蒜子，另外还使用了 Google 统计，方便自己查看数据。<br>我会坚持在工作之余，写点技术分享，记录一下我的学习历程。我也不知道我会分享哪些东西，但是我想可能还是嵌入式软件方面可能会比较多一些吧，其他方面也可能会分享一些学习、工作、生活中的经历和经验吧！祝我未来，越来越好！</p><p>strongwong</p><p>2018.8.2</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用-Hexo-Github-Pages-搭建个人博客记录&quot;&gt;&lt;a href=&quot;#使用-Hexo-Github-Pages-搭建个人博客记录&quot; class=&quot;headerlink&quot; title=&quot;使用 Hexo+Github Pages 搭建个人博客记录&quot;&gt;&lt;/a&gt;使用 Hexo+Github Pages 搭建个人博客记录&lt;/h2&gt;&lt;p&gt;最近在学习的时候发现很多人都推荐说，要学会写作。很多大牛都会有自己的博客，或者微信公众号。不仅要学会学习，更要学会表达，而写作就是一个很好的方式。通过把自己学到的东西再次输出出来，才有价值，写作是一个人吸收知识，并增强记忆转化成自己东西的过程。很多人认为学校里出来了之后应该会很少写文字了，其实不然，在工作中经常会有各种各样的汇报和报告需要你去写。&lt;br&gt;如果你不经常去写一些文字，慢慢的也就生疏了，也就忘了该怎么通过书面方式更好的表达信息。比如我们领导让大家每周写一份周报，每到周五的时候大家总是在纠结，这周报该怎么写。还有做测试的时候要有测试方案，测试结果，测试报告（分析）都是要写文档的。跟文字打交道的时候还是很多的啊！所以啊，平时还得多写写！&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://blog.strongwong.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="blog" scheme="https://blog.strongwong.top/tags/blog/"/>
    
      <category term="教程" scheme="https://blog.strongwong.top/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于</title>
    <link href="https://blog.strongwong.top//posts/%E5%85%B3%E4%BA%8E.html"/>
    <id>https://blog.strongwong.top//posts/关于.html</id>
    <published>2018-07-28T10:59:50.000Z</published>
    <updated>2018-08-14T13:06:05.284Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎您访问我的网站，希望我分享的东西会对您有一些帮助！<br>祝您 Coding 愉快！</p><a id="more"></a><p>关于我，你什么也不需要知道，哈哈哈~~</p><p>关于本站，我有时间就写点东西喽，嘿嘿~~，开心就好！</p><p>关于分享什么，聊一点技术、谈一点理想、做一点实事不枉来世一遭！</p><p>达则兼济天下，穷则独善其身~~</p><p>做一个快乐的程序员！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎您访问我的网站，希望我分享的东西会对您有一些帮助！&lt;br&gt;祝您 Coding 愉快！&lt;/p&gt;
    
    </summary>
    
      <category term="Testing" scheme="https://blog.strongwong.top/categories/Testing/"/>
    
    
      <category term="Testing" scheme="https://blog.strongwong.top/tags/Testing/"/>
    
      <category term="Another Tag" scheme="https://blog.strongwong.top/tags/Another-Tag/"/>
    
  </entry>
  
</feed>
